<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ACG音乐推荐(1) —— 那些最喜欢的]]></title>
    <url>%2Fblogs%2Fc784bcde%2F</url>
    <content type="text"><![CDATA[想想算来入宅3有余，看了也有200多部动漫了 ，喜欢的动画音乐也不计其数。动画音乐自出生起就有动画本身所赋予的情感生命。所以，对于我来说每一首动画音乐都是有生命的，都是来自某个动画世界里的声音。 但是，人的精力总归是有限的，不可每天都能把所有的听一遍，所以这里就要发挥人类喜欢排名这个喜好了。在这里推荐一些我最喜欢的ACG音乐。 我一直相信好的音乐是能够与心共鸣的。 さようなら（再见）——《小林家的龙女仆》 “早知道，我就多夸夸她做的蛋包饭了……” 人总是在失去的时候才知道原来拥有的是多么宝贵。对于托尔来说，小林的一生只相当于龙的几个月而已,转眼就是生死离别。 “可是，我最喜欢小林了” 所以，即使知道那样的结局也依然要在一起，因为喜欢，所以更珍惜陪伴的每一刻。每当听到这首音乐，不论开心，还是不开心，无论生活如何欺骗我，让我有着怎么样的心情，都能让我瞬间平静，去接纳我所经历的每一刻。去期待未来的每一种可能。 きみにとどけ(留在你身边） —— 《好想告诉你》 这份天真烂漫的心情也好那一同开怀大笑的日子也好我都想慎重地培养好它们你穿过断断续续的时空给了我许多的第一次连接起来 到达你身边 这首歌是少有的我没看完动画但依然百听不厌的。（剧情真的快急死我了，真不愧“好想急死你”）老夫的少女心啊~~~我想谈恋爱~每次听这首歌心情都能好起来，可能是因为这首歌将那份青涩的爱情完美的传达了吧。 ヒャダインとももクロのじょーじょーゆーじょー —— 《日常》OP2 我们每天度过的所谓的日常，说不定是一个个连续的奇迹呢 最上川 i do —— 《攻壳机动队》 var ap = new APlayer({ element: document.getElementById("aplayer-WTDlJcoQ"), narrow: false, autoplay: false, showlrc: false, music: { title: "i do", author: "laria Graziano", url: "i do - Ilaria Graziano.mp3", pic: "/blogs/c784bcde/i%20do.png", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 其实在入宅之前就听过攻壳的大名，但知道入宅很久后，也一直没有看。直到听到这首歌（话说我的很多补番都是因为先听歌然后才去看的动画）。才开始慢慢补动画。不过到现在也没看完，或许等到补完。对于这首歌能有更多的感触。 again —— 《钢之炼金术师》ブラーチヤ ——《钢之炼金术师》 钢炼无疑是一部极为优秀的动画，但相较于动画，我更喜欢这两首音乐。特别是第二首兄弟 亲爱的妈妈！你是如此温柔！我們很爱你。但我們所有的努力竟都是徒劳无功的。我自己被美丽的希望所诱惑想要回到我們的家我的兄弟，都是我的错。但我们应该怎么办？ 可以说是完美的表现了那场禁忌术式之后兄弟二人复活母亲愿望破灭后的痛苦，哥哥另弟弟失去身体的自责和懊悔，和兄弟二人擦干眼泪决心向前的心情。 となりのトトロ —— 《龙猫》 var ap = new APlayer({ element: document.getElementById("aplayer-bEVapmNv"), narrow: false, autoplay: false, showlrc: false, music: { title: "となりのトトロ（龙猫）", author: "井上あずみ", url: "となりのトトロ(隔壁的龙猫).mp3", pic: "/blogs/c784bcde/longmao.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 永远不会忘记两个小女孩围着一夜长出来的小树高兴的一遍一遍喊道： “好像在做梦”“可是不是梦” 也永远不会忘记猫巴士在田野上奔驰的身影。人们说，长大了，就在也看不到龙猫了。是么？另外，伊藤サチコ老师的吉卜力翻唱集里翻唱了很多宫崎骏动画的歌曲，也很不错。推荐。 今まで何度も —— 《火影忍者》 作为从小学追火影十几年到大学的人，实在不知道那首歌是最喜欢的。记得小时候除了电视里放的龙珠，数码宝贝这些，火影只能从哥哥给我的盗版光盘里看到。所以前100多集不知道在DVD里看了多少遍，里面的音乐都成为了童年珍贵的记忆，况且确实很棒。不过非要我选一首的话，我选择这首今まで何度も，即使现在我还常听。 今まで何度も なんとかあきらめずに迄今为止 有数次 总之别放弃今まで何度も 立ちあがってきたじゃないか迄今为止 有数次 为何不能重新振作今まで何度も 僕ら 何度も 信じて 何度も 夢見て迄今为止 有数次 重新相信 有数次 梦见何度も…有数次…今まで何度も バカを見てきたじゃないか迄今为止 有数次 都是懊恼万分今まで何度も 人のかげに立ってきたじゃないか迄今为止 有数次 在逆境中成长さぁ 主役だよ 自分の夢くらい わがままでいさせて这就是坚强的意志 放任自己去追求心中的梦想吧木叶十二小强集体照 这首歌就是那时我对火影里人物的印象，一群无论有什么困难，无论失败多少次都能再次站起来追求梦想的人。没有转世什么的……还有，那时的火影拯救了我。 One more time, One more chance —— 《秒速五厘米》 var ap = new APlayer({ element: document.getElementById("aplayer-XCVnlSHW"), narrow: false, autoplay: false, showlrc: false, music: { title: "One more time, One more chance", author: "山崎まさよし", url: "山崎まさよし - One more time, One more chance.mp3", pic: "/blogs/c784bcde/One%20more%20time,%20One%20more%20chance.png", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 呐，你知道吗？听说樱花飘落的速度是秒速五厘米哦 这首我觉得就不需要多说了。 For フルーツバスケット —— 《水果篮子》 记得是小时候应该星空卫视播放过，虽然我一点都不记得动画讲的什么，后来遇到这首歌，如此柔软的声音，我想动画里也一定有如此温柔的人吧。直到现在我都没看这部动画，没有各种原因，只是觉得这首歌就够了，听了这首歌仿佛就能感受到动画里传达的感情。 たとえ苦しい今日だとしても即使今天充满痛苦いつかあたたかな想い出になる总有一天 它会成为温馨的回忆心ごとすべてなげだせたなら只要我们的心被感动ここに生きてる意味がわかるよ我明白生存在这的意义生まれおちた歓びを知る也了解诞生于世的快乐Let’s stay together いつも让我们永远在一起 如此美丽的声音，却因癌症在04年离而消逝。 secret base ~君がくれたもの~ (10 years after Ver.) —— 《未闻花名》 虽然这首歌不是动画原创，但是我觉得还是写上来吧。 最喜欢仁太了，是想成为仁太新娘的那种喜欢面码，找到你了 催人泪下的剧情，加上这音乐，每到关键时刻这首歌就会响起，于是搞得眼泪在不停的在眼里打转。第一次感受到了音乐出现时机的重要性。 あなたがいた森 (曾有你的森林)——《Fate/Stay night 》 每次听到这首歌就想到吾王站在草原上杵着剑，微风吹过金发的样子，好美。 8遵从召唤而来，我问你，你是我的Master吗?贝狄威尔，不要露出这样的表情. 剑鞘正在治疗我的伤， 我不会就这样一睡不醒的.抱歉贝狄威尔 这次我将会…睡得…久一点…* God knows —— 《凉宫春日的忧郁》いつもの風景 —— 《凉宫春日的忧郁》 第一首相信不用多提，即使没看过凉宫，那个文化祭的演唱片段也一定会看过。最令我印象深刻的就是大明神的吉他了，我不懂音乐，但我就是觉得好听，厉害。第二首如果看过凉宫一定不会陌生，它常常伴随着阿虚的吐槽出现。每当听到这首歌，都会想起阿虚那关于外星人的开场吐槽。心情大好。 音乐这东西，好听不好听全凭个人喜好，其实我觉得音乐并无优劣之分，只要这个音乐能打动你的心，能与你的心共鸣，就是好音乐。何必在意别人喜欢不喜欢呢？我喜欢的音乐还有很多，我只是把我百听不厌的一部分写了出来。剩下没写的和未来喜欢的，就在未来某时某刻我再来补充吧。]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kaggle：泰坦尼克幸存者预测]]></title>
    <url>%2Fblogs%2Ff4fe8c7c%2F</url>
    <content type="text"><![CDATA[泰坦尼克号是当时（1912年）世界上体积最庞大、内部设施最豪华的客运轮船，有“永不沉没”的美誉 。然而在首次航行中，泰坦尼克号与一座冰山相撞，逾1500人丧生，其中仅333具罹难者遗体被寻回。泰坦尼克号沉没事故为和平时期死伤人数最惨重的海难之一，其残骸直至1985年才被再度发现，目前受到联合国教育、科学及文化组织的保护。本次竞赛以此为背景，根据提供的乘客数据来预测这些乘客能否生还（当然真实的情况要比这复杂得多）。 123456789101112import pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport seaborn as snsimport osimport warningswarnings.filterwarnings('ignore')%matplotlib inlineimport matplotlibmatplotlib.rcParams['axes.unicode_minus']=False 导入数据12345titanic = pd.read_csv(r'E:\DataScience\ML\Titanic\train.csv')titanic_test = pd.read_csv(r'E:\DataScience\ML\Titanic\test.csv')titanic.head(10) .dataframe tbody tr th:only-of-type {vertical-align: middle;}.dataframe tbody tr th {vertical-align: top;}.dataframe thead th {text-align: right;}PassengerIdSurvivedPclassNameSexAgeSibSpParchTicketFareCabinEmbarked0103Braund, Mr. Owen Harrismale22.010A/5 211717.2500NaNS1211Cumings, Mrs. John Bradley (Florence Briggs Th…female38.010PC 1759971.2833C85C2313Heikkinen, Miss. Lainafemale26.000STON/O2. 31012827.9250NaNS3411Futrelle, Mrs. Jacques Heath (Lily May Peel)female35.01011380353.1000C123S4503Allen, Mr. William Henrymale35.0003734508.0500NaNS5603Moran, Mr. JamesmaleNaN003308778.4583NaNQ6701McCarthy, Mr. Timothy Jmale54.0001746351.8625E46S7803Palsson, Master. Gosta Leonardmale2.03134990921.0750NaNS8913Johnson, Mrs. Oscar W (Elisabeth Vilhelmina Berg)female27.00234774211.1333NaNS91012Nasser, Mrs. Nicholas (Adele Achem)female14.01023773630.0708NaNC 单词 翻译 Key survival 是否幸存 0 = No, 1 = Yes pclass 社会阶层 1 = 精英, 2 = 中层 , 3 = 普通民众 sex 性别 Age 年龄 sibsp 船上兄弟/姐妹的个数 parch 船上父母/孩子的个数 ticket 船票号 fare 船票价格 cabin 船舱号码 embarked 登船口 C = Cherbourg, Q = Queenstown, S = Southampton 123# 查看数据简单的统计titanic.describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } PassengerId Survived Pclass Age SibSp Parch Fare count 891.000000 891.000000 891.000000 714.000000 891.000000 891.000000 891.000000 mean 446.000000 0.383838 2.308642 29.699118 0.523008 0.381594 32.204208 std 257.353842 0.486592 0.836071 14.526497 1.102743 0.806057 49.693429 min 1.000000 0.000000 1.000000 0.420000 0.000000 0.000000 0.000000 25% 223.500000 0.000000 2.000000 20.125000 0.000000 0.000000 7.910400 50% 446.000000 0.000000 3.000000 28.000000 0.000000 0.000000 14.454200 75% 668.500000 1.000000 3.000000 38.000000 1.000000 0.000000 31.000000 max 891.000000 1.000000 3.000000 80.000000 8.000000 6.000000 512.329200 123# 查看数据概要titanic.info() &lt;class &apos;pandas.core.frame.DataFrame&apos;&gt; RangeIndex: 891 entries, 0 to 890 Data columns (total 12 columns): PassengerId 891 non-null int64 Survived 891 non-null int64 Pclass 891 non-null int64 Name 891 non-null object Sex 891 non-null object Age 714 non-null float64 SibSp 891 non-null int64 Parch 891 non-null int64 Ticket 891 non-null object Fare 891 non-null float64 Cabin 204 non-null object Embarked 889 non-null object dtypes: float64(2), int64(5), object(5) memory usage: 83.6+ KB 从上可以看出，Age,Cabin,Fare,Embarked几个特征存在空值 123# 统计空值print(titanic.isnull().sum()) PassengerId 0 Survived 0 Pclass 0 Name 0 Sex 0 Age 177 SibSp 0 Parch 0 Ticket 0 Fare 0 Cabin 687 Embarked 2 dtype: int64 数据清洗处理缺失值12345678910# 可以填充整个dataframe的空值# titanic.fillna(0)# 也可以单独填充一列# titanic.Age.fillna(0)titanic.Age.fillna(-30, inplace=True)#查看为空的数据titanic.isnull().sum() PassengerId 0 Survived 0 Pclass 0 Name 0 Sex 0 Age 0 SibSp 0 Parch 0 Ticket 0 Fare 0 Cabin 687 Embarked 2 dtype: int64 数据分析性别Sex对生还与否的影响12# 做简单是汇总统计titanic.groupby(['Sex','Survived'])['Survived'].count() Sex Survived female 0 81 1 233 male 0 468 1 109 Name: Survived, dtype: int64 1234# 生还率统计df_sex = titanic[['Sex','Survived']].groupby(['Sex']).mean()df_sex .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Survived Sex female 0.742038 male 0.188908 12345678# 绘制柱状图df_sex.plot(kind='bar', figsize=(8,6), rot=0, fontsize=18, stacked=True)plt.grid(True, linestyle='--') 从上面可以发现，事实是与男性比女性的生存能力更强的经验常识相悖的，可以推测Lady First起到了很大的作用 社会阶层 Pclass与生还与否的关系12# 统计titanic.groupby(['Pclass', 'Survived'])['Pclass'].count() Pclass Survived 1 0 80 1 136 2 0 97 1 87 3 0 372 1 119 Name: Pclass, dtype: int64 12df_pclass = titanic[['Pclass', 'Survived']].groupby(['Pclass']).mean()df_pclass .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Survived Pclass 1 0.629630 2 0.472826 3 0.242363 1234567# 绘制柱状图df_pclass.plot(kind='bar', rot=0, fontsize=18, figsize=(8,6))plt.show() 可以看到，等级越高的人，生存几率越大，那么ladyfirst能否跨越等级界限呢？ 12df_psex = titanic[['Pclass', 'Sex', 'Survived']].groupby(['Pclass', 'Sex']).mean()df_psex .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Survived Pclass Sex 1 female 0.968085 male 0.368852 2 female 0.921053 male 0.157407 3 female 0.500000 male 0.135447 12345df_psex.plot(kind='bar', rot=0, fontsize=12, figsize=(8,6))plt.show() 可以看到，ladyfirst确实跨越了社会等级界限，普通阶层的女性的生还率都高于精英阶层的男性生还率。不过，无法忽视的是，不同等级的生还率还是有一定区别的。 年龄Age对生还与否的影响绘图分析不同阶层和不同性别下的年龄分布情况以及与生还的关系 1234567891011# 绘图分析不同阶层和不同性别下的年龄分布情况以及与生还的关系fig, ax = plt.subplots(1, 2, figsize=(18,8))sns.violinplot('Pclass','Age', hue='Survived', data=titanic, split=True, ax=ax[0])ax[0].set_title('Pclass and Age vs Survived',size=18)ax[0].set_yticks(range(0, 110, 10))sns.violinplot("Sex", "Age", hue="Survived", data=titanic, split=True, ax=ax[1])ax[1].set_title('Sex and Age vs Survived',size=18)ax[1].set_yticks(range(0, 110, 10))plt.show() 12345678910# 统计总体的年龄分布plt.figure(figsize=(10,6))plt.subplot(1,2,1)titanic['Age'].hist(bins=20)plt.xlabel('Age')plt.ylabel('Num')plt.subplot(1,2,2)titanic.boxplot(column='Age', showfliers=False)plt.show() 因为年龄缺失值填充的问题，所以中间高出很多 12345page = sns.FacetGrid(titanic, hue="Survived",aspect=4)page.map(sns.kdeplot,'Age',shade= True)page.set(xlim=(-40, titanic['Age'].max()))page.add_legend()plt.show() 可以看到，孩子和中年人更容易获救。那么规则就是 lady and children first，缺省值中死亡更多所以无法统计到年龄 123456f, ax = plt.subplots(figsize=(8,3))ax.set_title('Sex Age dist', size=20)sns.distplot(titanic[titanic.Sex=='female'].dropna().Age, hist=False, color='pink', label='female')sns.distplot(titanic[titanic.Sex=='male'].dropna().Age, hist=False, color='blue', label='male')ax.legend(fontsize=15)plt.show() 可以看到，女性更加年轻些，孩子和中老年人中男性更多 1234567f, ax = plt.subplots(figsize=(8,3))ax.set_title('Pclass Age dist', size=20)sns.distplot(titanic[titanic.Pclass==1].dropna().Age, hist=False, color='pink', label='P1',rug=True)sns.distplot(titanic[titanic.Pclass==2].dropna().Age, hist=False, color='blue', label='p2',rug=True)sns.distplot(titanic[titanic.Pclass==3].dropna().Age, hist=False, color='g', label='p3',rug=True)ax.legend(fontsize=15)plt.show() 阶层越高，年纪更老龄化 有无兄弟姐妹 SibSp 对生还与否的影响1234# 首先将数据分为有兄弟姐妹和没有兄弟姐妹两组df_sibsp = titanic[titanic['SibSp'] != 0]df_sibsp_no = titanic[titanic['SibSp'] == 0] 12345678910plt.figure(figsize=(12,6))plt.subplot(1,2,1)df_sibsp['Survived'].value_counts().plot(kind='pie',labels=['No Survived', 'Survived'], autopct = '%1.1f%%')plt.xlabel('sibsp',fontsize=18)plt.subplot(1,2,2)df_sibsp_no['Survived'].value_counts().plot(kind='pie',labels=['No Survived', 'Survived'], autopct = '%1.1f%%')plt.xlabel('sibsp_no',fontsize=18)plt.show() 有了兄弟姐妹的帮助，似乎更能在险境中存活 有无父母孩子 Parch 对生还与否的影响方法同上 1234567891011121314# 按照有无父母孩子分组df_parch = titanic[titanic['Parch'] != 0]df_parch_no = titanic[titanic['Parch'] == 0]plt.figure(figsize=(12,6))plt.subplot(1,2,1)df_sibsp['Survived'].value_counts().plot(kind='pie',labels=['No Survived', 'Survived'], autopct = '%1.1f%%')plt.xlabel('Parch',fontsize=18)plt.subplot(1,2,2)df_sibsp_no['Survived'].value_counts().plot(kind='pie',labels=['No Survived', 'Survived'], autopct = '%1.1f%%')plt.xlabel('Parch_no',fontsize=18)plt.show() 从之前的分析中知道，孩子是特殊照顾的对象，而孩子一般是有父母跟随的。即使都是成年人，互相帮助存活概率也更高。 亲人数量对生还与否的影响是否亲人越多，生还可能性越大呢？ 1234567fig,ax = plt.subplots(1, 2, figsize=(12,8))titanic[['Parch','Survived']].groupby(['Parch']).mean().plot(kind='bar',ax=ax[0])ax[0].set_title('Parch and Survived')titanic[['SibSp','Survived']].groupby(['SibSp']).mean().plot.bar(ax=ax[1])ax[1].set_title('SibSp and Survived')plt.show() 123titanic['fam_size'] = titanic['SibSp'] + titanic['Parch'] + 1titanic[['fam_size','Survived']].groupby(['fam_size']).mean().plot.bar(figsize=(8,6))plt.show() 从上可以看出，家庭成员在1-4人生还率最高，推测应该是这样正好组成了可以互帮互助，行动又不臃肿从小组。而后面7人家庭成员的存活率上升，推测应该是人数上升后，至少存活一人的概率增加。 票价 Fare 对生还与否的影响12345# 绘制票价分布图titanic['Fare'].plot(kind='hist',bins=100,figsize=(10,6), grid=True)titanic.boxplot(column='Fare', by='Pclass',showfliers=False,figsize=(10,6))plt.show() 1titanic['Fare'].describe() count 891.000000 mean 32.204208 std 49.693429 min 0.000000 25% 7.910400 50% 14.454200 75% 31.000000 max 512.329200 Name: Fare, dtype: float64 12# 绘制生还者非生还者票价分析titanic.boxplot(column='Fare', by='Survived',showfliers=False,showmeans=True) 可以看到，幸存者的票价普遍更高，符合之前阶层越高，生还几率越大的推测 船舱号码 Cabin 对生还与否的影响按照查询的资料，我认为乘客所处的船舱应该是跟是否生还有很大关系的，特别是下层的乘客，下部船舱快速进水，通向甲板的路不难想象也是混作一团，这就大大减少了生还可能。但是，此字段缺失数据多达600多个，所以只做下简单的数据分析。（不过我认为，票价和船舱应该有对应关系，如果能知道票价与船舱对应的史料就最好了） 1titanic.Cabin.isnull().value_counts() True 687 False 204 Name: Cabin, dtype: int64 1titanic.groupby(by=titanic.Cabin.isnull())['Survived'].mean() Cabin False 0.666667 True 0.299854 Name: Survived, dtype: float64 由上可知，缺失值的生存率很低，那么可以将Cabin是否为空作为一个特征！ 123456789titanic['Cabin_fir'] = titanic.Cabin.fillna('0').str.split(' ').apply(lambda x: x[0][0])df_cabin_fir = titanic.groupby(by='Cabin_fir')['Survived'].mean()print(df_cabin_fir)df_cabin_fir.plot(kind='bar', rot=0, legend=True,figsize=(10,8), fontsize=12)plt.show() Cabin_fir 0 0.299854 A 0.466667 B 0.744681 C 0.593220 D 0.757576 E 0.750000 F 0.615385 G 0.500000 T 0.000000 Name: Survived, dtype: float64 12df_cabin_fare = titanic.groupby(by='Cabin_fir')['Fare','Survived'].mean()df_cabin_fare .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Fare Survived Cabin_fir 0 19.157325 0.299854 A 39.623887 0.466667 B 113.505764 0.744681 C 100.151341 0.593220 D 57.244576 0.757576 E 46.026694 0.750000 F 18.696792 0.615385 G 13.581250 0.500000 T 35.500000 0.000000 在有记录的乘客中，可以发现，BC舱位总统套间，掏钱最多，DE为贵宾舱，费用中等，其余为普通舱。生还率大致符合阶层的情况。至于为何C舱生还率低于BDE，暂不分析，推测应该与所处舱位位置不佳，男性占比大，年龄偏大有关。 登船地点 Embarked 对生还与否的影响 泰坦尼克号从英国南安普敦出发，途经法国瑟堡-奥克特维尔以及爱尔兰昆士敦 —— 百度百科 南安普顿对应 S = Southampton， 瑟堡-奥克特维尔对应 C = Cherbourg，昆士敦对应 Q = Queenstown 12titanic.groupby(by='Embarked')['Survived'].mean().plot(kind='bar', rot=0, fontsize=15, legend=True)plt.show() 12df_embarked = titanic.groupby(by='Embarked')['Survived','Fare'].agg(['mean', 'count'])df_embarked .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead tr th { text-align: left; } .dataframe thead tr:last-of-type th { text-align: right; } Survived Fare mean count mean count Embarked C 0.553571 168 59.954144 168 Q 0.389610 77 13.276030 77 S 0.336957 644 27.079812 644 1234567ax = plt.figure(figsize=(10,6)).add_subplot(111)ax.set_xlim([-40, 80])sns.kdeplot(titanic[titanic.Embarked=='C'].Age, ax=ax, label='C')sns.kdeplot(titanic[titanic.Embarked=='Q'].Age, ax=ax, label='Q')sns.kdeplot(titanic[titanic.Embarked=='S'].Age, ax=ax, label='S')ax.legend(fontsize=18)plt.show() C和S上岸的乘客的年龄分布较为相似，Q上岸的人很多没有年龄。C和S比较，C口岸的人中有更多的孩子和老人 名字 Name 对生还与否的影响\通过对名字该字段的初步观察，发现名字中不但透漏出性别，还代表着一个人的地位，年龄，职业等比如Master，Miss等 123# 称谓统计titanic['Title'] = titanic.Name.apply(lambda x: x.split(',')[1].split('.')[0])titanic['Title'].value_counts() Mr 517 Miss 182 Mrs 125 Master 40 Dr 7 Rev 6 Mlle 2 Major 2 Col 2 the Countess 1 Don 1 Jonkheer 1 Mme 1 Capt 1 Sir 1 Lady 1 Ms 1 Name: Title, dtype: int64 12# 姓氏统计titanic.Name.apply(lambda x: x.split(',')[1].split('.')[1]).value_counts()[:10] John 9 James 7 Mary 6 William 6 William Henry 4 Bertha 4 Ivan 4 William John 4 Samuel 3 Patrick 3 Name: Name, dtype: int64 1titanic[['Title','Survived']].groupby(['Title']).mean() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Survived Title Capt 0.000000 Col 0.500000 Don 0.000000 Dr 0.428571 Jonkheer 0.000000 Lady 1.000000 Major 0.500000 Master 0.575000 Miss 0.697802 Mlle 1.000000 Mme 1.000000 Mr 0.156673 Mrs 0.792000 Ms 1.000000 Rev 0.000000 Sir 1.000000 the Countess 1.000000 123# 不同称呼的生存率统计titanic[['Title','Survived']].groupby(['Title']).mean().plot.bar(rot=45, figsize=(15,6), fontsize=12)plt.show() 可以看到，称谓确实与获救率有关，以为称谓往往与人的性别，地位有关。 换个角度，我们知道，歪果仁的名字中通常会加入家族名字，爵位等，所以是不是名字越长就越能像是一个家族的历史和地位呢？那么名字的长短是否能够显示出人的地位从而影响到是否获救？ 1234titanic['name_len'] = titanic['Name'].apply(len)df_namelen = titanic[['name_len','Survived']].groupby(['name_len'],as_index=False).mean()df_namelen.plot.bar(x='name_len',y='Survived',figsize=(18,6),rot=0,colormap='Blues_r',alpha=0.6,fontsize=12)plt.show() 看来猜想是正确的，名字的长度确实与是否获救有一定关系 Ticket类别比较大，观察可以发现，票号开头应该代表着船舱区域，故提取分析 123titanic['Ticket_Lett'] = titanic['Ticket'].apply(lambda x: str(x)[0])titanic['Ticket_Lett'] = titanic['Ticket_Lett'].apply(lambda x: str(x))titanic.groupby(titanic['Ticket_Lett'])['Survived'].mean() Ticket_Lett 1 0.630137 2 0.464481 3 0.239203 4 0.200000 5 0.000000 6 0.166667 7 0.111111 8 0.000000 9 1.000000 A 0.068966 C 0.340426 F 0.571429 L 0.250000 P 0.646154 S 0.323077 W 0.153846 Name: Survived, dtype: float64 1titanic.groupby(titanic['Ticket_Lett'])['Survived'].mean().plot.bar(rot=0) 可以看到，船票不同开头的生存率不同，可以作为一个特征 通过以上的分析，我们发现，乘客获救与否，与多种因素有关。包括性别，年龄，阶级等。在这大灾难面前，强壮的男人死亡率反常的高，而女人和孩子反而更易存活，这不正常，但也是正常的，这应该就是文明发展的结果。 那么，如果你当时在泰坦尼克上，你是否会成功获救呢？下篇文章，将通过机器学习算法，来预测另一批乘客是否会活下来。 特征工程变量转换 变量转换的目的是将数据转换为适用于模型使用的数据，不同模型接受不同类型的数据，Scikit-learn要求数据都是数字型numeric，所以我们要将一些非数字型的原始数据转换为数字型numeric 12345678910from sklearn.preprocessing import LabelEncoderfrom sklearn.model_selection import train_test_splitfrom sklearn.linear_model import LogisticRegressionfrom sklearn.svm import SVCfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.tree import DecisionTreeClassifierfrom xgboost import XGBClassifierimport warningswarnings.filterwarnings('ignore') 1234os.chdir('E:\DataScience\ML\Titanic')data_train = pd.read_csv('train.csv')data_test = pd.read_csv('test.csv')combine = pd.concat([data_train,data_test]) 对数据进行特征工程，也就是从各项参数中提取出对输出结果有或大或小的影响的特征，将这些特征作为训练模型的依据。 一般来说，我们会先从含有缺失值的特征开始 Embarked因为该项的缺失值没几个，所以这里我们以众数来填充： 123456# 缺失值填充，众数为 Scombine['Embarked'] = combine['Embarked'].fillna('S')# dummy处理df = pd.get_dummies(combine['Embarked'], prefix='Embarked')combine = pd.concat([combine, df], axis=1).drop('Embarked', axis=1) Name_length1combine['Name_length'] = combine['Name'].apply(len) Title123456789combine['Title'] = combine['Name'].apply(lambda x: x.split(',')[1]).apply(lambda x:x.split('.')[0])combine['Title'] = combine['Title'].apply(lambda x: x.strip())combine['Title'] = combine['Title'].replace(['Major','Capt','Rev','Col','Dr'],'officer')combine['Title'] = combine['Title'].replace(['Mlle','Miss'], 'Miss')combine['Title'] = combine['Title'].replace(['Mme','Ms','Mrs'], 'Mrs')combine['Title'] = combine['Title'].replace(['Master','Jonkheer'], 'Master')combine['Title'] = combine['Title'].replace(['Don', 'Sir', 'the Countess', 'Dona', 'Lady'], 'Royalty')df = pd.get_dummies(combine['Title'],prefix='Title')combine = pd.concat([combine,df], axis=1) Fare该项只有一个缺失值，对该值进行填充,我们可以按照阶级均价来填充 1combine['Fare'] = combine['Fare'].fillna(combine.groupby('Pclass')['Fare'].transform(np.mean)) 通过对Ticket简单的统计，我们可以看到部分票号数据有重复，同时结合亲属人数及名字的数据，和票价船舱等级对比，我们可以知道购买的票中有团体票，所以我们需要将团体票的票价分配到每个人的头上 123combine['Group_Ticket'] = combine['Fare'].groupby(by=combine['Ticket']).transform('count')combine['Fare'] = combine['Fare'] / combine['Group_Ticket']combine.drop(['Group_Ticket'], axis=1, inplace=True) 123456# 分级combine['Fare_1'] = np.where(combine['Fare'] &lt;= 7.91,1,0)combine['Fare_2'] = np.where((combine['Fare'] &gt; 7.91) &amp; (combine['Fare'] &lt;= 14.454),1,0)combine['Fare_3'] = np.where((combine['Fare'] &gt; 14.454)&amp; (combine['Fare'] &lt;= 31),1,0)combine['Fare_4'] = np.where((combine['Fare'] &gt; 31),1,0)combine = combine.drop('Fare',axis=1) Dead_female_family &amp; Survive_male_family前面分析可以知道，家庭的行为具有一致性，那么如果家族中有一个女的死亡，那么其他女性也倾向于死亡，反之，如果有男性生还，其他男性也会倾向于生还，为了防止模型无脑判断女性生还和男性死亡，在这里分出这两类情况。 1234567combine['Fname'] = combine['Name'].apply(lambda x:x.split(',')[0])combine['Familysize'] = combine['SibSp']+combine['Parch']dead_female_Fname = list(set(combine[(combine.Sex=='female') &amp; (combine.Age&gt;=12) &amp; (combine.Survived==0) &amp; (combine.Familysize&gt;1)]['Fname'].values))survive_male_Fname = list(set(combine[(combine.Sex=='male') &amp; (combine.Age&gt;=12) &amp; (combine.Survived==1) &amp; (combine.Familysize&gt;1)]['Fname'].values))combine['Dead_female_family'] = np.where(combine['Fname'].isin(dead_female_Fname),1,0)combine['Survive_male_family'] = np.where(combine['Fname'].isin(survive_male_Fname),1,0)combine = combine.drop(['Name','Fname','Familysize'],axis=1) AgeAge缺失值太多，可以按照阶级性别的平均年龄填充，也可以利用机器学习算法来预测,这里我们采用第一种方法 12345group = combine.groupby(['Title', 'Pclass'])['Age']combine['Age'] = group.transform(lambda x: x.fillna(x.median()))combine['IsChild'] = np.where(combine['Age']&lt;=12,1,0)# combine['Age'] = pd.cut(combine['Age'],5)combine = combine.drop(['Title'],axis=1) CabinCabin的缺失值太多，但是根据之前的分析，该特征值的有无与生还与否也相关性，所以我们将其分为两类 123combine['Cabin_0'] = np.where(combine['Cabin'].isnull(),1,0)combine['Cabin_1'] = np.where(combine['Cabin'].isnull(),0,1)combine = combine.drop('Cabin',axis=1) PclassPclass这一项，只需要将其转换为dummy形式就可以了 12df = pd.get_dummies(combine['Pclass'], prefix='Pclass')combine = pd.concat([combine, df], axis=1).drop('Pclass',axis=1) TicketTicket 在前面并没有分析，主要是因为里面有英文有数字，难以分析出规律，但是只看英文数字结合的票号，不难发现，票号前面的英文应该代表着位置信息，那么位置影响逃生路线，故将这部分提取出来做特征处理 1234567combine['Ticket_Lett'] = combine['Ticket'].apply(lambda x: str(x)[0])combine['Ticket_Lett'] = combine['Ticket_Lett'].apply(lambda x: str(x))combine['High_Survival_Ticket'] = np.where(combine['Ticket_Lett'].isin(['1', '2', 'P','9','F']),1,0)combine['mid_Survival_Ticket'] = np.where(combine['Ticket_Lett'].isin(['3','4','L','S']),1,0)combine['Low_Survival_Ticket'] = np.where(combine['Ticket_Lett'].isin(['A','W','6','7']),1,0)combine = combine.drop(['Ticket','Ticket_Lett'],axis=1) Sex对Sex进行one-hot编码 12df = pd.get_dummies(combine['Sex'], prefix='Sex')combine = pd.concat([combine, df],axis=1).drop('Sex',axis=1) Parch and SibSp亲友数量是会影响到生存率的，那么将这两项合为一项 12345combine['Family_size'] = np.where((combine['Parch']+combine['SibSp']==0),'Alone', np.where((combine['Parch']+combine['SibSp']&lt;=3),'Small','Big'))df = pd.get_dummies(combine['Family_size'], prefix='Family_size')combine = pd.concat([combine,df],axis=1).drop(['SibSp','Parch','Family_size'],axis=1) 将所有特征转换正数值型编码12345features = combine.drop(["PassengerId","Survived"], axis=1).columnsle = LabelEncoder()for feature in features: le = le.fit(combine[feature]) combine[feature] = le.transform(combine[feature]) 将训练数据和测试数据分开123x_train = combine.iloc[:891,:].drop(['PassengerId', 'Survived'],axis=1)y_train = combine.iloc[:891,:]['Survived']x_test = combine.iloc[891:,:].drop(['PassengerId','Survived'], axis=1) 模型比较123456789101112131415161718192021222324252627282930313233343536373839404142# logistic RegressionLogreg = LogisticRegression()Logreg.fit(x_train,y_train)y_pred = Logreg.predict(x_test)acc_logreg = round(Logreg.score(x_train, y_train) * 100,2)# Support Vector Machinessvc = SVC()svc.fit(x_train, y_train)y_pred = svc.predict(x_test)acc_svc = round(svc.score(x_train, y_train) *100,2)# K-Nearest Neighborsknn = KNeighborsClassifier(n_neighbors=3)knn.fit(x_train, y_train)y_pred = knn.predict(x_test)acc_knn = round(knn.score(x_train, y_train) * 100, 2)# Random Forestrf = RandomForestClassifier(n_estimators=100)rf.fit(x_train, y_train)y_pred = rf.predict(x_test)acc_rf = round(rf.score(x_train, y_train) * 100, 2)# Decision Treedec_tree = DecisionTreeClassifier()dec_tree.fit(x_train, y_train)y_pred = dec_tree.predict(x_test)acc_dec_tree = round(dec_tree.score(x_train,y_train) * 100,2)# XGBoostxgb = XGBClassifier(max_depth=3, n_estimators=300, learning_rate=0.03)xgb.fit(x_train,y_train)y_pred = xgb.predict(x_test)acc_xgb = round(xgb.score(x_train,y_train) * 100, 2)models = pd.DataFrame(&#123;'model':['Logreg','svc','knn','rf','dec_tree','xgb'], 'Score':[acc_logreg,acc_svc,acc_knn,acc_rf,acc_dec_tree,acc_xgb]&#125;)print(models.sort_values(by='Score', ascending=False)) Score model 4 99.21 dec_tree 3 99.10 rf 5 88.55 xgb 2 87.32 knn 1 87.09 svc 0 86.31 Logreg 12345# XGBxgb = XGBClassifier()xgb.fit(x_train,y_train)y_pred = xgb.predict(x_test).astype(int)# 该列必须是整型，否则格式不对，得分0分（别问我怎么知道的）# 只得到了78分的成绩 12subminssion = pd.DataFrame(&#123;"PassengerId": data_test["PassengerId"],"Survived": y_pred&#125;)subminssion.to_csv('submission.csv',index=False) 最后，提交结果后，发现得到了11% 的排名，这里没有做模型融合，模型的调参也不怎么熟练，特征工程也做的一般，所以还是有很大的优化空间的。]]></content>
      <categories>
        <category>机器学习项目</category>
        <category>kaggle</category>
      </categories>
      <tags>
        <tag>kaggle</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计分析之集中趋势与离中趋势]]></title>
    <url>%2Fblogs%2Fd999db0%2F</url>
    <content type="text"><![CDATA[统计指标对定量数据进行统计描述，常从集中趋势和离中趋势两个方面进行分析 集中趋势度量 指一组数据向某一中心靠拢的倾向，核心在于寻找数据的代表值或中心值 取得集中趋势代表值的方法有两种：数值平均数和 位置平均数 数值平均数 算数平均数 调和平均数 几何平均数 位置平均数 众数 中位数 数值平均数算数平均数 关注数值，鲁棒性弱（稳定性较弱，易受到异常值影响） 12345678910111213data = pd.DataFrame(&#123;'value':np.random.randint(100,120,100), 'f':np.random.rand(100)&#125;)data['f'] = data['f'] / data['f'].sum() # f为权重，这里将f列设置成总和为1的权重占比print(data.head())print('-----------------')# 算数平均值mean = data['value'].mean()print('算数平均数为：%.2f'%mean)mean_w = (data['value'] * data['f']).sum() / data['f'].sum()print('加权算数平均值为：%.2f'%mean_w)# 加权算数平均值 = (x1f1 + x2f2 + ... + xnfn) / (f1 + f2 + ... + fn) f value 0 0.014970 118 1 0.007184 116 2 0.007459 101 3 0.005892 110 4 0.016599 119 ----------------- 算数平均数为：110.09 加权算数平均值为：110.69 几何平均数 计算几何平均数要求各观察值之间存在连乘积关系，它的主要用途是 对比率、指数等进行平均 计算平均发展速度 样本数据非负，主要用于对数正态分布 复利下的平均年利率 连续作业的车间求产品的平均合格率 $$G_{n} = \sqrt[n]{x_{1}x_{2}x_{3}x_{4}x_{…}x_{n}}\$$ 几何平均数(百度百科) 123456# 一位投资者持有股票，1996年，1997年，1998年，1999年收益率分别为# 4.5%, 2.0%, 3.5%, 5.4%,# 求此4年内平均收益率from scipy.stats import gmeandata_g = gmean(data['value'])data_g 109.96165465844449 位置平均数 中位数： 关注顺序，鲁棒性强 众数： 关注频次 123456789101112131415161718192021222324252627282930313233# 中位数med = data['value'].median()print('中位数为%i' % med)# 中位数指将总体各单位标志按照大小顺序排列后，中间位置的数字# 众数m = data['value'].mode()print('众数为',m.tolist())# 众数是一组数据中出现次数最多的数，这里可能返回多个值# 密度曲线data['value'].plot(kind='kde',style='--k',grid=True,figsize=(10,6))# 简单算术平均plt.axvline(mean,hold=None,color='r',linestyle='--',alpha=0.8)plt.text(mean+5,0.005,'简单算术平均值：%.2f' % mean,color='r',fontsize=15)# 加权平均数plt.axvline(mean_w,hold=None,color='b',linestyle='--',alpha=0.8)plt.text(mean+5,0.01,'加权平均值：%.2f' % mean_w,color='b',fontsize=15)# 几何平均数plt.axvline(data_g,hold=None,color='g',linestyle='--',alpha=0.8)plt.text(mean+5,0.015,'几何平均值：%.2f' % data_g,color='g',fontsize=15)# 中位数plt.axvline(med,hold=None,color='y',linestyle='--',alpha=0.8)plt.text(mean+5,0.020,'几何平均值：%.2f' % med,color='y',fontsize=15) 中位数为110 众数为 [108] Text(115.09,0.02,&apos;几何平均值：110.00&apos;) 离中趋势度 是指一组数据中个数据值以不同程度偏离其中心（平均数）的趋势，又称标志变动度 12345# 创建数据，销售数据data = pd.DataFrame(&#123;'A_sale':np.random.rand(30)*1000, 'B_sale':np.random.rand(30)*1000&#125;, index = pd.period_range('20170601','20170630'))print(data.head()) A_sale B_sale 2017-06-01 574.693080 970.059264 2017-06-02 278.487440 683.602258 2017-06-03 830.472896 293.102768 2017-06-04 505.211093 268.009253 2017-06-05 316.383594 134.011541 极差与分位差 极差： 没有考虑中间值的变动情况，测定离中趋势时不准确 分位差： 从一组数据踢出部分极端值后的从新计算类似极差的指标，常用的有 四分位差，八分位差 123a_r = data['A_sale'].max() - data['A_sale'].min()b_r = data['B_sale'].max() - data['B_sale'].min()print('A产品销售额极差为：%.2f,B产品销售额极差为：%.2f'%(a_r,b_r)) A产品销售额极差为：920.98,B产品销售额极差为：914.30 123456sta = data['A_sale'].describe()stb = data['B_sale'].describe()#print(sta)a_iqr = sta.loc['75%'] - sta.loc['25%']b_iqr = stb.loc['75%'] - stb.loc['25%']print('A销售额的分位差为：%.2f, B销售额的分位差为：%.2f' % (a_iqr,b_iqr)) A销售额的分位差为：481.57, B销售额的分位差为：508.45 12345# 绘制箱型图color = dict(boxes='DarkGreen', whiskers='DarkOrange', medians='DarkBlue', caps='Gray')data.plot.box(vert=False,grid = True,color = color,figsize = (10,6))# 箱型图 方差与标准差 平均差：平均差是总体所有单位与其算术平均数的离差绝对值的算术平均数，1范数，异常值影响 $$MD = \frac{\sum_N |x - \bar{x}|}{N}$$ 方差：差的平方的均值，2范数，异常值影响 总体方差 $$\sigma^2 = \frac{\sum_N (X-E(X))^2}{N}$$ 样本方差 $$s^2 = \frac{\sum_N (x - \bar{x})^2}{N-1}$$ 标准差：方差的算数平方根（应用最广） 平均差 VS 方差：对异常值的敏感程度不同 离散系数（常用的是标准差系数：数据标准差和算数平均数的比） $$CV = \frac{\sigma}{\mu}$$ 123456789a_std = sta.loc['std']b_std = stb.loc['std']a_var = data['A_sale'].var()b_var = data['B_sale'].var()print('A销售额的标准差为：%.2f, B销售额的标准差为：%.2f' % (a_std,b_std))print('A销售额的方差为：%.2f, B销售额的方差为：%.2f' % (a_var,b_var))# 方差 → 各组中数值与算数平均数离差平方的算术平均数# 标准差 → 方差的平方根# 标准差是最常用的离中趋势指标 → 标准差越大，离中趋势越明显 A销售额的标准差为：292.12, B销售额的标准差为：293.35 A销售额的方差为：85331.19, B销售额的方差为：86052.83 1234567891011121314fig = plt.figure(figsize = (12,4))ax1 = fig.add_subplot(1,2,1)data['A_sale'].plot(kind = 'kde',style = 'k--',grid = True,title = 'A密度曲线')plt.axvline(sta.loc['50%'],hold=None,color='r',linestyle="--",alpha=0.8) plt.axvline(sta.loc['50%'] - a_std,hold=None,color='b',linestyle="--",alpha=0.8) plt.axvline(sta.loc['50%'] + a_std,hold=None,color='b',linestyle="--",alpha=0.8) # A密度曲线，1个标准差ax2 = fig.add_subplot(1,2,2)data['B_sale'].plot(kind = 'kde',style = 'k--',grid = True,title = 'B密度曲线')plt.axvline(stb.loc['50%'],hold=None,color='r',linestyle="--",alpha=0.8) plt.axvline(stb.loc['50%'] - b_std,hold=None,color='b',linestyle="--",alpha=0.8) plt.axvline(stb.loc['50%'] + b_std,hold=None,color='b',linestyle="--",alpha=0.8) # B密度曲线，1个标准差]]></content>
      <categories>
        <category>统计学习</category>
      </categories>
      <tags>
        <tag>统计学习</tag>
        <tag>特征分析</tag>
      </tags>
  </entry>
</search>
