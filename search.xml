<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于KMeans的广告效果聚类分析</title>
    <url>/blogs/3f447a11/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><p>前段时间做了一个项目，该客户是来自教育行业，其主要的宣传获客手段就是在各个渠道投放广告，用广告将用户引流至网站。</p>
<p>但是广告的渠道非常多，那些渠道效果很好，那些效果不好。需要对广告效果分析针对性做广告效果测量和优化工作。我就想到之前学到的KMeans聚类分析广告的方法，在这里整理出来。供日后参考。<br><a id="more"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer  <span class="comment"># 字符串分类转整数分类库</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler <span class="comment"># MinMaxScaler库</span></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans   <span class="comment"># KMeans 模块</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics   <span class="comment"># 效果评估模块</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set(context=<span class="string">'notebook'</span>,font=<span class="string">'simhei'</span>,style=<span class="string">'whitegrid'</span>) </span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">'./ad_data.txt'</span>,delimiter=<span class="string">'\t'</span>)</span><br><span class="line">data.head(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<div> <style scoped> .dataframe tbody tr th:only-of-type { vertical-align: middle; }  .dataframe tbody tr th { vertical-align: top; }  .dataframe thead th { text-align: right; } </style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>渠道代号</th> <th>日均UV</th> <th>平均注册率</th> <th>平均搜索量</th> <th>访问深度</th> <th>平均停留时间</th> <th>订单转化率</th> <th>投放总时间</th> <th>素材类型</th> <th>广告类型</th> <th>合作方式</th> <th>广告尺寸</th> <th>广告卖点</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>A203</td> <td>3.69</td> <td>0.0071</td> <td>0.0214</td> <td>2.3071</td> <td>419.77</td> <td>0.0258</td> <td>20.0</td> <td>jpg</td> <td>banner</td> <td>roi</td> <td>140<em>40</em></td> <td>打折</td> </tr> <tr> <th>1</th> <td>A387</td> <td>178.70</td> <td>0.0040</td> <td>0.0324</td> <td>2.0489</td> <td>157.94</td> <td>0.0030</td> <td>19.0</td> <td>jpg</td> <td>banner</td> <td>cpc</td> <td>14040</td> <td>满减</td> </tr> <tr> <th>2</th> <td>A388</td> <td>91.77</td> <td>0.0022</td> <td>0.0530</td> <td>1.8771</td> <td>357.93</td> <td>0.0026</td> <td>4.0</td> <td>jpg</td> <td>banner</td> <td>cpc</td> <td>140*40</td> <td>满减</td> </tr> </tbody> </table> </div>


<h2 id="数据审查"><a href="#数据审查" class="headerlink" title="数据审查"></a>数据审查</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.info()</span><br></pre></td></tr></table></figure>
<pre><code>&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;
RangeIndex: 889 entries, 0 to 888
Data columns (total 13 columns):
渠道代号      889 non-null object
日均UV      889 non-null float64
平均注册率     889 non-null float64
平均搜索量     889 non-null float64
访问深度      889 non-null float64
平均停留时间    887 non-null float64
订单转化率     889 non-null float64
投放总时间     889 non-null float64
素材类型      889 non-null object
广告类型      889 non-null object
合作方式      889 non-null object
广告尺寸      889 non-null object
广告卖点      889 non-null object
dtypes: float64(7), object(6)
memory usage: 90.4+ KB
</code></pre><p>从上可以看出各个字段的数据类型，并发现字段“平均停留时间”有两个缺失值。<br>对于有些数据缺失较多，不容易看出来，可以这样统计：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这样用表格形式展示每个字段有多少缺失值</span></span><br><span class="line">pd.DataFrame(data.isnull().sum(),columns=[<span class="string">"num"</span>]).T</span><br></pre></td></tr></table></figure>
<div> <style scoped> .dataframe tbody tr th:only-of-type { vertical-align: middle; }  .dataframe tbody tr th { vertical-align: top; }  .dataframe thead th { text-align: right; } </style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>渠道代号</th> <th>日均UV</th> <th>平均注册率</th> <th>平均搜索量</th> <th>访问深度</th> <th>平均停留时间</th> <th>订单转化率</th> <th>投放总时间</th> <th>素材类型</th> <th>广告类型</th> <th>合作方式</th> <th>广告尺寸</th> <th>广告卖点</th> </tr> </thead> <tbody> <tr> <th>num</th> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>2</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> </tr> </tbody> </table> </div>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 缺失值用字段均值代替</span></span><br><span class="line">data_2  = data.fillna(data[<span class="string">"平均停留时间"</span>].mean())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 描述性统计</span></span><br><span class="line"></span><br><span class="line">data_2.describe().round(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<div> <style scoped> .dataframe tbody tr th:only-of-type { vertical-align: middle; }  .dataframe tbody tr th { vertical-align: top; }  .dataframe thead th { text-align: right; } </style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>日均UV</th> <th>平均注册率</th> <th>平均搜索量</th> <th>访问深度</th> <th>平均停留时间</th> <th>订单转化率</th> <th>投放总时间</th> </tr> </thead> <tbody> <tr> <th>count</th> <td>889.000</td> <td>889.000</td> <td>889.000</td> <td>889.000</td> <td>889.000</td> <td>889.000</td> <td>889.000</td> </tr> <tr> <th>mean</th> <td>540.847</td> <td>0.001</td> <td>0.030</td> <td>2.167</td> <td>262.669</td> <td>0.003</td> <td>16.053</td> </tr> <tr> <th>std</th> <td>1634.410</td> <td>0.003</td> <td>0.106</td> <td>3.801</td> <td>224.112</td> <td>0.012</td> <td>8.509</td> </tr> <tr> <th>min</th> <td>0.060</td> <td>0.000</td> <td>0.000</td> <td>1.000</td> <td>1.640</td> <td>0.000</td> <td>1.000</td> </tr> <tr> <th>25%</th> <td>6.180</td> <td>0.000</td> <td>0.001</td> <td>1.392</td> <td>126.200</td> <td>0.000</td> <td>9.000</td> </tr> <tr> <th>50%</th> <td>114.180</td> <td>0.000</td> <td>0.003</td> <td>1.793</td> <td>236.660</td> <td>0.000</td> <td>16.000</td> </tr> <tr> <th>75%</th> <td>466.870</td> <td>0.001</td> <td>0.012</td> <td>2.216</td> <td>357.930</td> <td>0.002</td> <td>24.000</td> </tr> <tr> <th>max</th> <td>25294.770</td> <td>0.039</td> <td>1.037</td> <td>98.980</td> <td>4450.830</td> <td>0.216</td> <td>30.000</td> </tr> </tbody> </table> </div>


<p>从描述性统计我们可以看到</p>
<ol>
<li>UV的数据波动很大，说明不同渠道差异是很明显的。但是差异并不一定是异常值，广告流量的特征是有爆发性的，所以一般不作为异常值处理。</li>
<li>可以看到平均注册率，平均搜索量，订单转化率多个统计量为0，但是考虑到极大值本身就很小，说明数据本身就很小，符合实际情况，所以是正常的。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_2.corr().round(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<div> <style scoped> .dataframe tbody tr th:only-of-type { vertical-align: middle; }  .dataframe tbody tr th { vertical-align: top; }  .dataframe thead th { text-align: right; } </style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>日均UV</th> <th>平均注册率</th> <th>平均搜索量</th> <th>访问深度</th> <th>平均停留时间</th> <th>订单转化率</th> <th>投放总时间</th> </tr> </thead> <tbody> <tr> <th>日均UV</th> <td>1.00</td> <td>-0.05</td> <td>-0.07</td> <td>-0.02</td> <td>0.04</td> <td>-0.05</td> <td>-0.04</td> </tr> <tr> <th>平均注册率</th> <td>-0.05</td> <td>1.00</td> <td>0.24</td> <td>0.11</td> <td>0.22</td> <td>0.32</td> <td>-0.01</td> </tr> <tr> <th>平均搜索量</th> <td>-0.07</td> <td>0.24</td> <td>1.00</td> <td>0.06</td> <td>0.17</td> <td>0.13</td> <td>-0.03</td> </tr> <tr> <th>访问深度</th> <td>-0.02</td> <td>0.11</td> <td>0.06</td> <td>1.00</td> <td>0.72</td> <td>0.16</td> <td>0.06</td> </tr> <tr> <th>平均停留时间</th> <td>0.04</td> <td>0.22</td> <td>0.17</td> <td>0.72</td> <td>1.00</td> <td>0.25</td> <td>0.05</td> </tr> <tr> <th>订单转化率</th> <td>-0.05</td> <td>0.32</td> <td>0.13</td> <td>0.16</td> <td>0.25</td> <td>1.00</td> <td>-0.00</td> </tr> <tr> <th>投放总时间</th> <td>-0.04</td> <td>-0.01</td> <td>-0.03</td> <td>0.06</td> <td>0.05</td> <td>-0.00</td> <td>1.00</td> </tr> </tbody> </table> </div>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制分布图</span></span><br><span class="line">sns.pairplot(data_2,kind=<span class="string">'reg'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="output_10_1.png" alt="png"></p>
<p>从上述相关性的分析中看出，只有平均停留时间和访问深度虽然有相关性0.72，但是特征并不是很明显。其余特征之间相关性并不突出。</p>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将字符串转换成整数，离散化</span></span><br><span class="line"></span><br><span class="line">cols = [<span class="string">"素材类型"</span>, <span class="string">"广告类型"</span>, <span class="string">"合作方式"</span>, <span class="string">"广告尺寸"</span>, <span class="string">"广告卖点"</span>]</span><br><span class="line"></span><br><span class="line">convert_matrix = data_2[cols]</span><br><span class="line">lines = convert_matrix.shape[<span class="number">0</span>]</span><br><span class="line">dict_list = []  <span class="comment"># 存放字符串与对应索引组成的字典</span></span><br><span class="line">unique_list = []  <span class="comment"># 总唯一值列表，用于存放每个列的唯一值列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col_name <span class="keyword">in</span> cols:</span><br><span class="line">    col_unique_vlaue = data_2[col_name].unique().tolist()  <span class="comment"># 每列唯一值列表</span></span><br><span class="line">    unique_list.append(col_unique_vlaue)  <span class="comment"># 将列表存入总表</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> line_index <span class="keyword">in</span> range(lines):</span><br><span class="line">    each_record = convert_matrix.iloc[line_index]   <span class="comment"># 读取每行数据,结果是series</span></span><br><span class="line">    <span class="keyword">for</span> each_index,each_data <span class="keyword">in</span> enumerate(each_record):</span><br><span class="line">        <span class="comment"># 读取series中每行的值及其对应的index（原列名）的数字索引值。</span></span><br><span class="line">        list_value = unique_list[each_index]</span><br><span class="line">        <span class="comment"># 读取行索引对应的列唯一值</span></span><br><span class="line">        each_record[each_index] = list_value.index(each_data)</span><br><span class="line">        <span class="comment"># 将每一个值对应到唯一值列表中的索引</span></span><br><span class="line">    each_dict = dict(zip(cols,each_record))</span><br><span class="line">    dict_list.append(each_dict)</span><br><span class="line">    </span><br><span class="line">model_transform = DictVectorizer(separator=<span class="keyword">False</span>,dtype=np.int64)</span><br><span class="line">data_dicvec = model_transform.fit_transform(dict_list).toarray()</span><br></pre></td></tr></table></figure>
<p>从数据可以看到，UV和转化率这些字段的数据处在不同的量级，UV有上万，而转化率却小于1，因此需要做数据标准化，这里采用MINMAX标准化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据标准化</span></span><br><span class="line">scaler_matrix = data_2.iloc[:,<span class="number">1</span>:<span class="number">8</span>]</span><br><span class="line">minmax_scaler = MinMaxScaler()</span><br><span class="line">data_scaler = minmax_scaler.fit_transform(scaler_matrix)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并数据</span></span><br><span class="line">data3 = np.hstack((data_scaler,data_dicvec))  <span class="comment"># 横向合并</span></span><br></pre></td></tr></table></figure>
<h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><p>KMeans聚类算法的关键点在于K值的确定。KMeans作为非监督学习，并没有“最佳”K值，但是从数据特征上来讲，最佳的K值是类内距离最小化，类间距离最大化。有如平均轮廓系数，类内距离/类间距离等方法可以来评估K值。这里我们用枚举法计算每个K之下的平均轮廓系数，然后选出最大系数是K值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score_list = []   <span class="comment"># 储存系数的列表</span></span><br><span class="line">score_init = <span class="number">-1</span>   <span class="comment"># 初始轮廓系数</span></span><br><span class="line"><span class="keyword">for</span> n_k <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">11</span>):</span><br><span class="line">    model_kmeans = KMeans(n_clusters=n_k,random_state=<span class="number">0</span>)  <span class="comment"># 建立模型</span></span><br><span class="line">    cluster_tmp = model_kmeans.fit_predict(data3) <span class="comment"># 训练模型</span></span><br><span class="line">    score_tmp = metrics.silhouette_score(data3,cluster_tmp)  <span class="comment"># 得到K值的轮廓系数</span></span><br><span class="line">    <span class="keyword">if</span> score_tmp &gt; score_init:  <span class="comment"># 如果这个系数更高</span></span><br><span class="line">        good_k = n_k  <span class="comment">#储存K值</span></span><br><span class="line">        score_init = score_tmp  <span class="comment">#储存轮廓系数，做下次比较</span></span><br><span class="line">        good_model = model_kmeans  <span class="comment"># 储存模型</span></span><br><span class="line">        good_cluster = cluster_tmp  <span class="comment"># 储存聚类标签</span></span><br><span class="line">    score_list.append([n_k,score_tmp])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(score_list)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'Best K is:&#123;0&#125; with average silhouette of &#123;1&#125;'</span>.</span><br><span class="line">       format(good_k, score_init.round(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>
<pre><code>[[2, 0.4669282108253203], [3, 0.5490464644387694], [4, 0.5696854692292723], [5, 0.481866036548318], [6, 0.45477666842362924], [7, 0.4820426124661439], [8, 0.5044722277929435], [9, 0.5269749291473864], [10, 0.5433876151990182]]
Best K is:4 with average silhouette of 0.5697
</code></pre><p>可以看到，当K=4的时候，轮廓之最大。所以这里选择4作为最佳K值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cluster_labels = pd.DataFrame(good_cluster,columns=[<span class="string">'cluster'</span>])</span><br><span class="line"></span><br><span class="line">merge_data = pd.concat((data_2,cluster_labels),axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">merge_data.head()</span><br></pre></td></tr></table></figure>
<div> <style scoped> .dataframe tbody tr th:only-of-type { vertical-align: middle; }  .dataframe tbody tr th { vertical-align: top; }  .dataframe thead th { text-align: right; } </style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>渠道代号</th> <th>日均UV</th> <th>平均注册率</th> <th>平均搜索量</th> <th>访问深度</th> <th>平均停留时间</th> <th>订单转化率</th> <th>投放总时间</th> <th>素材类型</th> <th>广告类型</th> <th>合作方式</th> <th>广告尺寸</th> <th>广告卖点</th> <th>cluster</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>A203</td> <td>3.69</td> <td>0.0071</td> <td>0.0214</td> <td>2.3071</td> <td>419.77</td> <td>0.0258</td> <td>20.0</td> <td>jpg</td> <td>banner</td> <td>roi</td> <td>140<em>40</em></td> <td>打折</td> <td>3</td> </tr> <tr> <th>1</th> <td>A387</td> <td>178.70</td> <td>0.0040</td> <td>0.0324</td> <td>2.0489</td> <td>157.94</td> <td>0.0030</td> <td>19.0</td> <td>jpg</td> <td>banner</td> <td>cpc</td> <td>14040</td> <td>满减</td> <td>3</td> </tr> <tr> <th>2</th> <td>A388</td> <td>91.77</td> <td>0.0022</td> <td>0.0530</td> <td>1.8771</td> <td>357.93</td> <td>0.0026</td> <td>4.0</td> <td>jpg</td> <td>banner</td> <td>cpc</td> <td>140<em>40</em></td> <td>满减</td> <td>3</td> </tr> <tr> <th>3</th> <td>A389</td> <td>1.09</td> <td>0.0074</td> <td>0.3382</td> <td>4.2426</td> <td>364.07</td> <td>0.0153</td> <td>10.0</td> <td>jpg</td> <td>banner</td> <td>cpc</td> <td>14040</td> <td>满减</td> <td>3</td> </tr> <tr> <th>4</th> <td>A390</td> <td>3.37</td> <td>0.0028</td> <td>0.1740</td> <td>2.1934</td> <td>313.34</td> <td>0.0007</td> <td>30.0</td> <td>jpg</td> <td>banner</td> <td>cpc</td> <td>140*40</td> <td>满减</td> <td>3</td> </tr> </tbody> </table> </div>



<h2 id="寻找各个分类的数据特征"><a href="#寻找各个分类的数据特征" class="headerlink" title="寻找各个分类的数据特征"></a>寻找各个分类的数据特征</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算每个类别的计数</span></span><br><span class="line">cluster_count = pd.DataFrame(merge_data[<span class="string">"渠道代号"</span>].groupby(</span><br><span class="line">                merge_data[<span class="string">'cluster'</span>]).count()).T.rename(&#123;<span class="string">"渠道代号"</span>:<span class="string">"count"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个类别的占比</span></span><br><span class="line">cluster_ratio = (cluster_count / len(merge_data)).round(<span class="number">4</span>).rename(</span><br><span class="line">                &#123;<span class="string">"count"</span>:<span class="string">"per"</span>&#125;)</span><br><span class="line"></span><br><span class="line">cluster_features = []  <span class="comment"># 空列表，储存特征信息</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> range(good_k):</span><br><span class="line">    label_data = merge_data[merge_data[<span class="string">"cluster"</span>] == line]  <span class="comment"># 获得特定类别数据</span></span><br><span class="line">    part1_data = label_data.iloc[:,<span class="number">1</span>:<span class="number">8</span>] <span class="comment"># 获得数值型数据</span></span><br><span class="line">    part1_desc = part1_data.describe().round(<span class="number">3</span>)</span><br><span class="line">    merge_data_mean = part1_desc.iloc[<span class="number">2</span>,:]   <span class="comment"># 均值特征</span></span><br><span class="line">    </span><br><span class="line">    part2_data = label_data.iloc[:,<span class="number">8</span>:<span class="number">-1</span>]   <span class="comment"># 获得字符串数据特征</span></span><br><span class="line">    part2_desc = part2_data.describe(include=<span class="string">"all"</span>)</span><br><span class="line">    merge_data2_mean = part2_desc.iloc[<span class="number">2</span>,:]   <span class="comment"># 均值特征</span></span><br><span class="line">    merge_line = pd.concat((merge_data_mean,merge_data2_mean),axis=<span class="number">0</span>)  <span class="comment"># 合并</span></span><br><span class="line">    cluster_features.append(merge_line)  <span class="comment"># 添加到列表中</span></span><br><span class="line">    </span><br><span class="line">cluster_df = pd.DataFrame(cluster_features).T</span><br><span class="line">cluster_all = pd.concat((cluster_count,cluster_ratio,cluster_df),axis=<span class="number">0</span>)</span><br><span class="line">cluster_all</span><br></pre></td></tr></table></figure>
<div> <style scoped> .dataframe tbody tr th:only-of-type { vertical-align: middle; }  .dataframe tbody tr th { vertical-align: top; }  .dataframe thead th { text-align: right; } </style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>0</th> <th>1</th> <th>2</th> <th>3</th> </tr> </thead> <tbody> <tr> <th>count</th> <td>411</td> <td>297</td> <td>27</td> <td>154</td> </tr> <tr> <th>per</th> <td>0.4623</td> <td>0.3341</td> <td>0.0304</td> <td>0.1732</td> </tr> <tr> <th>日均UV</th> <td>1369.81</td> <td>1194.69</td> <td>1263.03</td> <td>2718.7</td> </tr> <tr> <th>平均注册率</th> <td>0.003</td> <td>0.003</td> <td>0.003</td> <td>0.005</td> </tr> <tr> <th>平均搜索量</th> <td>0.082</td> <td>0.144</td> <td>0.151</td> <td>0.051</td> </tr> <tr> <th>访问深度</th> <td>0.918</td> <td>5.728</td> <td>9.8</td> <td>0.948</td> </tr> <tr> <th>平均停留时间</th> <td>165.094</td> <td>285.992</td> <td>374.689</td> <td>104.14</td> </tr> <tr> <th>订单转化率</th> <td>0.009</td> <td>0.016</td> <td>0.017</td> <td>0.007</td> </tr> <tr> <th>投放总时间</th> <td>8.462</td> <td>8.57</td> <td>7.996</td> <td>8.569</td> </tr> <tr> <th>素材类型</th> <td>swf</td> <td>jpg</td> <td>swf</td> <td>jpg</td> </tr> <tr> <th>广告类型</th> <td>不确定</td> <td>不确定</td> <td>通栏</td> <td>banner</td> </tr> <tr> <th>合作方式</th> <td>cpc</td> <td>cpc</td> <td>cpc</td> <td>cpc</td> </tr> <tr> <th>广告尺寸</th> <td>600<em>90</em></td> <td>60090</td> <td>900<em>120</em></td> <td>308388</td> </tr> <tr> <th>广告卖点</th> <td>打折</td> <td>直降</td> <td>打折</td> <td>满减</td> </tr> </tbody> </table> </div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制极坐标图来可视化数据特征</span></span><br><span class="line"></span><br><span class="line">num_sets = cluster_df.iloc[:<span class="number">6</span>,:].T.astype(np.float64)   <span class="comment"># 提取展示的数据</span></span><br><span class="line">num_sets_minmax = minmax_scaler.fit_transform(num_sets)  <span class="comment"># 标准化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>,polar=<span class="keyword">True</span>)</span><br><span class="line">labels = np.array(merge_data_mean.index[:<span class="number">-1</span>])   <span class="comment"># 数据标签</span></span><br><span class="line">colors = [<span class="string">'r'</span>,<span class="string">'g'</span>,<span class="string">'b'</span>,<span class="string">'y'</span>]</span><br><span class="line">angles = np.linspace(<span class="number">0</span>,<span class="number">2</span>*np.pi,len(labels),endpoint=<span class="keyword">False</span>)   <span class="comment"># 计算各区间角度</span></span><br><span class="line">angles = np.concatenate((angles,[angles[<span class="number">0</span>]]))  <span class="comment"># 建立首位相同字段保证闭合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(num_sets)):</span><br><span class="line">    data_tmp =  num_sets_minmax[i,:]</span><br><span class="line">    df = np.concatenate((data_tmp,[data_tmp[<span class="number">0</span>]]))</span><br><span class="line">    ax.plot(angles,df,<span class="string">'o-'</span>,c=colors[i],label=i) </span><br><span class="line"></span><br><span class="line">ax.set_thetagrids(angles*<span class="number">180</span> / np.pi,labels,fontsize=<span class="number">12</span>)</span><br><span class="line">ax.set_title(<span class="string">"各聚类类别显著特征对比"</span>,fontsize=<span class="number">20</span>)  <span class="comment"># 设置标题放置</span></span><br><span class="line">ax.set_rlim(<span class="number">-0.2</span>, <span class="number">1.2</span>)  <span class="comment"># 设置坐标轴尺度范围</span></span><br><span class="line">plt.legend(loc=<span class="number">0</span>)  <span class="comment"># 设置图例位置</span></span><br><span class="line">plt.show()  <span class="comment"># 展示图像</span></span><br></pre></td></tr></table></figure>
<p><img src="output_23_0.png" alt="png"></p>
<h2 id="简要分析"><a href="#简要分析" class="headerlink" title="简要分析"></a>简要分析</h2><ol>
<li><p>从数据上初步分析： </p>
<ul>
<li>0号类别占比最大，但是在数据特征上没有突出的亮点，各方面都很平庸。</li>
<li>1号类别有着33%的占比，同时在平均搜索量，停留时间，访问深度及订单转化率方面表现突出</li>
<li>2号类别与1号相似度很高，并且在1号的典型特征上表现更好，但是占比过低，只有3%</li>
<li>3号类别与其他类别区别明显，体现出流量大的特征。但是流量质量较差。</li>
</ul>
</li>
<li><p>针对业务如何选择不同类别的广告商。</p>
<ul>
<li>0号广告渠道各方面表现一般，需要重新考虑投放价值，在资金紧张时可以考虑取舍。</li>
<li>1号和2号广告渠道是流量质量较高的渠道，尤其是渠道2.所以运营策略里，应该加强对注册引导，注册激励方面的引导。重点宣传打折，直降等重点，广告尺寸适宜900*120尺寸。此类广告渠道应作为流量质量支撑的角色，在投放组合中重点考虑。</li>
<li>3号渠道是典型的流量型渠道，以作为营销活动中的流量骨干，引流效果明显。投放宜以满减为促销点，广告尺寸适宜308*388.</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言中的抽样方法与描述统计函数</title>
    <url>/blogs/97bf052e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><h2 id="抽样方法"><a href="#抽样方法" class="headerlink" title="抽样方法"></a>抽样方法</h2><p>常见的抽样方法  </p>
<ul>
<li>简单随机抽样</li>
<li>分层抽样</li>
<li>系统抽样</li>
</ul>
<a id="more"></a>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line"><span class="comment"># 1 金融  2 建筑   3 外语</span></span><br><span class="line">data &lt;- read.csv(<span class="string">"E:\\Github\\code-learning\\R\\data\\第11期资料\\data.csv"</span>)</span><br><span class="line"><span class="comment"># 按照专业和ID排序</span></span><br><span class="line">data &lt;- data[order(data$专业,data$ID),]</span><br><span class="line">head(data)</span><br></pre></td></tr></table></figure>
<table> <thead><tr><th></th><th scope="col">专业</th><th scope="col">ID</th><th scope="col">收入</th></tr></thead> <tbody> <tr><th scope="row">375</th><td>1   </td><td>A001</td><td>6811</td></tr> <tr><th scope="row">360</th><td>1   </td><td>A002</td><td>3976</td></tr> <tr><th scope="row">505</th><td>1   </td><td>A003</td><td>2692</td></tr> <tr><th scope="row">470</th><td>1   </td><td>A004</td><td>8156</td></tr> <tr><th scope="row">214</th><td>1   </td><td>A005</td><td>2169</td></tr> <tr><th scope="row">450</th><td>1   </td><td>A006</td><td>6142</td></tr> </tbody> </table>



<h3 id="简单随机抽样"><a href="#简单随机抽样" class="headerlink" title="简单随机抽样"></a>简单随机抽样</h3><p>简单随机抽样最基本的抽样方法。分为重复抽样和不重复抽样。社会调查采用不重复抽样。</p>
<p>sample(x,size,replace=FALSE,prob=NULL)  </p>
<ul>
<li>x :抽样总体 </li>
<li>size: 样本容量</li>
<li>replace: 是否有放回</li>
<li>prob: 抽样概率，默认等概率</li>
</ul>
<p>使用sample函数要将数据按照升序排序</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对数据序号抽样</span></span><br><span class="line"><span class="comment"># 无放回的抽取10个样本</span></span><br><span class="line">index_11 &lt;- sample(<span class="number">1</span>:nrow(data),<span class="number">10</span>,replace = <span class="literal">FALSE</span>)</span><br><span class="line">index_11</span><br><span class="line">data[index_11,]</span><br></pre></td></tr></table></figure>
<ol class="list-inline"> <li>202</li> <li>181</li> <li>392</li> <li>222</li> <li>22</li> <li>117</li> <li>190</li> <li>247</li> <li>135</li> <li>169</li> </ol>

<table> <thead><tr><th></th><th scope="col">专业</th><th scope="col">ID</th><th scope="col">收入</th></tr></thead> <tbody> <tr><th scope="row">65</th><td>2   </td><td>B102</td><td>8522</td></tr> <tr><th scope="row">369</th><td>2   </td><td>B081</td><td>8386</td></tr> <tr><th scope="row">309</th><td>3   </td><td>C092</td><td>6151</td></tr> <tr><th scope="row">169</th><td>2   </td><td>B122</td><td>6439</td></tr> <tr><th scope="row">392</th><td>1   </td><td>A022</td><td>4371</td></tr> <tr><th scope="row">41</th><td>2   </td><td>B017</td><td>4203</td></tr> <tr><th scope="row">428</th><td>2   </td><td>B090</td><td>5392</td></tr> <tr><th scope="row">44</th><td>2   </td><td>B147</td><td>3291</td></tr> <tr><th scope="row">402</th><td>2   </td><td>B035</td><td>7097</td></tr> <tr><th scope="row">523</th><td>2   </td><td>B069</td><td>8141</td></tr> </tbody> </table>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 又放回的抽取收入大于6000的5个样本</span></span><br><span class="line">index_12 &lt;- sample(data$ID,<span class="number">5</span>,replace = <span class="literal">TRUE</span>)</span><br><span class="line">index_12</span><br></pre></td></tr></table></figure>
<ol class="list-inline"> <li>C118</li> <li>A006</li> <li>B117</li> <li>B104</li> <li>C087</li> </ol>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不等概率的随机抽样</span></span><br><span class="line">sample(c(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>),size = <span class="number">10</span>,replace = <span class="literal">TRUE</span>,</span><br><span class="line">       prob = c(<span class="number">0.1</span>,<span class="number">0.5</span>,<span class="number">0.4</span>))</span><br></pre></td></tr></table></figure>
<ol class="list-inline"> <li>‘c’</li> <li>‘c’</li> <li>‘b’</li> <li>‘c’</li> <li>‘b’</li> <li>‘b’</li> <li>‘b’</li> <li>‘a’</li> <li>‘c’</li> <li>‘b’</li> </ol>


<h3 id="分层抽样"><a href="#分层抽样" class="headerlink" title="分层抽样"></a>分层抽样</h3><p>分层抽样：先依据一种或几种特征将总体分为若干个子总体,每一子总体称作一个层;然后从每层中随机抽取若干子样本，这些子样本合起来就是总体的样本</p>
<p>strata(data, stratanames=NULL, size, method=c(“srswor”,“srswr”,“poisson”,“systematic”), pik,description=FALSE)</p>
<ul>
<li>stratanames: 分层字段</li>
<li>size: 每层样本大小</li>
<li>method:<ul>
<li>srswor：不放回随机抽样</li>
<li>srswr：放回随机抽样</li>
<li>poisson：泊松抽样</li>
<li>systematic：系统抽样</li>
</ul>
</li>
<li>pik: 各数据包含在样本中的概率，只在不等概率抽样中使用</li>
<li>description: TRUE时，显示样本个数和总体个数</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入sampling</span></span><br><span class="line"><span class="keyword">library</span>(sampling)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照专业分层抽样，各抽取1个，2个，3个，方法为不放回抽样，显示描述信息</span></span><br><span class="line">index_21 &lt;- strata(data,stratanames = <span class="string">"专业"</span>,size=c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),</span><br><span class="line">                   method = <span class="string">"srswor"</span>,description = <span class="literal">TRUE</span>)</span><br><span class="line">index_21</span><br></pre></td></tr></table></figure>
<pre><code>Stratum 1 

Population total and number of selected units: 100 1 
Stratum 2 

Population total and number of selected units: 200 2 
Stratum 3 

Population total and number of selected units: 300 3 
Number of strata  3 
Total number of selected units 6 
</code></pre><table> <thead><tr><th></th><th scope="col">专业</th><th scope="col">ID_unit</th><th scope="col">Prob</th><th scope="col">Stratum</th></tr></thead> <tbody> <tr><th scope="row">62</th><td>1   </td><td> 62 </td><td>0.01</td><td>1   </td></tr> <tr><th scope="row">241</th><td>2   </td><td>241 </td><td>0.01</td><td>2   </td></tr> <tr><th scope="row">280</th><td>2   </td><td>280 </td><td>0.01</td><td>2   </td></tr> <tr><th scope="row">359</th><td>3   </td><td>359 </td><td>0.01</td><td>3   </td></tr> <tr><th scope="row">393</th><td>3   </td><td>393 </td><td>0.01</td><td>3   </td></tr> <tr><th scope="row">399</th><td>3   </td><td>399 </td><td>0.01</td><td>3   </td></tr> </tbody> </table>



<h3 id="系统抽样"><a href="#系统抽样" class="headerlink" title="系统抽样"></a>系统抽样</h3><p>又称等距抽样。是纯随机抽样的变种。在系统抽样中，先将总体从1～N相继编号，并计算抽样距离K=N/n。式中N为总体单位总数，n为样本容量。然后在1～K中抽一随机数k1，作为样本的第一个单位，接着取k1+K,k1+2K……，直至抽够n个单位为止。<br>系统抽样要防止周期性偏差，因为它会降低样本的代表性。例如，军队人员名单通常按班排列，10人一班，班长排第 1名，若抽样距离也取10时，则样本或全由士兵组成或全由班长组成。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data2=rbind(matrix(rep(<span class="string">"nc"</span>,<span class="number">165</span>),<span class="number">165</span>,<span class="number">1</span>,byrow=<span class="literal">TRUE</span>),</span><br><span class="line">matrix(rep(<span class="string">"sc"</span>,<span class="number">70</span>),<span class="number">70</span>,<span class="number">1</span>,byrow=<span class="literal">TRUE</span>))</span><br><span class="line">data2=cbind.data.frame(data2,c(rep(<span class="number">1</span>,<span class="number">100</span>), rep(<span class="number">2</span>,<span class="number">50</span>), rep(<span class="number">3</span>,<span class="number">15</span>), rep(<span class="number">1</span>,<span class="number">30</span>),rep(<span class="number">2</span>,<span class="number">40</span>)),</span><br><span class="line"><span class="number">1000</span>*runif(<span class="number">235</span>))</span><br><span class="line">names(data2)=c(<span class="string">"state"</span>,<span class="string">"region"</span>,<span class="string">"income"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用“income”字段计算每个总体单元的入样概率</span></span><br><span class="line">pik=inclusionprobabilities(data2$income,<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 使用系统抽样抽取样本（样本量为10）</span></span><br><span class="line">s=UPsystematic(pik) </span><br><span class="line"><span class="comment"># 提取观察到的数据</span></span><br><span class="line">getdata(data2,s)</span><br></pre></td></tr></table></figure>
<table> <thead><tr><th></th><th scope="col">ID_unit</th><th scope="col">state</th><th scope="col">region</th><th scope="col">income</th></tr></thead> <tbody> <tr><th scope="row">14</th><td> 14     </td><td>nc      </td><td>1       </td><td>172.0453</td></tr> <tr><th scope="row">38</th><td> 38     </td><td>nc      </td><td>1       </td><td>341.7052</td></tr> <tr><th scope="row">59</th><td> 59     </td><td>nc      </td><td>1       </td><td>616.9244</td></tr> <tr><th scope="row">87</th><td> 87     </td><td>nc      </td><td>1       </td><td>331.2421</td></tr> <tr><th scope="row">107</th><td>107     </td><td>nc      </td><td>2       </td><td>150.9538</td></tr> <tr><th scope="row">127</th><td>127     </td><td>nc      </td><td>2       </td><td>993.4834</td></tr> <tr><th scope="row">152</th><td>152     </td><td>nc      </td><td>3       </td><td>992.7680</td></tr> <tr><th scope="row">179</th><td>179     </td><td>sc      </td><td>1       </td><td>854.8830</td></tr> <tr><th scope="row">201</th><td>201     </td><td>sc      </td><td>2       </td><td>638.2734</td></tr> <tr><th scope="row">222</th><td>222     </td><td>sc      </td><td>2       </td><td>919.4055</td></tr> </tbody> </table>



<h2 id="描述统计"><a href="#描述统计" class="headerlink" title="描述统计"></a>描述统计</h2><p>有时候我们只是想快速浏览数据的描述统计特征，如果一个一个输入函数计算是很麻烦的，R中给我们提供了很多函数，可以一次性展示多个统计量</p>
<h3 id="summary函数"><a href="#summary函数" class="headerlink" title="summary函数"></a>summary函数</h3><p><code>summary()</code>是系统自带的函数，包括最小最大值，中位数，中值，四分位数及类别数据的频数统计。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">vars &lt;- c(<span class="string">"mpg"</span>,<span class="string">"hp"</span>,<span class="string">"wt"</span>)</span><br><span class="line">summary(mtcars[vars])</span><br></pre></td></tr></table></figure>
<pre><code>     mpg              hp              wt       
Min.   :10.40   Min.   : 52.0   Min.   :1.513  
1st Qu.:15.43   1st Qu.: 96.5   1st Qu.:2.581  
Median :19.20   Median :123.0   Median :3.325  
Mean   :20.09   Mean   :146.7   Mean   :3.217  
3rd Qu.:22.80   3rd Qu.:180.0   3rd Qu.:3.610  
Max.   :33.90   Max.   :335.0   Max.   :5.424  
</code></pre><h3 id="Hmisc包中的describe函数"><a href="#Hmisc包中的describe函数" class="headerlink" title="Hmisc包中的describe函数"></a>Hmisc包中的describe函数</h3><p>该函数提供变量和观测的数量，缺失值数量，唯一值数量，平均值，各个分位值，五个最大最小值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span>(Hmisc)</span><br><span class="line">describe(mtcars[vars])</span><br></pre></td></tr></table></figure>
<pre><code>mtcars[vars] 

 3  Variables      32  Observations
--------------------------------------------------------------------------------
mpg 
       n  missing distinct     Info     Mean      Gmd      .05      .10 
      32        0       25    0.999    20.09    6.796    12.00    14.34 
     .25      .50      .75      .90      .95 
   15.43    19.20    22.80    30.09    31.30 

lowest : 10.4 13.3 14.3 14.7 15.0, highest: 26.0 27.3 30.4 32.4 33.9
--------------------------------------------------------------------------------
hp 
       n  missing distinct     Info     Mean      Gmd      .05      .10 
      32        0       22    0.997    146.7    77.04    63.65    66.00 
     .25      .50      .75      .90      .95 
   96.50   123.00   180.00   243.50   253.55 

lowest :  52  62  65  66  91, highest: 215 230 245 264 335
--------------------------------------------------------------------------------
wt 
       n  missing distinct     Info     Mean      Gmd      .05      .10 
      32        0       29    0.999    3.217    1.089    1.736    1.956 
     .25      .50      .75      .90      .95 
   2.581    3.325    3.610    4.048    5.293 

lowest : 1.513 1.615 1.835 1.935 2.140, highest: 3.845 4.070 5.250 5.345 5.424
--------------------------------------------------------------------------------
</code></pre><h3 id="pastecs包中的stat-desc函数"><a href="#pastecs包中的stat-desc函数" class="headerlink" title="pastecs包中的stat.desc函数"></a>pastecs包中的stat.desc函数</h3><p>该函数可以计算种类繁多的描述性统计量。<br>stat.desc(x,basic=TRUE,desc=TRUE,norm=FALSE,p=0.95)</p>
<ul>
<li>basic: 计算其中所有值，控制，缺失值的数量，及最小最大值，值域和总和。</li>
<li>desc: 计算中位数，平均值，平均值标准误，平均值置信度为95%的置信区间，方差，标准差及变异系数</li>
<li>norm: 返回正态分布统计量（偏度，峰度，统计显著程度）和shapiro-Wilk正态检验结果</li>
<li>p: 置信区间</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span>(pastecs)</span><br><span class="line">stat.desc(mtcars[vars],norm = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<table> <thead><tr><th></th><th scope="col">mpg</th><th scope="col">hp</th><th scope="col">wt</th></tr></thead> <tbody> <tr><th scope="row">nbr.val</th><td> 32.0000000  </td><td>  32.00000000</td><td> 32.00000000 </td></tr> <tr><th scope="row">nbr.null</th><td>  0.0000000  </td><td>   0.00000000</td><td>  0.00000000 </td></tr> <tr><th scope="row">nbr.na</th><td>  0.0000000  </td><td>   0.00000000</td><td>  0.00000000 </td></tr> <tr><th scope="row">min</th><td> 10.4000000  </td><td>  52.00000000</td><td>  1.51300000 </td></tr> <tr><th scope="row">max</th><td> 33.9000000  </td><td> 335.00000000</td><td>  5.42400000 </td></tr> <tr><th scope="row">range</th><td> 23.5000000  </td><td> 283.00000000</td><td>  3.91100000 </td></tr> <tr><th scope="row">sum</th><td>642.9000000  </td><td>4694.00000000</td><td>102.95200000 </td></tr> <tr><th scope="row">median</th><td> 19.2000000  </td><td> 123.00000000</td><td>  3.32500000 </td></tr> <tr><th scope="row">mean</th><td> 20.0906250  </td><td> 146.68750000</td><td>  3.21725000 </td></tr> <tr><th scope="row">SE.mean</th><td>  1.0654240  </td><td>  12.12031731</td><td>  0.17296847 </td></tr> <tr><th scope="row">CI.mean.0.95</th><td>  2.1729465  </td><td>  24.71955013</td><td>  0.35277153 </td></tr> <tr><th scope="row">var</th><td> 36.3241028  </td><td>4700.86693548</td><td>  0.95737897 </td></tr> <tr><th scope="row">std.dev</th><td>  6.0269481  </td><td>  68.56286849</td><td>  0.97845744 </td></tr> <tr><th scope="row">coef.var</th><td>  0.2999881  </td><td>   0.46740771</td><td>  0.30412851 </td></tr> <tr><th scope="row">skewness</th><td>  0.6106550  </td><td>   0.72602366</td><td>  0.42314646 </td></tr> <tr><th scope="row">skew.2SE</th><td>  0.7366922  </td><td>   0.87587259</td><td>  0.51048252 </td></tr> <tr><th scope="row">kurtosis</th><td> -0.3727660  </td><td>  -0.13555112</td><td> -0.02271075 </td></tr> <tr><th scope="row">kurt.2SE</th><td> -0.2302812  </td><td>  -0.08373853</td><td> -0.01402987 </td></tr> <tr><th scope="row">normtest.W</th><td>  0.9475647  </td><td>   0.93341934</td><td>  0.94325772 </td></tr> <tr><th scope="row">normtest.p</th><td>  0.1228814  </td><td>   0.04880824</td><td>  0.09265499 </td></tr> </tbody> </table>

<p>总之，R中的描述性统计函数是很多的，这只是其中几个。有兴趣的可以发掘下，找到自己习惯的用一个就可以了</p>
<p>欢迎大家关注我的公众号<strong>数据里261号</strong>，我的文章会同步发表至公众号，且是不是有资源分享哦</p>
]]></content>
      <categories>
        <category>R</category>
        <category>统计学习</category>
      </categories>
      <tags>
        <tag>统计学习</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>python数据可视化seaborn（四）—— 分类数据可视化</title>
    <url>/blogs/36032875/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><p>之前的文章关注的是两个变量都是<code>数值变量</code>的情况,当有一个变量是分类变量的时候，我们就需要其他类型的图形来展示分析数据。在seaborn中有多种类型的图形且非常易于上手。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">sns.set(style=<span class="string">"whitegrid"</span>,font_scale=<span class="number">1.4</span>,context=<span class="string">"paper"</span>)</span><br><span class="line"><span class="comment"># 设置风格、尺度</span></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>) </span><br><span class="line"><span class="comment"># 不发出警告</span></span><br></pre></td></tr></table></figure>
<p>seaborn中，分类图主要分为三个部分：</p>
<ul>
<li>分类散点图：<ul>
<li>stripplot(默认，kind = “strip”)</li>
<li>swarmplot(kind = “swarm”)</li>
</ul>
</li>
<li>分类分布图：<ul>
<li>boxplot(kind=”box”)</li>
<li>violinplot(kind=”violin”)</li>
<li>boxenplot(kind=”boxen”)</li>
</ul>
</li>
<li>分类估计图：<ul>
<li>pointplot(kind=”point”)</li>
<li>barplot(kind=”bar”)</li>
<li>countplot(kind=”count”)</li>
</ul>
</li>
</ul>
<p>以上三种系列分别代表了不同粒度级别的数据。当然，在实际使用的过程中，其实没有必要记住这么多，因为seaborn中的分类系列有统一的图形界面<code>catplot()</code>,只需要这一个函数，就能访问所有分类图像类型。</p>
<h2 id="分类散点图"><a href="#分类散点图" class="headerlink" title="分类散点图"></a>分类散点图</h2><p>seaborn.stripplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, jitter=True, dodge=False, orient=None, color=None, palette=None, size=5, edgecolor=’gray’, linewidth=0, ax=None, **kwargs)  </p>
<ul>
<li>jitter : 是否抖动，True，false or float</li>
<li>dodge : 当有hue参数时，是否沿轴分离不同颜色</li>
<li>orient : 图形方向，垂直（“v”）或者水平(“h”)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、catplot()  默认情况下，kind='strip'</span></span><br><span class="line"><span class="comment"># 按照不同类别对样本数据进行分布散点图绘制</span></span><br><span class="line"></span><br><span class="line">tips = sns.load_dataset(<span class="string">"tips"</span>)</span><br><span class="line">print(tips.head())</span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line"></span><br><span class="line">sns.catplot(x=<span class="string">"day"</span>,          <span class="comment"># x → 设置分组统计字段</span></span><br><span class="line">            y=<span class="string">"total_bill"</span>,   <span class="comment"># y → 数据分布统计字段</span></span><br><span class="line">            <span class="comment"># 这里xy数据对调，将会使得散点图横向分布</span></span><br><span class="line">            data=tips,        <span class="comment"># data → 对应数据</span></span><br><span class="line">            jitter = <span class="keyword">True</span>, height=<span class="number">6</span>,   </span><br><span class="line">            <span class="comment">#当点数据重合较多时，jitter可以控制点抖动，也可以设置间距如：jitter = 0.1</span></span><br><span class="line">            s = <span class="number">6</span>, edgecolor = <span class="string">'w'</span>,linewidth=<span class="number">1</span>,marker = <span class="string">'o'</span> , </span><br><span class="line">            <span class="comment"># 设置点的大小、描边颜色或宽度、点样式</span></span><br><span class="line">            )</span><br></pre></td></tr></table></figure>
<pre><code>   total_bill   tip     sex smoker  day    time  size
0       16.99  1.01  Female     No  Sun  Dinner     2
1       10.34  1.66    Male     No  Sun  Dinner     3
2       21.01  3.50    Male     No  Sun  Dinner     3
3       23.68  3.31    Male     No  Sun  Dinner     2
4       24.59  3.61  Female     No  Sun  Dinner     4
</code></pre><p><img src="output_5_2.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、stripplot()</span></span><br><span class="line"><span class="comment"># 通过kind='swarm' 来调整点防止重合</span></span><br><span class="line"></span><br><span class="line">sns.catplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>,kind=<span class="string">'swarm'</span>,</span><br><span class="line">              hue=<span class="string">'sex'</span>,data=tips,height=<span class="number">5</span>,s=<span class="number">5.5</span>)</span><br><span class="line"><span class="comment"># 通过让点沿轴分布来防止重合，这只使用与较小数据集</span></span><br></pre></td></tr></table></figure>
<p><img src="output_6_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、stripplot()</span></span><br><span class="line"><span class="comment"># 设置调色盘</span></span><br><span class="line"></span><br><span class="line">sns.catplot(x=<span class="string">"sex"</span>, y=<span class="string">"total_bill"</span>, hue=<span class="string">"day"</span>,</span><br><span class="line">              data=tips, jitter=<span class="keyword">True</span>,</span><br><span class="line">              palette=<span class="string">"Set2"</span>,  <span class="comment"># 设置调色盘</span></span><br><span class="line">              dodge=<span class="keyword">True</span>,  <span class="comment"># 是否拆分</span></span><br><span class="line">             )</span><br></pre></td></tr></table></figure>
<p><img src="output_7_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 排序</span></span><br><span class="line">print(tips[<span class="string">'day'</span>].value_counts())</span><br><span class="line"><span class="comment"># 查看day字段的唯一值</span></span><br><span class="line"></span><br><span class="line">sns.catplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, data=tips,</span><br><span class="line">              order = [<span class="string">'Sun'</span>,<span class="string">'Sat'</span>])</span><br><span class="line"><span class="comment"># order → 筛选类别,控制排序</span></span><br></pre></td></tr></table></figure>
<pre><code>Sat     87
Sun     76
Thur    62
Fri     19
Name: day, dtype: int64
</code></pre><p><img src="output_8_2.png" alt="png"></p>
<h2 id="分类分布图"><a href="#分类分布图" class="headerlink" title="分类分布图"></a>分类分布图</h2><h3 id="箱线图-boxplot"><a href="#箱线图-boxplot" class="headerlink" title="箱线图 boxplot()"></a>箱线图 boxplot()</h3><p>seaborn.boxplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, orient=None, color=None, palette=None, saturation=0.75, width=0.8, dodge=True, fliersize=5, linewidth=None, whis=1.5, notch=False, ax=None, **kwargs)</p>
<ul>
<li>saturation : float,颜色饱和度</li>
<li>fliersize : 异常值标记的大小</li>
<li>whis : float,超出IQR多少比例被视为异常值，默认1.5</li>
<li>notch : 是否用中位数设置凹槽</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 箱线图 catplot(kind='box')</span></span><br><span class="line">sns.catplot(x=<span class="string">'day'</span>, y=<span class="string">'total_bill'</span>, data=tips,</span><br><span class="line">            kind=<span class="string">'box'</span>,linewidth=<span class="number">2</span>,  <span class="comment"># 线宽</span></span><br><span class="line">            width=<span class="number">0.6</span>,  <span class="comment"># 箱之间的间隔比例</span></span><br><span class="line">            fliersize=<span class="number">5</span>,   <span class="comment"># 异常点大小</span></span><br><span class="line">            palette=<span class="string">'hls'</span>,  <span class="comment"># 调色板</span></span><br><span class="line">            whis=<span class="number">1.5</span>,  <span class="comment"># 设置IQR</span></span><br><span class="line">            notch=<span class="keyword">True</span>,  <span class="comment"># 设置是否用中位数做凹槽</span></span><br><span class="line">            order=[<span class="string">'Thur'</span>, <span class="string">'Fri'</span>, <span class="string">'Sat'</span>, <span class="string">'Sun'</span>], <span class="comment">#筛选类别</span></span><br><span class="line">           )</span><br></pre></td></tr></table></figure>
<p><img src="output_11_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过hue参数再分类</span></span><br><span class="line"><span class="comment"># 多种类型图混合</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制箱型图</span></span><br><span class="line">sns.catplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, data=tips,</span><br><span class="line">            kind=<span class="string">'box'</span>,hue = <span class="string">'smoker'</span>,height=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制散点图</span></span><br><span class="line">sns.swarmplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, data=tips,</span><br><span class="line">              color =<span class="string">'k'</span>,s= <span class="number">3</span>,alpha = <span class="number">0.8</span>)</span><br><span class="line"><span class="comment"># 添加分类散点图，这里添加散点图要用各自的函数swarmplot()</span></span><br><span class="line"><span class="comment"># 不能再用高级端口catplot() 否则就是两个图了</span></span><br></pre></td></tr></table></figure>
<p><img src="output_12_1.png" alt="png"></p>
<p>对于数据量较大的数据集，散点图会显的很拥挤，这时我们可以使用<code>boxenplot()</code>,这种图表类似箱线图，既能够展示数据的分布也可以如箱线图展示数据的统计信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">diamonds = sns.load_dataset(<span class="string">"diamonds"</span>)</span><br><span class="line">print(diamonds.head(<span class="number">3</span>))</span><br><span class="line">sns.catplot(x=<span class="string">'color'</span>,y=<span class="string">'price'</span>,kind=<span class="string">'boxen'</span>,</span><br><span class="line">           data=diamonds.sort_values(<span class="string">"color"</span>),</span><br><span class="line">           height=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<pre><code>   carat      cut color clarity  depth  table  price     x     y     z
0   0.23    Ideal     E     SI2   61.5   55.0    326  3.95  3.98  2.43
1   0.21  Premium     E     SI1   59.8   61.0    326  3.89  3.84  2.31
2   0.23     Good     E     VS1   56.9   65.0    327  4.05  4.07  2.31
</code></pre><p><img src="output_14_2.png" alt="png"></p>
<h3 id="提琴图"><a href="#提琴图" class="headerlink" title="提琴图"></a>提琴图</h3><p>小提琴图将核密度估计和箱线图结合起来</p>
<p>seaborn.violinplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, bw=’scott’, cut=2, scale=’area’, scale_hue=True, gridsize=100, width=0.8, inner=’box’, split=False, dodge=True, orient=None, linewidth=None, color=None, palette=None, saturation=0.75, ax=None, **kwargs)</p>
<ul>
<li>bw : (“scott”,”silverman”,float),核大小的比例因子，实际效果是越大越平滑。</li>
<li>cut : float,用于将密度扩展到极端数据点之外的距离，设置为0以将小提琴范围限制在观测数据的范围内。</li>
<li>scale : 小提琴图的宽度：area-面积相同，count-按照样本数量决定宽度，width-宽度一样</li>
<li>scale_hue : bool,当有hue时，决定实在分组内还是图上所有小提琴计算缩放比例</li>
<li>gridsize : 和必读估计离散网格中的点数，越高越平滑</li>
<li>inner : （“box”, “quartile”, “point”, “stick”, None），内部显示样式</li>
<li>split : 当有颜色嵌套是，是否分别绘制每侧的小提琴。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2、violinplot()</span></span><br><span class="line"><span class="comment"># 小提琴图</span></span><br><span class="line"></span><br><span class="line">sns.catplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, data=tips,</span><br><span class="line">            kind=<span class="string">'violin'</span>,linewidth = <span class="number">2</span>,   <span class="comment"># 线宽</span></span><br><span class="line">            width = <span class="number">0.8</span>,     <span class="comment"># 箱之间的间隔比例</span></span><br><span class="line">            height=<span class="number">6</span>,palette = <span class="string">'hls'</span>, <span class="comment"># 设置调色板</span></span><br><span class="line">            order = [<span class="string">'Thur'</span>,<span class="string">'Fri'</span>,<span class="string">'Sat'</span>,<span class="string">'Sun'</span>],  <span class="comment"># 筛选类别</span></span><br><span class="line">            scale = <span class="string">'area'</span>,  </span><br><span class="line">            <span class="comment"># 测度小提琴图的宽度：</span></span><br><span class="line">            <span class="comment"># area-面积相同，count-按照样本数量决定宽度，width-宽度一样</span></span><br><span class="line">            gridsize = <span class="number">30</span>,   <span class="comment"># 设置小提琴图边线的平滑度，越高越平滑</span></span><br><span class="line">            inner = <span class="string">'box'</span>,   </span><br><span class="line">            bw = <span class="number">.5</span>    <span class="comment"># 控制拟合程度，一般可以不设置</span></span><br><span class="line">           )</span><br></pre></td></tr></table></figure>
<p><img src="output_16_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2、violinplot()</span></span><br><span class="line"><span class="comment"># 通过hue参数再分类</span></span><br><span class="line"></span><br><span class="line">sns.catplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, data=tips,</span><br><span class="line">            kind=<span class="string">'violin'</span>,hue = <span class="string">'smoker'</span>,</span><br><span class="line">            palette=<span class="string">"muted"</span>, split=<span class="keyword">True</span>,  <span class="comment"># 设置是否拆分小提琴图</span></span><br><span class="line">            inner=<span class="string">"quartile"</span>,height=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p><img src="output_17_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2、violinplot()</span></span><br><span class="line"><span class="comment"># 结合散点图</span></span><br><span class="line"></span><br><span class="line">sns.catplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, data=tips,</span><br><span class="line">            kind=<span class="string">'violin'</span>,palette = <span class="string">'hls'</span>,</span><br><span class="line">            inner = <span class="keyword">None</span>,height=<span class="number">6</span>,</span><br><span class="line">            cut=<span class="number">0</span>  <span class="comment"># 设置为0，将图限制在观测数据范围内。</span></span><br><span class="line">           )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入散点图</span></span><br><span class="line">sns.swarmplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, data=tips,</span><br><span class="line">              color=<span class="string">"k"</span>, alpha=<span class="number">.5</span>)</span><br></pre></td></tr></table></figure>
<p><img src="output_18_1.png" alt="png"></p>
<h2 id="统计图"><a href="#统计图" class="headerlink" title="统计图"></a>统计图</h2><p>seaborn.barplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, estimator=&lt;\function mean&gt;, ci=95, n_boot=1000, units=None, orient=None, color=None, palette=None, saturation=0.75, errcolor=’.26’, errwidth=None, capsize=None, dodge=True, ax=None, **kwargs)</p>
<ul>
<li>estimator : 分类箱内使用的统计函数</li>
<li>ci : （float,”sd”,None）</li>
<li>units : 变量名称，对变量的每个采样单独绘制，可用于绘制重复数据</li>
<li>errwidth : 误差线宽度</li>
<li>capsize : 误差条帽的宽度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、barplot()</span></span><br><span class="line"><span class="comment"># 置信区间：样本均值 + 抽样误差</span></span><br><span class="line">titanic = sns.load_dataset(<span class="string">"titanic"</span>)</span><br><span class="line"><span class="comment"># print(titanic.head())</span></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line"></span><br><span class="line">sns.catplot(x=<span class="string">"sex"</span>, y=<span class="string">"survived"</span>, data=titanic,</span><br><span class="line">            kind=<span class="string">'bar'</span>,palette = <span class="string">'hls'</span>, hue=<span class="string">"class"</span>,</span><br><span class="line">            order = [<span class="string">'male'</span>,<span class="string">'female'</span>],  <span class="comment"># 筛选类别</span></span><br><span class="line">            capsize = <span class="number">0.05</span>,  <span class="comment"># 误差线横向延伸宽度</span></span><br><span class="line">            saturation=<span class="number">.8</span>,   <span class="comment"># 颜色饱和度</span></span><br><span class="line">            errcolor = <span class="string">'gray'</span>,errwidth = <span class="number">2</span>,  <span class="comment"># 误差线颜色，宽度</span></span><br><span class="line">            height=<span class="number">6</span>,ci = <span class="string">'sd'</span></span><br><span class="line">            <span class="comment"># 置信区间误差 → 0-100内值、'sd'、None</span></span><br><span class="line">            )</span><br><span class="line">print(titanic.groupby([<span class="string">'sex'</span>,<span class="string">'class'</span>]).mean()[<span class="string">'survived'</span>])</span><br><span class="line">print(titanic.groupby([<span class="string">'sex'</span>,<span class="string">'class'</span>]).std()[<span class="string">'survived'</span>])</span><br><span class="line"><span class="comment"># 计算数据</span></span><br></pre></td></tr></table></figure>
<pre><code>sex     class 
female  First     0.968085
        Second    0.921053
        Third     0.500000
male    First     0.368852
        Second    0.157407
        Third     0.135447
Name: survived, dtype: float64
sex     class 
female  First     0.176716
        Second    0.271448
        Third     0.501745
male    First     0.484484
        Second    0.365882
        Third     0.342694
Name: survived, dtype: float64
</code></pre><p><img src="output_20_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、barplot()</span></span><br><span class="line"><span class="comment"># 柱状图 - 置信区间估计</span></span><br><span class="line"><span class="comment"># 可以这样子改变风格</span></span><br><span class="line"></span><br><span class="line">sns.catplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, data=tips,</span><br><span class="line">            linewidth=<span class="number">2.5</span>,facecolor=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">            kind=<span class="string">'bar'</span>,edgecolor = <span class="string">'k'</span>,)</span><br></pre></td></tr></table></figure>
<p><img src="output_21_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、barplot()</span></span><br><span class="line"></span><br><span class="line">crashes = sns.load_dataset(<span class="string">"car_crashes"</span>).sort_values(<span class="string">"total"</span>, ascending=<span class="keyword">False</span>)</span><br><span class="line">print(crashes.head())</span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line"></span><br><span class="line">f, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">15</span>))</span><br><span class="line"><span class="comment"># 创建图表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sns.set_color_codes("pastel")</span></span><br><span class="line">sns.barplot(x=<span class="string">"total"</span>, y=<span class="string">"abbrev"</span>, data=crashes,</span><br><span class="line">            label=<span class="string">"Total"</span>, color=<span class="string">"b"</span>,edgecolor = <span class="string">'w'</span>)</span><br><span class="line"><span class="comment"># 设置第一个柱状图</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sns.set_color_codes("muted")</span></span><br><span class="line">sns.barplot(x=<span class="string">"alcohol"</span>, y=<span class="string">"abbrev"</span>, data=crashes,</span><br><span class="line">            label=<span class="string">"Alcohol-involved"</span>, color=<span class="string">"y"</span>,edgecolor = <span class="string">'w'</span>)</span><br><span class="line"><span class="comment"># 设置第二个柱状图</span></span><br><span class="line"></span><br><span class="line">ax.legend(ncol=<span class="number">2</span>, loc=<span class="string">"lower right"</span>)</span><br><span class="line">sns.despine(left=<span class="keyword">True</span>, bottom=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<pre><code>    total  speeding  alcohol  not_distracted  no_previous  ins_premium  \
40   23.9     9.082    9.799          22.944       19.359       858.97   
34   23.9     5.497   10.038          23.661       20.554       688.75   
48   23.8     8.092    6.664          23.086       20.706       992.61   
3    22.4     4.032    5.824          21.056       21.280       827.34   
17   21.4     4.066    4.922          16.692       16.264       872.51   

    ins_losses abbrev  
40      116.29     SC  
34      109.72     ND  
48      152.56     WV  
3       142.39     AR  
17      137.13     KY  
</code></pre><p><img src="output_22_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2、countplot()</span></span><br><span class="line"><span class="comment"># 计数柱状图</span></span><br><span class="line"></span><br><span class="line">sns.catplot(x=<span class="string">"class"</span>, hue=<span class="string">"who"</span>, data=titanic,</span><br><span class="line">              kind=<span class="string">'count'</span>,palette = <span class="string">'magma'</span>)</span><br><span class="line"></span><br><span class="line">sns.catplot(y=<span class="string">"class"</span>, hue=<span class="string">"who"</span>, data=titanic,</span><br><span class="line">            kind=<span class="string">'count'</span>,palette = <span class="string">'magma'</span>)  </span><br><span class="line"><span class="comment"># x/y → 以x或者y轴绘图（横向，竖向）</span></span><br><span class="line"><span class="comment"># 用法和barplot相似</span></span><br></pre></td></tr></table></figure>
<p><img src="output_23_1.png" alt="png"></p>
<p><img src="output_23_2.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3、pointplot()</span></span><br><span class="line"></span><br><span class="line">sns.catplot(x=<span class="string">"time"</span>, y=<span class="string">"total_bill"</span>, hue = <span class="string">'smoker'</span>,data=tips,</span><br><span class="line">              kind=<span class="string">'point'</span>,palette = <span class="string">'hls'</span>,height=<span class="number">7</span>,</span><br><span class="line">              dodge = <span class="keyword">True</span>,   <span class="comment"># 设置点是否分开</span></span><br><span class="line">              join = <span class="keyword">True</span>,    <span class="comment"># 是否连线</span></span><br><span class="line">              markers=[<span class="string">"o"</span>, <span class="string">"x"</span>], linestyles=[<span class="string">"-"</span>, <span class="string">"--"</span>],  <span class="comment"># 设置点样式、线型</span></span><br><span class="line">              )</span><br><span class="line"><span class="comment"># 计算数据</span></span><br><span class="line"><span class="comment"># # 用法和barplot相似</span></span><br></pre></td></tr></table></figure>
<p><img src="output_24_1.png" alt="png"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>可视化</tag>
        <tag>seaborn</tag>
      </tags>
  </entry>
  <entry>
    <title>python数据可视化seaborn（三）——探索变量之间的关系</title>
    <url>/blogs/8d288665/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><p>我们常常想知道变量之间是否存在关联，以及这些关联是否收到其他变量影响。可视化能够帮助我们非常直观的展示这些。<br><a id="more"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>) </span><br><span class="line"><span class="comment"># 不发出警告</span></span><br><span class="line">sns.set_context(<span class="string">'notebook'</span>,font_scale=<span class="number">1.2</span>)</span><br><span class="line">tips = sns.load_dataset(<span class="string">"tips"</span>)</span><br><span class="line">tips.head()</span><br></pre></td></tr></table></figure>
<div> <style scoped> .dataframe tbody tr th:only-of-type { vertical-align: middle; }  .dataframe tbody tr th { vertical-align: top; }  .dataframe thead th { text-align: right; } </style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>total_bill</th> <th>tip</th> <th>sex</th> <th>smoker</th> <th>day</th> <th>time</th> <th>size</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>16.99</td> <td>1.01</td> <td>Female</td> <td>No</td> <td>Sun</td> <td>Dinner</td> <td>2</td> </tr> <tr> <th>1</th> <td>10.34</td> <td>1.66</td> <td>Male</td> <td>No</td> <td>Sun</td> <td>Dinner</td> <td>3</td> </tr> <tr> <th>2</th> <td>21.01</td> <td>3.50</td> <td>Male</td> <td>No</td> <td>Sun</td> <td>Dinner</td> <td>3</td> </tr> <tr> <th>3</th> <td>23.68</td> <td>3.31</td> <td>Male</td> <td>No</td> <td>Sun</td> <td>Dinner</td> <td>2</td> </tr> <tr> <th>4</th> <td>24.59</td> <td>3.61</td> <td>Female</td> <td>No</td> <td>Sun</td> <td>Dinner</td> <td>4</td> </tr> </tbody> </table> </div>

<h1 id="relplot"><a href="#relplot" class="headerlink" title="relplot"></a>relplot</h1><p>这是一个seaborn新的图形级函数，通过<code>kind</code>参数，能对<code>scatterplot()</code>和<code>lineplot()</code>两个轴级函数进行访问。</p>
<p><em>seaborn.relplot(x=None, y=None, hue=None, size=None, style=None, data=None, row=None, col=None, col_wrap=None, row_order=None, col_order=None, palette=None, hue_order=None, hue_norm=None, sizes=None, size_order=None, size_norm=None, markers=None, dashes=None, style_order=None, legend=’brief’, kind=’scatter’, height=5, aspect=1, facet_kws=None, **kwargs)</em></p>
<ul>
<li>[hue,size,style]: 可以生成不同的颜色，大小，样式来独立的显示第三个变量</li>
<li>[row,col]: 按照某个变量分列或者分行</li>
<li>col_wrap: int, 分成几列（不能与参数row共同出现）</li>
<li>sizes: 对size参数的每个分类设定大小<ul>
<li>大小值列表</li>
<li>变量到大小的字典映射</li>
<li>包含最大最小的元组,会在此范围对值归一化</li>
</ul>
</li>
<li>[col,row,size,hue,style]_order: 指定变量出现的顺序。</li>
<li>hue_norm: 当hue的变量值数字时，用于将colormap标准化，如果是分类变量则无关。</li>
<li>size_norm: 数据单元的标准化，当size变量为数字时缩放图像</li>
<li>legend: 如何绘制图例<ul>
<li>False：不绘制图例</li>
<li>‘brief’(默认)：数值型的hue和size参数会用均匀间隔的样本表示</li>
<li>‘full’：对比‘brief’,每个组都会在图例中输出一个条目</li>
</ul>
</li>
<li>facet_kws: 要传递给FacetGrid其他参数的字典</li>
</ul>
<h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.relplot(x=<span class="string">"total_bill"</span>, y=<span class="string">"tip"</span>, data=tips,</span><br><span class="line">            kind=<span class="string">'scatter'</span>, <span class="comment"># ['scatter','line']</span></span><br><span class="line">            hue=<span class="string">'day'</span>,  <span class="comment"># 设置按颜色分类的第三变量</span></span><br><span class="line"><span class="comment">#             style='day', # 设置形状分类</span></span><br><span class="line">            palette=<span class="string">'husl'</span>,s=<span class="number">60</span>, <span class="comment"># 设置调色盘类型和散点大小</span></span><br><span class="line">            aspect=<span class="number">1.5</span>,height=<span class="number">6</span>  <span class="comment"># 设置图像大小和横纵比</span></span><br><span class="line">           )</span><br></pre></td></tr></table></figure>
<p><img src="output_5_1.png" alt="png"></p>
<p>可以看到，小费与消费总体呈线性正相关，那精确到不同日期，有什么不同么？上图颜色虽有区分但是不够明显，<br>seaborn可以将分类变量分别绘制到不同的子图中，如下图所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.relplot(x=<span class="string">"total_bill"</span>, y=<span class="string">"tip"</span>, data=tips,</span><br><span class="line">            hue=<span class="string">"time"</span>, <span class="comment"># 用颜色对time变量分类</span></span><br><span class="line">            col=<span class="string">"day"</span>, <span class="comment"># 按照day变量分列</span></span><br><span class="line">            col_wrap=<span class="number">2</span>, <span class="comment"># 每行2个分类</span></span><br><span class="line">            s=<span class="number">100</span>, <span class="comment"># 散点大小（来自plt.scatter的参数）</span></span><br><span class="line">            height=<span class="number">3</span>,aspect=<span class="number">1.5</span>)<span class="comment"># 图像大小及每个轴的横纵比</span></span><br></pre></td></tr></table></figure>
<p><img src="output_7_1.png" alt="png"></p>
<p>当然，也可以用大小来展示变量的大小强弱等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.relplot(x=<span class="string">"total_bill"</span>, y=<span class="string">"tip"</span>, data=tips,</span><br><span class="line">            hue=<span class="string">"time"</span>, size=<span class="string">"size"</span>,</span><br><span class="line">            palette=[<span class="string">"b"</span>, <span class="string">"r"</span>],</span><br><span class="line">            sizes=(<span class="number">30</span>, <span class="number">120</span>),<span class="comment"># size大小按照最小20最大120分布</span></span><br><span class="line">            col=<span class="string">"time"</span>)<span class="comment"># 按照time分列</span></span><br></pre></td></tr></table></figure>
<p><img src="output_9_1.png" alt="png"></p>
<p>当然也可以将点设置成不同的形状来区分类别，但是不建议单独将一个变量与形状表示，因为形状的区分不是很明显，建议和颜色一同使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.relplot(x=<span class="string">'total_bill'</span>,y=<span class="string">'tip'</span>,data=tips,</span><br><span class="line">            hue=<span class="string">'smoker'</span>,style=<span class="string">'smoker'</span>,s=<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<p><img src="output_11_1.png" alt="png"></p>
<p>颜色既可以展示离散变量，也可以展示连续变量，还可以对调色盘自定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.relplot(x=<span class="string">'total_bill'</span>,y=<span class="string">'tip'</span>,data=tips,</span><br><span class="line">            hue=<span class="string">'size'</span>,palette=<span class="string">'ch:r=-.5,l=.75'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="output_13_1.png" alt="png"></p>
<h2 id="线图"><a href="#线图" class="headerlink" title="线图"></a>线图</h2><p>用relpot绘制线图其实是对<code>lineplot()</code>函数的访问，所以lineplot的所有参数都可以用在这里面。同样的，<code>scatterplot()</code>函数的参数设置与此几乎相同。<br><em>seaborn.lineplot(x=None, y=None, hue=None, size=None, style=None, data=None, palette=None, hue_order=None, hue_norm=None, sizes=None, size_order=None, size_norm=None, dashes=True, markers=None, style_order=None, units=None, estimator=’mean’, ci=95, n_boot=1000, sort=True, err_style=’band’, err_kws=None, legend=’brief’, ax=None, **kwargs)</em></p>
<ul>
<li>units: 对变量的每个采样单独绘制，但不会绘制图例。可用于绘制重复数据。</li>
<li>estimator：pandas方法的名称或None,对同一x变量的多个观察值进行聚合的方法。</li>
<li>ci: [int,’sd’,None],置信区间的大小，当为‘sd’时绘制数据的标准差。</li>
<li>n_boot: int, 计算置信区间的bootstrap数</li>
<li>sort: bool, 数据将按照x和y变量排序，否则将按照他们在数据集中的顺序排列点</li>
<li>err_style: “band”和”bars”,置信区间风格</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fmri = sns.load_dataset(<span class="string">"fmri"</span>)</span><br><span class="line">print(fmri.head())</span><br><span class="line">g = sns.relplot(x=<span class="string">"timepoint"</span>, y=<span class="string">"signal"</span>, data=fmri,</span><br><span class="line">                hue=<span class="string">"event"</span>, style=<span class="string">"event"</span>, </span><br><span class="line">                col=<span class="string">"region"</span>, </span><br><span class="line">                markers=<span class="keyword">True</span>,dashes=<span class="keyword">False</span>,<span class="comment"># 添加标记，禁止虚线</span></span><br><span class="line">                kind=<span class="string">"line"</span>)</span><br></pre></td></tr></table></figure>
<pre><code>  subject  timepoint event    region    signal
0     s13         18  stim  parietal -0.017552
1      s5         14  stim  parietal -0.080883
2     s12         18  stim  parietal -0.081033
3     s11         18  stim  parietal -0.046134
4     s10         18  stim  parietal -0.037970
</code></pre><p><img src="output_16_1.png" alt="png"></p>
<ol>
<li><code>lineplot()</code>在默认情况下会将x按照数值进行排序，也可以禁止。</li>
<li>对于某些复杂的数据集，例如上面的fmri数据集。同一个x会有多个测量值。seaborn的默认行为是通过绘制平均值和平均值周围的95%置信区间来聚合每个x的多个测量值。对于大型数据绘制置信区间可能会用较长时间，所以可以通过<code>ci=None</code>来禁止。当然也可以将置信区间替换成标准差<code>ci=&quot;sd&quot;</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.relplot(x=<span class="string">"timepoint"</span>, y=<span class="string">"signal"</span>,</span><br><span class="line">                data=fmri,sort=<span class="keyword">False</span>, <span class="comment"># 禁止对x排序</span></span><br><span class="line">                kind=<span class="string">"line"</span>,ci=<span class="keyword">False</span>) <span class="comment"># 禁止有置信区间</span></span><br></pre></td></tr></table></figure>
<p><img src="output_18_1.png" alt="png"></p>
<p>要完全关闭聚合，可以这么设置<code>estimator=None</code>，不过当数据在每个点有多个观察值时，可能会产生奇怪的效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.relplot(x=<span class="string">"timepoint"</span>, y=<span class="string">"signal"</span>, estimator=<span class="keyword">None</span>, kind=<span class="string">"line"</span>, data=fmri)</span><br></pre></td></tr></table></figure>
<p><img src="output_20_1.png" alt="png"></p>
<p>有时候我们需要对同一个问题做重复测量并比较。那么seaborn也可以单独绘制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.relplot(x=<span class="string">"timepoint"</span>, y=<span class="string">"signal"</span>, hue=<span class="string">"region"</span>,</span><br><span class="line">            units=<span class="string">"subject"</span>, estimator=<span class="keyword">None</span>,</span><br><span class="line">            kind=<span class="string">"line"</span>, data=fmri.query(<span class="string">"event == 'stim'"</span>))</span><br></pre></td></tr></table></figure>
<p><img src="output_22_1.png" alt="png"></p>
<p>线图通常用于可视化与实际日期和时间相关的数据。这些函数将原始格式的数据传递给底层matplotlib函数，因此它们可以利用matplotlib在刻度标签中格式化日期的能力。但是所有的格式化都必须在matplotlib层进行，您可以参考matplotlib文档来了解它是如何工作的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line">df = pd.DataFrame(dict(time=pd.date_range(<span class="string">"2017-1-1"</span>, periods=<span class="number">500</span>),</span><br><span class="line">                       value=np.random.randn(<span class="number">500</span>).cumsum()))</span><br><span class="line">g = sns.relplot(x=<span class="string">"time"</span>, y=<span class="string">"value"</span>, kind=<span class="string">"line"</span>, data=df)</span><br><span class="line">g.fig.autofmt_xdate()   <span class="comment"># 当X轴是时间格式时，用此方法旋转避免重叠。</span></span><br></pre></td></tr></table></figure>
<p><img src="output_24_1.png" alt="png"></p>
<p>如果要检查变量多个分类的效果，最好将它放在列上分类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.relplot(x=<span class="string">"timepoint"</span>, y=<span class="string">"signal"</span>, hue=<span class="string">"event"</span>, style=<span class="string">"event"</span>,</span><br><span class="line">            col=<span class="string">"subject"</span>, col_wrap=<span class="number">5</span>,</span><br><span class="line">            height=<span class="number">3</span>, aspect=<span class="number">.75</span>, linewidth=<span class="number">2.5</span>,</span><br><span class="line">            kind=<span class="string">"line"</span>, data=fmri.query(<span class="string">"region == 'frontal'"</span>))</span><br></pre></td></tr></table></figure>
<p><img src="output_26_1.png" alt="png"></p>
<p>下篇文章，我们讨论seaborn中的线性关系可视化</p>
]]></content>
      <categories>
        <category>python</category>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>可视化</tag>
        <tag>seaborn</tag>
      </tags>
  </entry>
  <entry>
    <title>一个Python计算时间的脚本</title>
    <url>/blogs/c9a9ff25/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><p>因为之前的自动化的工作中几乎每个脚本都要在时间节点运行，比如每周的第一天，每月第一天和最后一天等等。这就要涉及到时间的计算，但是没有现成的包，只能自己写一个(╯‵□′)╯︵┻━┻。</p>
<p>====================================分割线=======================================</p>
<p>最近，因为要处理很多报表，所以再次想起了这个脚本，然后发现有些不足的地方，所以又对其进行了修改，在保证原有功能都还能使用的基础上，拓展其可用范围,增加了getweek()函数，来获取前后任意一周的周一和周末的日期，同时也修改了一些其他问题。<br><a id="more"></a></p>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>这个脚本里包含了一般自动化报表会用到的时间节点。</p>
<table>
<thead>
<tr>
<th style="text-align:left">时间节点</th>
<th style="text-align:left">函数方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">今天（struct_time格式）</td>
<td style="text-align:left">today(today_s)</td>
</tr>
<tr>
<td style="text-align:left">昨天</td>
<td style="text-align:left">yesterday</td>
</tr>
<tr>
<td style="text-align:left">n月前/后是几月</td>
<td style="text-align:left">month()</td>
</tr>
<tr>
<td style="text-align:left">n月前/后月的第一天</td>
<td style="text-align:left">month_start()</td>
</tr>
<tr>
<td style="text-align:left">n月前/后月的最后一天</td>
<td style="text-align:left">month_end()</td>
</tr>
<tr>
<td style="text-align:left">上周第一天</td>
<td style="text-align:left">last_week_start()</td>
</tr>
<tr>
<td style="text-align:left">上周最后一天</td>
<td style="text-align:left">last_week_end()</td>
</tr>
<tr>
<td style="text-align:left">N周前/后当周的周一和周日</td>
<td style="text-align:left">getweek()</td>
</tr>
<tr>
<td style="text-align:left">本周是今年第几周</td>
<td style="text-align:left">weeknum</td>
</tr>
<tr>
<td style="text-align:left">今天是本周第几天</td>
<td style="text-align:left">wday</td>
</tr>
<tr>
<td style="text-align:left">今天是本月第几天</td>
<td style="text-align:left">mday</td>
</tr>
<tr>
<td style="text-align:left">今天是本年第几天</td>
<td style="text-align:left">yday</td>
</tr>
<tr>
<td style="text-align:left">本月天数</td>
<td style="text-align:left">mranges</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">day = Sometime(timestr=<span class="string">"2019-04-25"</span>) <span class="comment"># 指定基准日期</span></span><br><span class="line">print(day.today)</span><br><span class="line">print(day.yesterday)</span><br><span class="line">print(day.month(n_mon=<span class="number">2</span>))   <span class="comment"># 2个月后是几月</span></span><br><span class="line">print(day.month_start(n_mon=<span class="number">5</span>)) <span class="comment"># 5个月后当月的第一天</span></span><br><span class="line">print(day.month_end(n_mon=<span class="number">-6</span>))  <span class="comment"># 6个月前的当月第一天</span></span><br><span class="line">print(day.last_week_start())</span><br><span class="line">print(day.last_week_end())</span><br><span class="line">print(day.today_s)</span><br></pre></td></tr></table></figure>
<pre><code>2019-04-25 00:00:00
2019-04-24
6
2019-09-01
2018-10-31
2019-04-15
2019-04-21
time.struct_time(tm_year=2019, tm_mon=4, tm_mday=25, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=115, tm_isdst=-1)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">day1 = Sometime(n=<span class="number">2</span>)  <span class="comment"># 利用n来指定日期，正数是未来，负数是过去</span></span><br><span class="line">print(day1.today)</span><br><span class="line">print(day1.year)</span><br><span class="line">print(day1.yday)</span><br><span class="line">print(day1.mday)</span><br><span class="line">print(day1.wday)</span><br><span class="line">print(day1.weeknum)</span><br><span class="line">print(day1.mranges)</span><br></pre></td></tr></table></figure>
<pre><code>2019-04-28
2019
118
28
6
17
30
</code></pre><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sometime</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, timestr=None, n=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        自定义起始日期，然后从起始日期计算：  </span></span><br><span class="line"><span class="string">        当天日期，昨天日期，  </span></span><br><span class="line"><span class="string">        上月开始结束日期，上周开始结束日期，  </span></span><br><span class="line"><span class="string">        本周是今年第几周，今天是本周第几天  </span></span><br><span class="line"><span class="string">        参数设定： </span></span><br><span class="line"><span class="string">        timestr: str    </span></span><br><span class="line"><span class="string">        按照"2019-01-01"的格式填写  </span></span><br><span class="line"><span class="string">        n: int  </span></span><br><span class="line"><span class="string">        n = 0 默认，等于今天，</span></span><br><span class="line"><span class="string">        n &lt; 0 时，1等于昨天，2等于前天，以此类推  </span></span><br><span class="line"><span class="string">        n &gt; 0 时，-1等于明天，-2等于后天，以此类推</span></span><br><span class="line"><span class="string">        参数timestr存在则默认使用timestr参数！！！</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> timestr <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                time_str = datetime.date.today()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                time_str = (datetime.date.today() -</span><br><span class="line">                            datetime.timedelta(days= -n))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                time_str = datetime.datetime.strptime(timestr, <span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                time_str = datetime.datetime.strptime(timestr, <span class="string">"%Y-%m-%d"</span>)</span><br><span class="line"></span><br><span class="line">        self.today_str = time_str <span class="comment"># 今天的str格式</span></span><br><span class="line">        self.today = time_str.strftime(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">        self.today_struct = time_str.timetuple()  <span class="comment"># 输出今天的struct_time格式</span></span><br><span class="line">        self.yesterday = (time_str - datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line">                          ).strftime(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">        self.year = self.today_s.tm_year    <span class="comment"># 今年年份</span></span><br><span class="line">        self.mday = self.today_s.tm_mday    <span class="comment"># 今天是本月第几天</span></span><br><span class="line">        self.yday = self.today_s.tm_yday    <span class="comment"># 今天是今年第几天</span></span><br><span class="line">        self.wday = self.today_s.tm_wday    <span class="comment"># 今天是本周第几天</span></span><br><span class="line">        self.weeknum = time_str.isocalendar()[<span class="number">1</span>]    <span class="comment"># 今周是今年第几周</span></span><br><span class="line">        self.mranges = calendar.monthrange(self.today_s.tm_year,</span><br><span class="line">                                           self.today_s.tm_mon)[<span class="number">1</span>]    <span class="comment"># 本月天数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">month</span><span class="params">(self, n_mon=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        计算：\n</span></span><br><span class="line"><span class="string">        n月前（当n是负数时）或\n</span></span><br><span class="line"><span class="string">        n月后（当n是正数时）是几月份\n</span></span><br><span class="line"><span class="string">        默认n=0返回当前月份</span></span><br><span class="line"><span class="string">        返回值类型为:int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k = (self.today_s.tm_mon + n_mon) % <span class="number">12</span></span><br><span class="line">        <span class="keyword">if</span> n_mon == <span class="number">0</span>:</span><br><span class="line">            result = self.today_s.tm_mon</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = <span class="number">12</span> <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">else</span> k</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">month_start</span><span class="params">(self, n_mon=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        计算：\n</span></span><br><span class="line"><span class="string">        n月前（当n是负数时）或\n</span></span><br><span class="line"><span class="string">        n月后（当n是正数时）的月份的第一天\n</span></span><br><span class="line"><span class="string">        默认n=0返回当前月份第一天</span></span><br><span class="line"><span class="string">        返回值类型为:string</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        month_l = self.month(n_mon=n_mon)</span><br><span class="line">        y = (self.today_s.tm_mon + n_mon) / <span class="number">12</span></span><br><span class="line">        y1 = (self.today_s.tm_mon + n_mon) // <span class="number">12</span></span><br><span class="line">        <span class="keyword">if</span> y &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> month_l == <span class="number">12</span>:   <span class="comment"># 当月份为12月份时年份提前+1的情况</span></span><br><span class="line">                year_l = self.year + y1 - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                year_l = self.year <span class="keyword">if</span> y1 == <span class="number">0</span> <span class="keyword">else</span> self.year + y1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            year_l = self.year - <span class="number">1</span> <span class="keyword">if</span> y1 == <span class="number">0</span> <span class="keyword">else</span> self.year + y1</span><br><span class="line">        result = datetime.date(</span><br><span class="line">            year=year_l,</span><br><span class="line">            month=month_l,</span><br><span class="line">            day=<span class="number">1</span>).strftime(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">month_end</span><span class="params">(self, n_mon=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        计算：\n</span></span><br><span class="line"><span class="string">        n月前（当n是负数时）或\n</span></span><br><span class="line"><span class="string">        n月后（当n是正数时）的月份的最后一天\n</span></span><br><span class="line"><span class="string">        默认n=0返回当前月份最后一天</span></span><br><span class="line"><span class="string">        返回值类型为:string</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        month_l = self.month(n_mon=n_mon)</span><br><span class="line">        y = (self.today_s.tm_mon + n_mon) / <span class="number">12</span></span><br><span class="line">        y1 = (self.today_s.tm_mon + n_mon) // <span class="number">12</span></span><br><span class="line">        <span class="keyword">if</span> y &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> month_l == <span class="number">12</span>:   <span class="comment"># 当月份为12月份时年份提前+1的情况</span></span><br><span class="line">                year_l = self.year + y1 - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                year_l = self.year <span class="keyword">if</span> y1 == <span class="number">0</span> <span class="keyword">else</span> self.year + y1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            year_l = self.year - <span class="number">1</span> <span class="keyword">if</span> y1 == <span class="number">0</span> <span class="keyword">else</span> self.year + y1</span><br><span class="line">        mrange = calendar.monthrange(year_l, month_l)[<span class="number">1</span>]</span><br><span class="line">        result = datetime.date(</span><br><span class="line">            year=year_l,</span><br><span class="line">            month=month_l,</span><br><span class="line">            day=mrange).strftime(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">last_week_start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回上周第一天"""</span></span><br><span class="line">        result = (</span><br><span class="line">            self.td -</span><br><span class="line">            datetime.timedelta(</span><br><span class="line">                days=self.td.weekday() +</span><br><span class="line">                <span class="number">7</span>)).strftime(<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">last_week_end</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回上周最后一天"""</span></span><br><span class="line">        result = (</span><br><span class="line">            self.td -</span><br><span class="line">            datetime.timedelta(</span><br><span class="line">                days=self.td.weekday() +</span><br><span class="line">                <span class="number">1</span>)).strftime(<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得第n周的周一和周日的日期</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getWeek</span><span class="params">(self, week=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">"""        </span></span><br><span class="line"><span class="string">        计算：\n</span></span><br><span class="line"><span class="string">        n周前（当n是负数时）或\n</span></span><br><span class="line"><span class="string">        n周后（当n是正数时）\n</span></span><br><span class="line"><span class="string">        默认n=0返回目标周的周一和周日日期</span></span><br><span class="line"><span class="string">        返回值类型为:list</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        monday = (self.td - datetime.timedelta(days=(</span><br><span class="line">            -week * <span class="number">7</span> + self.td.weekday() - <span class="number">1</span> + <span class="number">1</span>))).strftime(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">        sunday = (self.td - datetime.timedelta(days=(</span><br><span class="line">           - week * <span class="number">7</span> + self.td.weekday() - <span class="number">7</span> + <span class="number">1</span>))).strftime(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">        <span class="keyword">return</span> [monday,sunday]</span><br></pre></td></tr></table></figure>
<p>通过两种指定“今天”的方式，可以计算出以任意一天为基点的相关日期。非常方便。<br>如果你在使用过程中有什么问题，可以联系我。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>自动化</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>python数据可视化seaborn（二）—— 分布数据可视化</title>
    <url>/blogs/f31a11b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><p>这篇文章是Python可视化seaborn系列的第二篇文章，本文将详解seaborn如何探索数据的分布。<br><a id="more"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">% matplotlib inline</span><br><span class="line"></span><br><span class="line">sns.set(context=<span class="string">'notebook'</span>,font=<span class="string">'simhei'</span>,style=<span class="string">'whitegrid'</span>)</span><br><span class="line"><span class="comment"># 设置风格尺度和显示中文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)  <span class="comment"># 不发出警告</span></span><br></pre></td></tr></table></figure>
<h1 id="单变量"><a href="#单变量" class="headerlink" title="单变量"></a>单变量</h1><h2 id="直方图-displot"><a href="#直方图-displot" class="headerlink" title="直方图 displot"></a>直方图 displot</h2><p><em>seaborn.distplot(a, bins=None, hist=True, kde=True, rug=False, fit=None, hist_kws=None, kde_kws=None, rug_kws=None, fit_kws=None, color=None, vertical=False, norm_hist=False, axlabel=None, label=None, ax=None)</em></p>
<ul>
<li>bins → 箱数</li>
<li>hist、ked、rug → bool,是否显示箱/密度曲线/数据分布</li>
<li>norm_hist → 直方图是否按照密度来显示，如果为False,显示计数</li>
<li>{hist，kde，rug，fit} _kws：字典，对应部分的各种参数。</li>
<li>vertical → 是否水平显示</li>
<li>fit → 可结合scipy库在图像上做拟合</li>
<li>label → 图例</li>
<li>axlabel → x轴标注</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直方图</span></span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> norm <span class="comment">#使用直方图和最大似然高斯分布拟合绘制分布</span></span><br><span class="line"></span><br><span class="line">rs = np.random.RandomState(<span class="number">50</span>)  <span class="comment"># 设置随机数种子</span></span><br><span class="line">s = pd.Series(rs.randn(<span class="number">100</span>)*<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line">sns.distplot(s, bins=<span class="number">10</span>, hist=<span class="keyword">True</span>, kde=<span class="keyword">False</span>, norm_hist=<span class="keyword">False</span>,</span><br><span class="line">            rug=<span class="keyword">True</span>, vertical=<span class="keyword">False</span>,label=<span class="string">'distplot'</span>,</span><br><span class="line">            axlabel=<span class="string">'x轴'</span>,hist_kws=&#123;<span class="string">'color'</span>:<span class="string">'y'</span>,<span class="string">'edgecolor'</span>:<span class="string">'k'</span>&#125;,</span><br><span class="line">            fit=norm)</span><br><span class="line"><span class="comment"># 用标准正态分布拟合</span></span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid(linestyle=<span class="string">'--'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_4_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line">sns.distplot(s,rug = <span class="keyword">True</span>,</span><br><span class="line">            rug_kws = &#123;<span class="string">'color'</span>:<span class="string">'b'</span>&#125; ,</span><br><span class="line">            <span class="comment"># 设置数据频率分布颜色</span></span><br><span class="line">            kde_kws=&#123;<span class="string">"color"</span>: <span class="string">"k"</span>, <span class="string">"lw"</span>: <span class="number">2</span>, <span class="string">"label"</span>: <span class="string">"KDE"</span>,<span class="string">'linestyle'</span>:<span class="string">'--'</span>&#125;,</span><br><span class="line">            <span class="comment"># 设置密度曲线颜色，线宽，标注、线形</span></span><br><span class="line">            hist_kws=&#123;<span class="string">"histtype"</span>: <span class="string">"step"</span>, <span class="string">"linewidth"</span>: <span class="number">2</span>,<span class="string">"alpha"</span>: <span class="number">1</span>, <span class="string">"color"</span>: <span class="string">"g"</span>&#125;)  </span><br><span class="line">            <span class="comment"># 设置箱子的风格、线宽、透明度、颜色</span></span><br><span class="line">            <span class="comment"># 风格包括：'bar', 'barstacked', 'step', 'stepfilled'</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_5_0.png" alt="png"></p>
<h2 id="核密度估计图-kdeplot"><a href="#核密度估计图-kdeplot" class="headerlink" title="核密度估计图 kdeplot"></a>核密度估计图 kdeplot</h2><p>核密度估计的步骤：</p>
<ul>
<li>每一个观测附近用一个正态分布曲线近似</li>
<li>叠加所有观测的正态分布曲线</li>
<li>归一化</li>
</ul>
<p><em>seaborn.kdeplot（data，data2 = None，shade = False，vertical = False，kernel =’gau’，bw =’scott’，gridsize = 100，cut = 3，clip = None，legend = True，cumulative = False，shade_lowest = True，cbar = False，cbar_ax =无，cbar_kws =无，ax =无，** kwargs ）</em></p>
<ul>
<li>shade: 如果为True，则用颜色填充KDE曲线下方的区域（或者在数据为双变量时用颜色填充的轮廓）</li>
<li>kernel: {‘gau’|‘cos’|‘biw’|‘epa’|‘tri’|‘triw’} 用于拟合的核，双变量值能用高斯核（gau）</li>
<li>bw: {‘scott’|’silverman’|标量|一对标量} 确定核的大小，近似理解为拟合程度，bw越大，曲线越平缓。</li>
<li>gridsize：int, 网格中的离散点数</li>
<li>cumulative ：是否绘制累积分布</li>
<li>cbar：参数若为True，则会添加一个颜色条(颜色条在双变量kde图像中才有)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单个样本数据密度分布图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">sns.kdeplot(s,label=<span class="string">'auto'</span>)</span><br><span class="line">sns.kdeplot(s,bw=<span class="number">10</span>, label=<span class="string">"bw: 10"</span>,linewidth = <span class="number">1.5</span>)</span><br><span class="line">sns.kdeplot(s,bw=<span class="number">100</span>, label=<span class="string">"bw: 100"</span>,linestyle = <span class="string">'--'</span>,linewidth = <span class="number">1.5</span>)</span><br><span class="line"><span class="comment"># bw → 也可以类似看做直方图的箱数，数越大，箱子越多，刻画的越精确。</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_8_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.kdeplot(s, label=<span class="string">"累积图"</span>,color=<span class="string">'k'</span>,cumulative=<span class="keyword">True</span>,</span><br><span class="line">            linestyle = <span class="string">'--'</span>,linewidth = <span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_9_0.png" alt="png"></p>
<p><strong> 核密度各级图不但能绘制单个变量的，也能绘制双变量！！！</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2、密度图 - kdeplot()</span></span><br><span class="line"><span class="comment"># 两个样本数据密度分布图</span></span><br><span class="line"></span><br><span class="line">rs = np.random.RandomState(<span class="number">2</span>)  <span class="comment"># 设定随机数种子</span></span><br><span class="line">df = pd.DataFrame(rs.randn(<span class="number">100</span>,<span class="number">2</span>),</span><br><span class="line">                 columns = [<span class="string">'A'</span>,<span class="string">'B'</span>])</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line">sns.kdeplot(df[<span class="string">'A'</span>],df[<span class="string">'B'</span>],</span><br><span class="line">           cbar = <span class="keyword">True</span>,    <span class="comment"># 是否显示颜色图例</span></span><br><span class="line">           shade = <span class="keyword">True</span>,   <span class="comment"># 是否填充</span></span><br><span class="line">           cmap = <span class="string">'Reds_r'</span>,  <span class="comment"># 设置调色盘</span></span><br><span class="line">           shade_lowest=<span class="keyword">True</span>,  <span class="comment"># 最外围颜色是否显示</span></span><br><span class="line">           n_levels = <span class="number">10</span>,   <span class="comment"># 曲线个数（越大，越密集）</span></span><br><span class="line">           bw = <span class="number">.3</span></span><br><span class="line">           )</span><br><span class="line"><span class="comment"># 两个维度数据生成曲线密度图，以颜色作为密度衰减显示</span></span><br><span class="line"></span><br><span class="line">sns.rugplot(df[<span class="string">'A'</span>], color=<span class="string">"g"</span>, axis=<span class="string">'x'</span>,alpha = <span class="number">0.5</span>)</span><br><span class="line">sns.rugplot(df[<span class="string">'B'</span>], color=<span class="string">"k"</span>, axis=<span class="string">'y'</span>,alpha = <span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 注意设置x，y轴</span></span><br></pre></td></tr></table></figure>
<p><img src="output_11_1.png" alt="png"></p>
<h1 id="双变量"><a href="#双变量" class="headerlink" title="双变量"></a>双变量</h1><h2 id="jointplot"><a href="#jointplot" class="headerlink" title="jointplot"></a>jointplot</h2><p><em>seaborn.jointplot（x，y，data = None，kind =’scatter’，color = None，height = 6，ratio = 5，space = 0.2，dropna = True，xlim = None，ylim = None，joint_kws = None，marginal_kws =None，annot_kws =None，** kwargs ）</em></p>
<p>该函数是<code>JoinGrid类</code>的一个轻量级界面，如果想更加灵活的绘制，可以使用<code>JoinGrid</code>函数</p>
<ul>
<li>kind: 设置类型：“scatter”、“reg”、“resid”、“kde”、“hex”</li>
<li>height: int, 图像大小（图像自动调整为正方形）</li>
<li>radio: int, 主图与边缘图的高度比</li>
<li>space:  # 设置主图和边缘图的间距</li>
<li>{x，y} lim ：在绘图之前设置轴限制</li>
<li>{joint，marginal，annot} _kws：dicts 绘图组件的其他关键字参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 散点图 + 边缘直方图</span></span><br><span class="line"></span><br><span class="line">tips = sns.load_dataset(<span class="string">"tips"</span>)</span><br><span class="line"></span><br><span class="line">sns.jointplot(x=<span class="string">'total_bill'</span>, y=<span class="string">'tip'</span>,  <span class="comment"># 设置xy轴，显示columns名称</span></span><br><span class="line">              data=tips,   <span class="comment"># 设置数据</span></span><br><span class="line">              color = <span class="string">'k'</span>,   <span class="comment"># 设置颜色</span></span><br><span class="line">              s = <span class="number">50</span>, edgecolor=<span class="string">"w"</span>,linewidth=<span class="number">1</span>,</span><br><span class="line">              <span class="comment"># 设置散点大小、边缘线颜色及宽度(只针对scatter）</span></span><br><span class="line">              kind = <span class="string">'scatter'</span>,</span><br><span class="line">              space = <span class="number">0.2</span>,  <span class="comment"># 设置散点图和布局图的间距</span></span><br><span class="line">              height = <span class="number">7</span>, ratio = <span class="number">5</span>,  <span class="comment"># 散点图与布局图高度比，整型</span></span><br><span class="line">              marginal_kws=dict(bins=<span class="number">20</span>, rug=<span class="keyword">True</span>)  <span class="comment"># 设置柱状图箱数，是否设置rug</span></span><br><span class="line">              )</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_15_0.png" alt="png"></p>
<p><strong>seaborn会直接给出变量的皮尔逊相关系数和P值</strong><br>pearson相关系数计算：</p>
<ul>
<li>$\rho_{X,Y} = \frac{cov(X,Y)} {\sigma_X \sigma_Y}$</li>
<li>p：样本间的差异由抽样误差所致的概率小于p.<a href="https://en.wikipedia.org/wiki/P-value" target="_blank" rel="noopener">p-value</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回归图 + 边缘直方图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sns.axes_style(<span class="string">"ticks"</span>):</span><br><span class="line">    sns.jointplot(x=<span class="string">'total_bill'</span>, y=<span class="string">'tip'</span>,data = tips,</span><br><span class="line">                  kind=<span class="string">"hex"</span>, color=<span class="string">"r"</span>,   <span class="comment"># 主图为六角箱图</span></span><br><span class="line">                  height=<span class="number">6</span>,space=<span class="number">0.1</span>,</span><br><span class="line">                  joint_kws=dict(gridsize=<span class="number">20</span>,edgecolor=<span class="string">'w'</span>),  <span class="comment"># 主图参数设置</span></span><br><span class="line">                  marginal_kws=dict(bins=<span class="number">20</span>,color=<span class="string">'g'</span>,</span><br><span class="line">                                    hist_kws=&#123;<span class="string">'edgecolor'</span>:<span class="string">'k'</span>&#125;),   <span class="comment"># 边缘图设置</span></span><br><span class="line">                  annot_kws=dict(stat=<span class="string">'r'</span>,fontsize=<span class="number">15</span>))  <span class="comment"># 修改统计注释</span></span><br></pre></td></tr></table></figure>
<p><img src="output_17_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 密度图</span></span><br><span class="line"></span><br><span class="line">rs = np.random.RandomState(<span class="number">15</span>)</span><br><span class="line">df = pd.DataFrame(rs.randn(<span class="number">300</span>,<span class="number">2</span>),columns = [<span class="string">'A'</span>,<span class="string">'B'</span>])</span><br><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line"><span class="keyword">with</span> sns.axes_style(<span class="string">"white"</span>):<span class="comment"># 设置当前图的样式</span></span><br><span class="line">    g = sns.jointplot(x=df[<span class="string">'A'</span>], y=df[<span class="string">'B'</span>],data = df,</span><br><span class="line">                  kind=<span class="string">"kde"</span>, color=<span class="string">"k"</span>,shade_lowest=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># 创建密度图</span></span><br><span class="line"></span><br><span class="line">    g.plot_joint(plt.scatter,c=<span class="string">"r"</span>, s=<span class="number">30</span>, linewidth=<span class="number">1</span>, marker=<span class="string">"+"</span>)</span><br><span class="line"><span class="comment"># 添加散点图</span></span><br></pre></td></tr></table></figure>
<p><img src="output_18_0.png" alt="png"></p>
<h2 id="JointGrid"><a href="#JointGrid" class="headerlink" title="JointGrid"></a>JointGrid</h2><p>前面讲过jointplot其实是JoinGrid的一个封装，要想有更灵活的设置，可以使用<code>JoinGrid类</code></p>
<ul>
<li>__init__（x，y，data = None，height = 6，ratio = 5，space = 0.2，dropna = True，xlim = None，ylim = None）<br> 方法：<ul>
<li>plot（joint_func，marginal_func ,annot_func)→ 绘制完整的图形</li>
<li>plot_joint（func，** kwargs）→  绘制双变量图形</li>
<li>plot_marginals（func，** kwargs）→   绘制边缘单变量图形</li>
<li>savefig（* args，** kwargs）→   保存</li>
<li>set_axis_labels（[xlabel，ylabel]）→  在双变量轴上设置轴标签。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可拆分绘制的散点图</span></span><br><span class="line"><span class="comment"># plot_joint() + ax_marg_x.hist() + ax_marg_y.hist()</span></span><br><span class="line"></span><br><span class="line">sns.set_style(<span class="string">"white"</span>)</span><br><span class="line"><span class="comment"># 设置风格</span></span><br><span class="line"></span><br><span class="line">g = sns.JointGrid(x=<span class="string">"total_bill"</span>, y=<span class="string">"tip"</span>, data=tips, height=<span class="number">7</span>)</span><br><span class="line"><span class="comment"># 创建一个绘图表格区域，设置好x、y对应数据</span></span><br><span class="line"></span><br><span class="line">g.plot_joint(sns.kdeplot, color =<span class="string">'m'</span>, edgecolor = <span class="string">'white'</span>)  <span class="comment"># 设置框内图表，scatter</span></span><br><span class="line">g.ax_marg_x.hist(tips[<span class="string">"total_bill"</span>], color=<span class="string">"b"</span>, alpha=<span class="number">.6</span>,</span><br><span class="line">                 edgecolor=<span class="string">'k'</span>,bins=np.arange(<span class="number">0</span>, <span class="number">60</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 设置x轴直方图，注意bins是数组</span></span><br><span class="line">g.ax_marg_y.hist(tips[<span class="string">"tip"</span>], color=<span class="string">"r"</span>, alpha=<span class="number">.6</span>,</span><br><span class="line">                 orientation=<span class="string">"horizontal"</span>,edgecolor=<span class="string">'k'</span>,</span><br><span class="line">                 bins=np.arange(<span class="number">0</span>, <span class="number">12</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># 设置y轴直方图，注意需要orientation参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line">g.annotate(stats.spearmanr , fontsize=<span class="number">16</span>, loc=<span class="string">'best'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置标注，可以为pearsonr，spearmanr，或者是自定义的函数</span></span><br><span class="line"></span><br><span class="line">plt.grid(linestyle = <span class="string">'--'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="output_20_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可拆分绘制的散点图</span></span><br><span class="line"><span class="comment"># plot_joint() + plot_marginals()</span></span><br><span class="line"></span><br><span class="line">g = sns.JointGrid(x=<span class="string">"total_bill"</span>, y=<span class="string">"tip"</span>, data=tips,height=<span class="number">6.5</span>,ratio=<span class="number">6</span>)</span><br><span class="line"><span class="comment"># 创建一个绘图表格区域，设置好x、y对应数据</span></span><br><span class="line"></span><br><span class="line">g = g.plot_joint(plt.scatter,color=<span class="string">"g"</span>, s=<span class="number">50</span>, edgecolor=<span class="string">"white"</span>)   <span class="comment"># 绘制散点图</span></span><br><span class="line">plt.grid(linestyle = <span class="string">'--'</span>)  <span class="comment"># 设置网格线</span></span><br><span class="line">g.plot_marginals(sns.distplot, kde=<span class="keyword">True</span>, hist_kws=&#123;<span class="string">'color'</span>:<span class="string">'g'</span>,<span class="string">'edgecolor'</span>:<span class="string">'k'</span>&#125;)  <span class="comment"># 设置边缘图</span></span><br><span class="line"></span><br><span class="line">rsquare = <span class="keyword">lambda</span> a, b: stats.pearsonr(a, b)[<span class="number">0</span>] ** <span class="number">2</span>   <span class="comment"># 自定义统计函数</span></span><br><span class="line">g = g.annotate(rsquare, template=<span class="string">"&#123;stat&#125;: &#123;val:.2f&#125;"</span>,</span><br><span class="line">               stat=<span class="string">"$R^2$"</span>, loc=<span class="string">"upper left"</span>, fontsize=<span class="number">16</span>)  <span class="comment"># 设置注释</span></span><br></pre></td></tr></table></figure>
<p><img src="output_21_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、综合散点图 - JointGrid()</span></span><br><span class="line"><span class="comment"># 可拆分绘制的散点图</span></span><br><span class="line"><span class="comment"># plot_joint() + plot_marginals()</span></span><br><span class="line"><span class="comment"># kde - 密度图</span></span><br><span class="line"></span><br><span class="line">g = sns.JointGrid(x=<span class="string">"total_bill"</span>, y=<span class="string">"tip"</span>, data=tips,space=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 创建一个绘图表格区域，设置好x、y对应数据</span></span><br><span class="line"></span><br><span class="line">g = g.plot_joint(sns.regplot)     <span class="comment"># 绘制密度图</span></span><br><span class="line">plt.grid(linestyle = <span class="string">'--'</span>)</span><br><span class="line">g.plot_marginals(sns.distplot, color=<span class="string">"r"</span>,bins=<span class="number">20</span>,hist_kws=&#123;<span class="string">'edgecolor'</span>:<span class="string">'k'</span>&#125;)  <span class="comment"># 绘制x，y轴密度图</span></span><br><span class="line">g.annotate(stats.pearsonr)</span><br></pre></td></tr></table></figure>
<p><img src="output_22_1.png" alt="png"></p>
<h1 id="探索两两变量之间的关系"><a href="#探索两两变量之间的关系" class="headerlink" title="探索两两变量之间的关系"></a>探索两两变量之间的关系</h1><p>通常我们的数据并不是只有一个或者两个变量，那么对于多个变量，我们常需要探索两两变量之间的分布及关系这是我们就需要使用<code>pairplot</code>函数<br>或者是<code>PairGrid类</code></p>
<h2 id="pairplot"><a href="#pairplot" class="headerlink" title="pairplot"></a>pairplot</h2><p><em>seaborn.pairplot（data，hue = None，hue_order = None，palette = None，vars = None，x_vars = None，y_vars = None，kind =’scatter’，diag_kind =’auto’，markers = None，s = 2.5，aspect = 1，dropna = True，plot_kws = None，diag_kws = None，grid_kws = None）</em></p>
<ul>
<li>hue: string(变量名) ： 颜色将按照指定的变量分类</li>
<li>hue_order ： list 设置调色板色调变量级别</li>
<li>palette ： 调色板</li>
<li>vars : list 变量名称列表，否则使用所有数值型变量的列</li>
<li>markers: 点样式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2、矩阵散点图 - pairplot()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sns.set_style("white")</span></span><br><span class="line"><span class="comment"># 设置风格</span></span><br><span class="line"></span><br><span class="line">iris = sns.load_dataset(<span class="string">"iris"</span>)</span><br><span class="line">print(iris.head())</span><br><span class="line"><span class="comment"># 读取鸢尾花数据</span></span><br><span class="line"></span><br><span class="line">sns.pairplot(iris,</span><br><span class="line">            kind = <span class="string">'scatter'</span>,  <span class="comment"># 散点图/回归分布图 &#123;‘scatter’, ‘reg’&#125;  </span></span><br><span class="line">            diag_kind=<span class="string">"hist"</span>,  <span class="comment"># 设置对角线图直方图/密度图 &#123;‘hist’, ‘kde’&#125;</span></span><br><span class="line">            hue=<span class="string">"species"</span>,   <span class="comment"># 按照某一字段进行分类</span></span><br><span class="line">            palette=<span class="string">"husl"</span>,  <span class="comment"># 设置调色板</span></span><br><span class="line">            markers=[<span class="string">"o"</span>, <span class="string">"s"</span>, <span class="string">"D"</span>],  <span class="comment"># 设置不同系列的点样式（这里根据参考分类个数）</span></span><br><span class="line">            height = <span class="number">2</span>,   <span class="comment"># 图表大小</span></span><br><span class="line">            plot_kws=&#123;<span class="string">'s'</span>:<span class="number">20</span>&#125;,    <span class="comment"># 设置点大小</span></span><br><span class="line">            diag_kws=&#123;<span class="string">'edgecolor'</span>:<span class="string">'w'</span>&#125;)  <span class="comment"># 设置对角线直方图样式</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<pre><code>   sepal_length  sepal_width  petal_length  petal_width species
0           5.1          3.5           1.4          0.2  setosa
1           4.9          3.0           1.4          0.2  setosa
2           4.7          3.2           1.3          0.2  setosa
3           4.6          3.1           1.5          0.2  setosa
4           5.0          3.6           1.4          0.2  setosa
</code></pre><p><img src="output_25_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2、矩阵散点图 - pairplot()</span></span><br><span class="line"><span class="comment"># 其他参数设置</span></span><br><span class="line"></span><br><span class="line">sns.pairplot(iris, kind=<span class="string">"reg"</span>,hue=<span class="string">'species'</span>, <span class="comment"># 设置回归图形</span></span><br><span class="line">             diag_kind=<span class="string">'kde'</span>,palette=<span class="string">'hls'</span>,  <span class="comment"># 设置对角线图类型及调色盘</span></span><br><span class="line">             diag_kws=dict(shade=<span class="keyword">True</span>),height=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><img src="output_26_1.png" alt="png"></p>
<h2 id="PairGrid"><a href="#PairGrid" class="headerlink" title="PairGrid"></a>PairGrid</h2><p>相当于<code>jointplot</code> 和 <code>JointGrid</code>的关系，PairGrid 对矩阵散点图有着更为灵活的控制</p>
<ul>
<li>__init__（data，hue = None，hue_order = None，palette = None，hue_kws = None，vars = None，x_vars = None，y_vars = None，diag_sharey = True，height = 2.5，aspect = 1，despine = True，dropna = True）<br>方法：<ul>
<li>add_legend（[legend_data，title，label_order]）绘制一个图例，可能将其放在轴外并调整图形大小。</li>
<li>map_diag（func，** kwargs）：在每个对角线子图上绘制具有单变量函数的图。</li>
<li>map_lower（func，** kwargs）：在下对角线子图上绘制具有双变量函数的图。</li>
<li>map_upper（func，** kwargs）：在上对角线子图上绘制具有双变量函数的图</li>
<li>map_offdiag（func，** kwargs）：在非对角线子图上绘制具有双变量函数的图。</li>
<li>set（** kwargs）：在每个子图集Axes上设置属性。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2、矩阵散点图 - PairGrid()</span></span><br><span class="line"><span class="comment"># 可拆分绘制的散点图</span></span><br><span class="line"><span class="comment"># map_diag() + map_offdiag()</span></span><br><span class="line"></span><br><span class="line">g = sns.PairGrid(iris,hue=<span class="string">"species"</span>,palette = <span class="string">'hls'</span>,height=<span class="number">2</span>,</span><br><span class="line">                vars = [<span class="string">'sepal_length'</span>,<span class="string">'sepal_width'</span>,<span class="string">'petal_length'</span>,<span class="string">'petal_width'</span>],  <span class="comment"># 可筛选</span></span><br><span class="line">                )</span><br><span class="line"><span class="comment"># 创建一个绘图表格区域，设置好x、y对应数据，按照species分类</span></span><br><span class="line"></span><br><span class="line">g.map_diag(plt.hist,</span><br><span class="line">           histtype = <span class="string">'barstacked'</span>,   <span class="comment"># 可选：'bar', 'barstacked', 'step', 'stepfilled'</span></span><br><span class="line">           linewidth = <span class="number">1</span>, edgecolor = <span class="string">'w'</span>)</span><br><span class="line"><span class="comment"># 对角线图表，plt.hist/sns.kdeplot</span></span><br><span class="line"></span><br><span class="line">g.map_offdiag(plt.scatter,</span><br><span class="line">              edgecolor=<span class="string">"w"</span>, s=<span class="number">40</span>,linewidth = <span class="number">1</span>   <span class="comment"># 设置点颜色、大小、描边宽度</span></span><br><span class="line">                )</span><br><span class="line"><span class="comment"># 其他图表，plt.scatter/plt.bar...</span></span><br><span class="line"></span><br><span class="line">g.add_legend()</span><br><span class="line"><span class="comment"># 添加图例</span></span><br></pre></td></tr></table></figure>
<p><img src="output_28_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2、矩阵散点图 - PairGrid()</span></span><br><span class="line"><span class="comment"># 可拆分绘制的散点图</span></span><br><span class="line"><span class="comment"># map_diag() + map_lower() + map_upper()</span></span><br><span class="line"></span><br><span class="line">g = sns.PairGrid(iris[iris[<span class="string">'species'</span>]==<span class="string">'versicolor'</span>])</span><br><span class="line">g.map_diag(sns.kdeplot, lw=<span class="number">3</span>)   <span class="comment"># 设置对角线图表</span></span><br><span class="line">g.map_upper(sns.regplot, color = <span class="string">'b'</span>)     <span class="comment"># 设置对角线上端图表</span></span><br><span class="line">g.map_lower(sns.kdeplot, cmap=<span class="string">"Blues_d"</span>)      <span class="comment"># 设置对角线下端图表</span></span><br></pre></td></tr></table></figure>
<p><img src="output_29_2.png" alt="png"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>可视化</tag>
        <tag>seaborn</tag>
      </tags>
  </entry>
  <entry>
    <title>python数据可视化seaborn（一）—— 整体样式与调色板</title>
    <url>/blogs/4f39f027/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><p>很久之前对seaborn有过一些涉及但是没有深入探究，这次有趁着有数据可视化的需求，就好好学一学</p>
<p>Seaborn其实是在matplotlib的基础上进行了更高级的API封装，从而使得作图更加容易，在大多数情况下使用seaborn就能做出很具有吸引力的图，为数据分析提供了很大的便利性。但是应该把Seaborn视为matplotlib的补充，而不是替代物。</p>
<p>这次就从最基本的图标风格和调色板开始，学习seaborn。<br><a id="more"></a></p>
<h1 id="图表风格（style）设置"><a href="#图表风格（style）设置" class="headerlink" title="图表风格（style）设置"></a>图表风格（style）设置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用 matplotlib创建一个正弦函数及图表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sinplot</span><span class="params">(flip=<span class="number">1</span>)</span>:</span></span><br><span class="line">    x = np.linspace(<span class="number">0</span>, <span class="number">14</span>, <span class="number">100</span>)</span><br><span class="line"><span class="comment">#     fig = plt.figure(figsize=(10,6))</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">        plt.plot(x, np.sin(x + i * <span class="number">.5</span>) * (<span class="number">7</span> - i) * flip)</span><br><span class="line"></span><br><span class="line">sinplot()</span><br></pre></td></tr></table></figure>
<p><img src="output_2_0.png" alt="png"></p>
<h2 id="sns-set-设置样式参数"><a href="#sns-set-设置样式参数" class="headerlink" title="sns.set()  设置样式参数"></a>sns.set()  设置样式参数</h2><p><em>seaborn.set（context =’notebook’，style =’darkgrid’，palette =’deep’，font =’sans-serif’，font_scale = 1，color_codes = True，rc = None)</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.set(style=<span class="string">'darkgrid'</span>,font_scale=<span class="number">1.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用此方法可以快速设置seaborn的默认风格，当然也可以添加参数设置其他风格</span></span><br><span class="line"><span class="comment"># font_scale：float，单独的缩放因子可以独立缩放字体元素的大小。</span></span><br><span class="line"></span><br><span class="line">sinplot()</span><br></pre></td></tr></table></figure>
<p><img src="output_4_0.png" alt="png"></p>
<h2 id="set-style-设置图标风格"><a href="#set-style-设置图标风格" class="headerlink" title="set_style() 设置图标风格"></a>set_style() 设置图标风格</h2><p><em>seaborn.set_style（style = None，rc = None )</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换seaborn图表风格</span></span><br><span class="line"><span class="comment"># 风格选择包括："white", "dark", "whitegrid", "darkgrid", "ticks"</span></span><br><span class="line"><span class="comment"># rc：dict，可选,参数映射以覆盖预设的seaborn样式字典中的值</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">ax1 = fig.add_subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">sns.set_style(<span class="string">'whitegrid'</span>,&#123;<span class="string">"xtick.major.size"</span>: <span class="number">10</span>, <span class="string">"ytick.major.size"</span>: <span class="number">10</span>&#125;)</span><br><span class="line">data = np.random.normal(size=(<span class="number">20</span>,<span class="number">6</span>)) + np.arange(<span class="number">6</span>) / <span class="number">2</span></span><br><span class="line">sns.boxplot(data=data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax2 =  fig.add_subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">sinplot()</span><br></pre></td></tr></table></figure>
<p><img src="output_6_0.png" alt="png"></p>
<h2 id="sns-despine-设置坐标轴"><a href="#sns-despine-设置坐标轴" class="headerlink" title="sns.despine() 设置坐标轴"></a>sns.despine() 设置坐标轴</h2><p><em>seaborn.despine(fig=None, ax=None, top=True, right=True, left=False, bottom=False, offset=None, trim=False)</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置图表坐标轴</span></span><br><span class="line"></span><br><span class="line">sns.set(style=<span class="string">'ticks'</span>,font_scale=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 设置风格</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>,<span class="number">12</span>))</span><br><span class="line">plt.subplots_adjust(hspace=<span class="number">0.3</span>)   <span class="comment"># 调整子图间距</span></span><br><span class="line"><span class="comment"># 图表基本设置</span></span><br><span class="line"></span><br><span class="line">ax1 = fig.add_subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">sinplot()</span><br><span class="line">sns.despine(ax=ax1)</span><br><span class="line"><span class="comment"># 默认隐藏右边和上边的坐标轴</span></span><br><span class="line"></span><br><span class="line">ax2 = fig.add_subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">sns.violinplot(data=data)</span><br><span class="line">sns.despine(ax=ax2,offset=&#123;<span class="string">'bottom'</span>:<span class="number">5</span>,<span class="string">'left'</span>:<span class="number">10</span>&#125;)</span><br><span class="line"><span class="comment"># offset ：坐标轴是否分开偏移,正值向外侧移动，负值向内侧移动.可用字典单独对每个轴设置</span></span><br><span class="line"><span class="comment"># trim: 当为True时，坐标轴两端限制在数据的最大最小值处</span></span><br><span class="line"></span><br><span class="line">ax3 = fig.add_subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">sns.boxplot(data=data, palette=<span class="string">'deep'</span>)</span><br><span class="line">sns.despine(ax=ax3,left=<span class="keyword">True</span>, right= <span class="keyword">False</span>, trim=<span class="keyword">True</span>,</span><br><span class="line">           offset=&#123;<span class="string">'bottom'</span>:<span class="number">10</span>,<span class="string">'right'</span>:<span class="number">10</span>&#125;)</span><br><span class="line"><span class="comment"># top, right, left, bottom：布尔型，为True时不显示</span></span><br></pre></td></tr></table></figure>
<p><img src="output_8_0.png" alt="png"></p>
<h2 id="sns-axes-style-设置子图风格"><a href="#sns-axes-style-设置子图风格" class="headerlink" title="sns.axes_style() 设置子图风格"></a>sns.axes_style() 设置子图风格</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4、axes_style()</span></span><br><span class="line"><span class="comment"># 设置局部图表风格，可学习和with配合的用法</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>))</span><br><span class="line"><span class="keyword">with</span> sns.axes_style(<span class="string">"darkgrid"</span>):</span><br><span class="line">    plt.subplot(<span class="number">211</span>)</span><br><span class="line">    sinplot()</span><br><span class="line"><span class="comment"># 设置局部图表风格，用with做代码块区分</span></span><br><span class="line"></span><br><span class="line">sns.set_style(<span class="string">"whitegrid"</span>)</span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">sinplot()</span><br><span class="line"><span class="comment"># 外部表格风格</span></span><br></pre></td></tr></table></figure>
<p><img src="output_10_0.png" alt="png"></p>
<h2 id="设置显示比例尺度-set-context"><a href="#设置显示比例尺度-set-context" class="headerlink" title="设置显示比例尺度 set_context()"></a>设置显示比例尺度 set_context()</h2><p><em>seaborn.set_context（context = None，font_scale = 1，rc = None )</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置显示比例尺度</span></span><br><span class="line"><span class="comment"># 选择包括：'paper', 'notebook', 'talk', 'poster'.这四个是预设的。不会影响整体样式。</span></span><br><span class="line"><span class="comment"># 默认为notebook</span></span><br><span class="line"></span><br><span class="line">sns.set_context(<span class="string">"notebook"</span>)</span><br><span class="line">sinplot()</span><br><span class="line">plt.grid(linestyle=<span class="string">'--'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="output_12_0.png" alt="png"></p>
<h1 id="图标颜色设置-color-palette"><a href="#图标颜色设置-color-palette" class="headerlink" title="图标颜色设置 color_palette()"></a>图标颜色设置 color_palette()</h1><p><em>sns.color_palette(palette=None, n_colors=None, desat=None)</em></p>
<p>我们选择颜色常常依据数据特征来选择，所以下面就从</p>
<ul>
<li><code>分类</code>：彼此间差异较大</li>
<li><code>连续</code>：颜色按照顺序渐变</li>
<li><code>发散</code>：中间颜色浅，两端颜色深</li>
</ul>
<p>三个调色板来讲解<code>color_palette()</code>函数</p>
<h2 id="分类调色板"><a href="#分类调色板" class="headerlink" title="分类调色板"></a>分类调色板</h2><p>当你不用区分离散数据的顺序时，建议使用分类调色板</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认6种颜色：deep, muted, pastel, bright, dark, colorblind</span></span><br><span class="line"><span class="comment"># n_colors：int,调色板中的颜色数量</span></span><br><span class="line"><span class="comment"># dasat:float，去饱和度0-1之间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">current_palette = sns.color_palette()</span><br><span class="line">sns.palplot(current_palette)</span><br><span class="line"><span class="comment"># 当不带参数的调用将返回当前默认颜色循环中的所有颜色</span></span><br><span class="line"><span class="comment"># 可以传入任何matplotlib支持的颜色</span></span><br></pre></td></tr></table></figure>
<p><img src="output_14_0.png" alt="png"></p>
<h3 id="圆形调色系统"><a href="#圆形调色系统" class="headerlink" title="圆形调色系统"></a>圆形调色系统</h3><p>当需要6中以上的颜色时，可以在圆形颜色空间中按均匀间隔画出颜色。</p>
<p>最常见的是使用<code>hls</code>颜色空间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.palplot(sns.color_palette(<span class="string">'hls'</span>,<span class="number">8</span>))</span><br><span class="line"><span class="comment"># 颜色色块个数为8个</span></span><br></pre></td></tr></table></figure>
<p><img src="output_16_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = np.random.normal(size=(<span class="number">10</span>, <span class="number">8</span>)) + np.arange(<span class="number">8</span>) / <span class="number">2</span></span><br><span class="line">sns.boxplot(data=data,palette=sns.color_palette(<span class="string">"hls"</span>, <span class="number">8</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="output_17_0.png" alt="png"></p>
<ul>
<li>HLS色调空间：<em>hls_palette([n_colors, h, l, s])</em>  </li>
<li>HUSL色调空间：<em>husl_palette([n_colors, h, l, s])</em></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置亮度，饱和度</span></span><br><span class="line"><span class="comment"># h - 第一个色调</span></span><br><span class="line"><span class="comment"># l - 亮度</span></span><br><span class="line"><span class="comment"># s - 饱和度</span></span><br><span class="line"></span><br><span class="line">sns.palplot(sns.husl_palette(<span class="number">8</span>, l=<span class="number">.6</span>, s=<span class="number">.7</span>))</span><br><span class="line"><span class="comment"># 这个看上去更舒服，更易区分</span></span><br></pre></td></tr></table></figure>
<p><img src="output_19_0.png" alt="png"></p>
<h3 id="使用分类Color-Brewer调色板"><a href="#使用分类Color-Brewer调色板" class="headerlink" title="使用分类Color Brewer调色板"></a>使用分类Color Brewer调色板</h3><p>另一个分类色板来源于Color Brewer（<code>同样也具有连续色板和发散色板</code>），它也同样存在于matplotlib colormaps中，但是并没有得到很好的处理。在Seaborn中，当你调用Color Brewer分类色板时，你总能得到离散的颜色，但是这意味着它们在某一点开始了循环。</p>
<p><a href="http://colorbrewer2.org" target="_blank" rel="noopener">Color Brewer</a>网站的一个很好的功能是它提供了一些关于哪些调色板是色盲安全的指导</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Color Brewer颜色设置</span></span><br><span class="line">sns.palplot(sns.color_palette(<span class="string">"Paired"</span>,<span class="number">8</span>))</span><br><span class="line">sns.palplot(sns.color_palette(<span class="string">"Set1"</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p><img src="output_21_0.png" alt="png"></p>
<p><img src="output_21_1.png" alt="png"></p>
<h3 id="使用xkcd颜色测量中的命名颜色"><a href="#使用xkcd颜色测量中的命名颜色" class="headerlink" title="使用xkcd颜色测量中的命名颜色"></a>使用xkcd颜色测量中的命名颜色</h3><p>xkcd包含了一系列命名RGB颜色。共954种颜色，您现在可以使用xkcd_rgb字典在seaborn中引用它们：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], sns.xkcd_rgb[<span class="string">"pale red"</span>], lw=<span class="number">3</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">2</span>], sns.xkcd_rgb[<span class="string">"medium green"</span>], lw=<span class="number">3</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">3</span>], sns.xkcd_rgb[<span class="string">"denim blue"</span>], lw=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><img src="output_23_1.png" alt="png"></p>
<h2 id="顺序调色板"><a href="#顺序调色板" class="headerlink" title="顺序调色板"></a>顺序调色板</h2><p>当数据范围从相对较低或不感兴趣的值到相对较高或有趣的值时，可以使用连续(顺序)调色板，在kdeplot()和heatmap()函数中常常会用到。</p>
<p>具有大色调偏移的色彩图往往会引入数据中不存在的不连续性，并且我们的视觉系统无法自然地将彩虹映射到诸如“高”或“低”的定量区别。结果是这些可视化最终更像是一个谜题，它们模糊了数据中的模式而不是揭示它们</p>
<p>所以对于顺序数据，最好使用色调最多相对微妙偏移的调色板，伴随着亮度和饱和度的大幅度变化。这种方法自然会吸引人们关注数据的相对重要部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.palplot(sns.color_palette(<span class="string">"Blues"</span>))</span><br><span class="line">sns.palplot(sns.color_palette(<span class="string">"Blues_r"</span>))</span><br><span class="line"><span class="comment"># 与matplotlib中一样，如果您希望反转亮度渐变，则可以为_r调色板名称添加后缀</span></span><br><span class="line"><span class="comment"># 不是所有颜色都可以反转！！！</span></span><br></pre></td></tr></table></figure>
<p><img src="output_25_0.png" alt="png"></p>
<p><img src="output_25_1.png" alt="png"></p>
<h3 id="顺序-cubehelix-调色板"><a href="#顺序-cubehelix-调色板" class="headerlink" title="顺序 cubehelix 调色板"></a>顺序 cubehelix 调色板</h3><p><a href="https://www.mrao.cam.ac.uk/~dag/CUBEHELIX/" target="_blank" rel="noopener">cubehelix</a>调色板系统既能亮度线性变化同时也能色调变化的线性色板。这意味着当转换为黑白（用于打印）或由色盲个人查看时，色彩映射中的信息将被保留。</p>
<p><em>seaborn.cubehelix_palette（n_colors = 6，start = 0，rot = 0.4，gamma = 1.0，hue = 0.8，light = 0.85，dark = 0.15，reverse = False，as_cmap = False ）</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照线性增长计算，设置颜色</span></span><br><span class="line"></span><br><span class="line">sns.palplot(sns.color_palette(<span class="string">"cubehelix"</span>, <span class="number">8</span>))</span><br><span class="line">sns.palplot(sns.cubehelix_palette(<span class="number">8</span>, gamma=<span class="number">2</span>))</span><br><span class="line">sns.palplot(sns.cubehelix_palette(<span class="number">8</span>, start=<span class="number">.5</span>, rot=<span class="number">-.75</span>))</span><br><span class="line">sns.palplot(sns.cubehelix_palette(<span class="number">8</span>, start=<span class="number">2</span>, rot=<span class="number">0</span>, dark=<span class="number">0</span>, light=<span class="number">.95</span>, reverse=<span class="keyword">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># n_colors → 颜色个数</span></span><br><span class="line"><span class="comment"># start → 值区间在[0,3]，开始颜色</span></span><br><span class="line"><span class="comment"># rot → float,颜色旋转角度,可能是（-1,1）之间</span></span><br><span class="line"><span class="comment"># gamma → 颜色伽马值，&gt;1 较亮，&lt;1 较暗</span></span><br><span class="line"><span class="comment"># dark，light → 值区间0-1，颜色深浅</span></span><br><span class="line"><span class="comment"># reverse → 布尔值，默认为False，由浅到深</span></span><br></pre></td></tr></table></figure>
<p><img src="output_27_0.png" alt="png"></p>
<p><img src="output_27_1.png" alt="png"></p>
<p><img src="output_27_2.png" alt="png"></p>
<p><img src="output_27_3.png" alt="png"></p>
<h3 id="自定义顺序调色板"><a href="#自定义顺序调色板" class="headerlink" title="自定义顺序调色板"></a>自定义顺序调色板</h3><p>对于自定义顺序调色板的简单界面，您可以使用<code>light_palette()</code>或使用<code>dark_palette()</code>，都是由单一的颜色并生成从浅色或深色去饱和值到该颜色的渐变调色板。这些函数还伴随着启动交互式小部件以创建这些调色板的功能</p>
<p><em>seaborn.light_palette（color，n_colors = 6，reverse = False，as_cmap = False，input =’rgb’ ）</em><br><em>seaborn.dark_palette（color，n_colors = 6，reverse = False，as_cmap = False，input =’rgb’ ）</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># color: 十六进制代码，html颜色名称或input空间中的元组</span></span><br><span class="line"><span class="comment"># input: &#123;'rgb'，'hls'，'husl'，xkcd'&#125;</span></span><br><span class="line"><span class="comment"># 用于解释输入颜色的颜色空间。前三个选项适用于元组输入，后者适用于字符串输入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sns.palplot(sns.light_palette(<span class="string">"green"</span>))<span class="comment"># 按照green做浅色调色盘</span></span><br><span class="line">sns.palplot(sns.dark_palette(<span class="string">'green'</span>, reverse=<span class="keyword">True</span>))<span class="comment"># 按照green做深色调色盘</span></span><br><span class="line"></span><br><span class="line">sns.palplot(sns.light_palette((<span class="number">260</span>, <span class="number">75</span>, <span class="number">60</span>), input=<span class="string">"husl"</span>))</span><br><span class="line">sns.palplot(sns.dark_palette(<span class="string">"muted purple"</span>, input=<span class="string">"xkcd"</span>))</span><br></pre></td></tr></table></figure>
<p><img src="output_29_0.png" alt="png"></p>
<p><img src="output_29_1.png" alt="png"></p>
<p><img src="output_29_2.png" alt="png"></p>
<p><img src="output_29_3.png" alt="png"></p>
<h2 id="发散的调色板"><a href="#发散的调色板" class="headerlink" title="发散的调色板"></a>发散的调色板</h2><p>第三类调色板称为“发散”。这些用于大低值和高值都很有趣的数据。数据中通常还有明确定义的中点。例如，如果要绘制某个基线时间点的温度变化，最好使用偏差色图来显示相对减少的区域和相对增加的区域。</p>
<p><strong>同样重要的是要强调使用红色和绿色应该避免，因为大量潜在的观众将无法区分它们</strong></p>
<p><em>seaborn.diverging_palette(h_neg, h_pos, s=75, l=50, sep=10, n=6,<br>center=’light’, as_cmap=False)</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建分散颜色</span></span><br><span class="line"><span class="comment"># h_neg, h_pos → 起始/终止颜色值</span></span><br><span class="line"><span class="comment"># s → 值区间0-100，饱和度</span></span><br><span class="line"><span class="comment"># l → 值区间0-100，亮度</span></span><br><span class="line"><span class="comment"># n → 颜色个数</span></span><br><span class="line"><span class="comment"># center → 中心颜色为浅色还是深色“light”，“dark”,默认为light</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Color Brewer库带有一组精心挑选的发散色图</span></span><br><span class="line">sns.palplot(sns.color_palette(<span class="string">"BrBG"</span>, <span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然可以自己定制</span></span><br><span class="line">sns.palplot(sns.diverging_palette(<span class="number">145</span>, <span class="number">280</span>, s=<span class="number">85</span>, l=<span class="number">25</span>, n=<span class="number">7</span>))</span><br></pre></td></tr></table></figure>
<p><img src="output_31_0.png" alt="png"></p>
<p><img src="output_31_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize = (<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line">x = np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">cmap = sns.diverging_palette(<span class="number">200</span>, <span class="number">20</span>, sep=<span class="number">16</span>, as_cmap=<span class="keyword">True</span>)</span><br><span class="line">sns.heatmap(x, cmap=cmap)</span><br></pre></td></tr></table></figure>
<p><img src="output_32_1.png" alt="png"></p>
<h2 id="选择调色板-choose-colorbrewer-palette"><a href="#选择调色板-choose-colorbrewer-palette" class="headerlink" title="选择调色板 choose_colorbrewer_palette()"></a>选择调色板 choose_colorbrewer_palette()</h2><p>您可以使用该<code>choose_colorbrewer_palette()</code>函数来播放各种颜色选项，如果希望返回值是可以传递给seaborn或matplotlib函数的colormap对象，则可以将as_cmap参数设置为True</p>
<p><em>seaborn.choose_colorbrewer_palette(data_type, as_cmap=False)</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.choose_colorbrewer_palette(<span class="string">'q'</span>)</span><br><span class="line"><span class="comment"># sequential：顺序，可以用 s 来代替</span></span><br><span class="line"><span class="comment"># diverging：发散, 可以用 d 来代替</span></span><br><span class="line"><span class="comment"># qualitative：分类, 可以用 q 来代替</span></span><br></pre></td></tr></table></figure>
<img src="/blogs/4f39f027/output_33_0.png" title="可通过调节按钮来寻找调色板">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Color Brewer的颜色图：</span></span><br><span class="line"><span class="comment"># Accent, Accent_r, Blues, Blues_r, BrBG, BrBG_r, BuGn, BuGn_r, BuPu,</span></span><br><span class="line"><span class="comment"># BuPu_r, CMRmap, CMRmap_r, Dark2, Dark2_r, GnBu, GnBu_r, Greens, Greens_r, Greys,</span></span><br><span class="line"><span class="comment">#Greys_r, OrRd, OrRd_r, Oranges, Oranges_r, PRGn, PRGn_r,</span></span><br><span class="line"><span class="comment"># Paired, Paired_r, Pastel1, Pastel1_r, Pastel2, Pastel2_r, PiYG, PiYG_r, PuBu, PuBuGn,</span></span><br><span class="line"><span class="comment">#PuBuGn_r, PuBu_r, PuOr, PuOr_r, PuRd, PuRd_r, Purples,</span></span><br><span class="line"><span class="comment"># Purples_r, RdBu, RdBu_r, RdGy, RdGy_r, RdPu, RdPu_r, RdYlBu, RdYlBu_r, RdYlGn, RdYlGn_r,</span></span><br><span class="line"><span class="comment"># Reds, Reds_r, Set1, Set1_r, Set2, Set2_r, Set3,</span></span><br><span class="line"><span class="comment"># Set3_r, Spectral, Spectral_r, Wistia, Wistia_r, YlGn, YlGnBu, YlGnBu_r, YlGn_r, YlOrBr,</span></span><br><span class="line"><span class="comment"># YlOrBr_r, YlOrRd, YlOrRd_r, afmhot, afmhot_r,</span></span><br><span class="line"><span class="comment"># autumn, autumn_r, binary, binary_r, bone, bone_r, brg, brg_r, bwr, bwr_r, cool, cool_r,</span></span><br><span class="line"><span class="comment"># coolwarm, coolwarm_r, copper, copper_r, cubehelix,</span></span><br><span class="line"><span class="comment"># cubehelix_r, flag, flag_r, gist_earth, gist_earth_r, gist_gray, gist_gray_r, gist_heat,</span></span><br><span class="line"><span class="comment"># gist_heat_r, gist_ncar, gist_ncar_r, gist_rainbow,</span></span><br><span class="line"><span class="comment"># gist_rainbow_r, gist_stern, gist_stern_r, gist_yarg, gist_yarg_r, gnuplot, gnuplot2,</span></span><br><span class="line"><span class="comment"># gnuplot2_r, gnuplot_r, gray, gray_r, hot, hot_r, hsv,</span></span><br><span class="line"><span class="comment"># hsv_r, icefire, icefire_r, inferno, inferno_r, jet, jet_r, magma, magma_r, mako,</span></span><br><span class="line"><span class="comment"># mako_r, nipy_spectral, nipy_spectral_r, ocean, ocean_r,</span></span><br><span class="line"><span class="comment"># pink, pink_r, plasma, plasma_r, prism, prism_r, rainbow, rainbow_r, rocket, rocket_r,</span></span><br><span class="line"><span class="comment"># seismic, seismic_r, spectral, spectral_r, spring,</span></span><br><span class="line"><span class="comment"># spring_r, summer, summer_r, terrain, terrain_r, viridis, viridis_r, vlag, vlag_r, winter, winter_r</span></span><br></pre></td></tr></table></figure>
<h1 id="设置默认的调色板"><a href="#设置默认的调色板" class="headerlink" title="设置默认的调色板"></a>设置默认的调色板</h1><p>类似于color_palette()。<code>set_palette()</code>接受相同的参数，但它会更改默认的matplotlib参数，以便将调色板<strong>应用于所有绘图。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置调色板后，绘图创建图表</span></span><br><span class="line"></span><br><span class="line">sns.set_style(<span class="string">"whitegrid"</span>)</span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置风格</span></span><br><span class="line"><span class="keyword">with</span> sns.color_palette(<span class="string">"PuBuGn_d"</span>):</span><br><span class="line">    plt.subplot(<span class="number">211</span>)</span><br><span class="line">    sinplot()</span><br><span class="line"></span><br><span class="line">sns.set_palette(<span class="string">"husl"</span>)</span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">sinplot()</span><br><span class="line"><span class="comment"># 绘制系列颜色</span></span><br></pre></td></tr></table></figure>
<p><img src="output_38_0.png" alt="png"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>可视化</tag>
        <tag>seaborn</tag>
      </tags>
  </entry>
  <entry>
    <title>Python利用openpyxl来操作Excel（一）</title>
    <url>/blogs/72901e2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><p>最近一直在做项目里的自动化的工作，为了是从繁琐重复的劳动中挣脱出来，把精力用在数据分析上。自动化方面python是在好不过了，不过既然要提交报表，<br>就不免要美观什么的。pandas虽然很强大，但是无法对Excel完全操作，现学vba有点来不及。于是就找到这个openpyxl包，用python来修改Excel，碍于水平<br>有限，琢磨了两天，踩了不少坑，好在完成了自动化工作（以后起码多出来几个小时，美滋滋）。</p>
<p>在这里写下这两天的笔记和踩得坑，方面新手躲坑，也供自己日后查阅。如有问题，还请见谅并指出，多谢。<br><a id="more"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl.styles <span class="keyword">import</span> colors, Font, Fill, NamedStyle</span><br><span class="line"><span class="keyword">from</span> openpyxl.styles <span class="keyword">import</span> PatternFill, Border, Side, Alignment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载文件</span></span><br><span class="line">wb = load_workbook(<span class="string">'./5a.xlsx'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>workbook： 工作簿，一个excel文件包含多个sheet。</li>
<li>worksheet：工作表，一个workbook有多个，表名识别，如“sheet1”,“sheet2”等。</li>
<li>cell： 单元格，存储数据对象</li>
</ul>
<p>文章所用表格为：<br><img src="/blogs/72901e2/1.png" title="所用表格"></p>
<h2 id="操作sheet"><a href="#操作sheet" class="headerlink" title="操作sheet"></a>操作sheet</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取sheetname</span></span><br><span class="line">print(<span class="string">'输出文件所有工作表名：\n'</span>, wb.sheetnames)</span><br><span class="line">ws = wb[<span class="string">'5a'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者不知道名字时</span></span><br><span class="line">sheet_names = wb.sheetnames</span><br><span class="line">ws2 = wb[sheet_names[<span class="number">0</span>]]    <span class="comment"># index为0为第一张表</span></span><br><span class="line">print(ws <span class="keyword">is</span> ws2)</span><br></pre></td></tr></table></figure>
<pre><code>输出文件所有工作表名：
 [&apos;5a&apos;]
True
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改sheetname</span></span><br><span class="line"></span><br><span class="line">ws.title = <span class="string">'5a_'</span></span><br><span class="line">print(<span class="string">'修改sheetname：\n'</span>, wb.sheetnames)</span><br></pre></td></tr></table></figure>
<pre><code>修改sheetname：
 [&apos;5a_&apos;]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新的sheet</span></span><br><span class="line"><span class="comment"># 创建的新表必须要赋值给一个对象，不然只有名字但是没有实际的新表</span></span><br><span class="line"></span><br><span class="line">ws4 = wb.create_sheet(index=<span class="number">0</span>, title=<span class="string">'newsheet'</span>)</span><br><span class="line"><span class="comment"># 什么参数都不写的话，默认插入到最后一个位置且名字为sheet,sheet1...按照顺序排列</span></span><br><span class="line"></span><br><span class="line">ws5 = wb.create_sheet()</span><br><span class="line">print(<span class="string">'创建新的sheet:\n'</span>, wb.sheetnames)</span><br></pre></td></tr></table></figure>
<pre><code>创建新的sheet:
 [&apos;newsheet&apos;, &apos;5a_&apos;, &apos;Sheet&apos;]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除sheet</span></span><br><span class="line">wb.remove(ws4)  <span class="comment"># 这里只能写worksheet对象，不能写sheetname</span></span><br><span class="line">print(<span class="string">'删除sheet：\n'</span>, wb.sheetnames)</span><br></pre></td></tr></table></figure>
<pre><code>删除sheet：
 [&apos;5a_&apos;, &apos;Sheet&apos;]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改sheet选项卡背景色，默认为白色，设置为RRGGBB模式</span></span><br><span class="line">ws.sheet_properties.tabColor = <span class="string">"FFA500"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取有效区域</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'最大列数为：'</span>, ws.max_column)</span><br><span class="line">print(<span class="string">'最大行数为：'</span>, ws.max_row)</span><br></pre></td></tr></table></figure>
<pre><code>最大列数为： 5
最大行数为： 17
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插入行和列</span></span><br><span class="line">ws.insert_rows(<span class="number">1</span>)  <span class="comment"># 在第一行插入一行</span></span><br><span class="line">ws.insert_cols(<span class="number">2</span>, <span class="number">4</span>)  <span class="comment"># 从第二列开始插入四列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除行和列</span></span><br><span class="line">ws.delete_cols(<span class="number">6</span>, <span class="number">3</span>)  <span class="comment"># 从第六列（F列）开始，删除3列即（F:H）</span></span><br><span class="line">ws.delete_rows(<span class="number">3</span>)   <span class="comment"># 删除第三行</span></span><br></pre></td></tr></table></figure>
<h2 id="单元格操作"><a href="#单元格操作" class="headerlink" title="单元格操作"></a>单元格操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取</span></span><br><span class="line">c = ws[<span class="string">'A1'</span>]</span><br><span class="line">c1 = ws.cell(row=<span class="number">1</span>, column=<span class="number">2</span>)</span><br><span class="line">print(c, c1)</span><br><span class="line">print(c.value, c1.value)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;Cell &apos;5a_&apos;.A1&gt; &lt;Cell &apos;5a_&apos;.B1&gt;
dth_title Province
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改</span></span><br><span class="line">ws[<span class="string">'A1'</span>] = <span class="string">'景区名称'</span></span><br><span class="line">ws.cell(<span class="number">1</span>, <span class="number">2</span>).value = <span class="string">'省份'</span></span><br><span class="line">print(c.value, c1.value)</span><br></pre></td></tr></table></figure>
<pre><code>景区名称 省份
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取多个单元格</span></span><br><span class="line"></span><br><span class="line">cell_range = ws[<span class="string">'A1'</span>:<span class="string">'D5'</span>]</span><br><span class="line">colC = ws[<span class="string">'C'</span>]</span><br><span class="line">col_range = ws[<span class="string">'C:D'</span>]</span><br><span class="line">row10 = ws[<span class="number">10</span>]</span><br><span class="line">row_range = ws[<span class="number">5</span>:<span class="number">10</span>]</span><br><span class="line"><span class="comment"># 其返回的结果都是一个包含单元格的元组</span></span><br><span class="line">print(type(cell_range))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> row10:</span><br><span class="line">    print(i)    <span class="comment"># row10只有有效单元格</span></span><br></pre></td></tr></table></figure>
<pre><code>&lt;class &apos;tuple&apos;&gt;
&lt;Cell &apos;5a_&apos;.A10&gt;
&lt;Cell &apos;5a_&apos;.B10&gt;
&lt;Cell &apos;5a_&apos;.C10&gt;
&lt;Cell &apos;5a_&apos;.D10&gt;
&lt;Cell &apos;5a_&apos;.E10&gt;
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照行列操作</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ws.iter_rows(min_row=<span class="number">1</span>, max_row=<span class="number">3</span>,</span><br><span class="line">                        min_col=<span class="number">1</span>, max_col=<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> row:</span><br><span class="line">        print(cell)</span><br><span class="line"><span class="comment"># 也可以用worksheet.iter_col(),用法都一样</span></span><br></pre></td></tr></table></figure>
<pre><code>&lt;Cell &apos;5a_&apos;.A1&gt;
&lt;Cell &apos;5a_&apos;.B1&gt;
&lt;Cell &apos;5a_&apos;.A2&gt;
&lt;Cell &apos;5a_&apos;.B2&gt;
&lt;Cell &apos;5a_&apos;.A3&gt;
&lt;Cell &apos;5a_&apos;.B3&gt;
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 合并单元格</span></span><br><span class="line">ws.merge_cells(<span class="string">'F1:G1'</span>)</span><br><span class="line">ws[<span class="string">'F1'</span>] = <span class="string">'合并两个单元格'</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">ws.merge_cells(start_row=<span class="number">2</span>, start_column=<span class="number">6</span>, end_row=<span class="number">3</span>, end_column=<span class="number">8</span>)</span><br><span class="line">ws.cell(<span class="number">2</span>, <span class="number">6</span>).value = <span class="string">'合并三个单元格'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消合并单元格</span></span><br><span class="line">ws.unmerge_cells(<span class="string">'F1:G1'</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">ws.unmerge_cells(start_row=<span class="number">2</span>, start_column=<span class="number">6</span>, end_row=<span class="number">3</span>, end_column=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">'./5a.xlsx'</span>)</span><br><span class="line"><span class="comment"># 保存之前的操作,保存文件时，文件必须是关闭的！！！</span></span><br></pre></td></tr></table></figure>
<p><strong>注意！！！</strong>，openpyxl对Excel的修改并不像是xlwings一样是实时的，他的修改是<code>暂时保存在内存中</code>的，所以当<br>后面的修改例如我接下来要在第一行插入新的一行做标题，那么当我对新的A1单元格操作的时候，还在内存中的原A1(现在是A2)的单元格<br>原有的修改就会被覆盖。所以要先保存，或者从一开始就计划好更改操作避免这样的事情发生。（别问我怎么知道的，都是泪o(╥﹏╥)o）</p>
<h2 id="样式修改"><a href="#样式修改" class="headerlink" title="样式修改"></a>样式修改</h2><h3 id="单个单元格样式"><a href="#单个单元格样式" class="headerlink" title="单个单元格样式"></a>单个单元格样式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wb = load_workbook(<span class="string">'./5a.xlsx'</span>)    <span class="comment"># 读取修改后的文件</span></span><br><span class="line">ws = wb[<span class="string">'5a_'</span>]</span><br><span class="line"><span class="comment"># 我们来设置一个表头</span></span><br><span class="line">ws.insert_rows(<span class="number">1</span>)    <span class="comment"># 在第一行插入新的一行</span></span><br><span class="line">ws.merge_cells(<span class="string">'A1:E1'</span>)  <span class="comment"># 合并单元格</span></span><br><span class="line">a1 = ws[<span class="string">'A1'</span>]</span><br><span class="line">ws[<span class="string">'A1'</span>] = <span class="string">'5A级风景区名单'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置字体</span></span><br><span class="line">ft = Font(name=<span class="string">'微软雅黑'</span>, color=<span class="string">'000000'</span>, size=<span class="number">15</span>, b=<span class="keyword">True</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">name:字体名称</span></span><br><span class="line"><span class="string">color:颜色通常是RGB或aRGB十六进制值</span></span><br><span class="line"><span class="string">b(bold):加粗（bool）</span></span><br><span class="line"><span class="string">i(italic):倾斜(bool)</span></span><br><span class="line"><span class="string">shadow：阴影（bool）</span></span><br><span class="line"><span class="string">underline：下划线（‘doubleAccounting’, ‘single’, ‘double’, ‘singleAccounting’）</span></span><br><span class="line"><span class="string">charset:字符集(int)</span></span><br><span class="line"><span class="string">strike:删除线(bool)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">a1.font = ft</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置文本对齐</span></span><br><span class="line"></span><br><span class="line">ali = Alignment(horizontal=<span class="string">'center'</span>, vertical=<span class="string">'center'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">horizontal:水平对齐('centerContinuous', 'general', 'distributed',</span></span><br><span class="line"><span class="string">                    'left', 'fill', 'center', 'justify', 'right')</span></span><br><span class="line"><span class="string">vertical:垂直对齐（'distributed', 'top', 'center', 'justify', 'bottom'）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">a1.alignment = ali</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图案填充</span></span><br><span class="line"></span><br><span class="line">fill = PatternFill(<span class="string">'solid'</span>, fgColor=<span class="string">'FFA500'</span>)</span><br><span class="line"><span class="comment"># 颜色一般使用十六进制RGB</span></span><br><span class="line"><span class="comment"># 'solid'是图案填充类型，详细可查阅文档</span></span><br><span class="line"></span><br><span class="line">a1.fill = fill</span><br></pre></td></tr></table></figure>
<p><a href="https://openpyxl.readthedocs.io/en/stable/api/openpyxl.styles.fills.html" target="_blank" rel="noopener">openpyxl.styles.fills模块参数文档</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置边框</span></span><br><span class="line">bian = Side(style=<span class="string">'medium'</span>, color=<span class="string">'000000'</span>)    <span class="comment"># 设置边框样式</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">style:边框线的风格&#123;'dotted','slantDashDot','dashDot','hair','mediumDashDot',</span></span><br><span class="line"><span class="string">        'dashed','mediumDashed','thick','dashDotDot','medium',</span></span><br><span class="line"><span class="string">        'double','thin','mediumDashDotDot'&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">border = Border(top=bian, bottom=bian, left=bian, right=bian)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">top（上）,bottom（下）,left（左）,right（右）:必须是 Side类型</span></span><br><span class="line"><span class="string">diagonal: 斜线 side类型 </span></span><br><span class="line"><span class="string">diagonalDownd: 右斜线 bool</span></span><br><span class="line"><span class="string">diagonalDown: 左斜线 bool</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a1.border = border</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> ws[<span class="string">'A1:E1'</span>][<span class="number">0</span>]:   <span class="comment"># 去元组中的每一个cell更改样式</span></span><br><span class="line">    item.border = border</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">'./5a.xlsx'</span>)  <span class="comment"># 保存更改</span></span><br></pre></td></tr></table></figure>
<p><strong>再次注意！！！：</strong></p>
<ul>
<li>不能使用 <code>a1.border = border</code>，否则只会如下图情况，<code>B1：E1</code>单元格<strong>没有线</strong>。我个人认为是因为线框涉及到相邻单元格边框的改动所以需要单独对每个单元格修改才行。</li>
<li>不能使用<code>ws[&#39;A1:E1&#39;].border = border</code>,由前面的内容可知，openpyxl的多个单元格其实是一个元组，而元组是没有style的方法的,所以必须一个一个改！！其实官方有其他办法，后面讲。</li>
</ul>
<img src="/blogs/72901e2/3.png" title="只有A1边框有加粗">
<h3 id="按列或行设置样式"><a href="#按列或行设置样式" class="headerlink" title="按列或行设置样式"></a>按列或行设置样式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 现在我们对整个表进行设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line">wb = load_workbook(<span class="string">'./5a.xlsx'</span>)</span><br><span class="line">ws = wb[<span class="string">'5a_'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据表格范围</span></span><br><span class="line">rows = ws.max_row</span><br><span class="line">cols = ws.max_column</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字体</span></span><br><span class="line">font1 = Font(name=<span class="string">'微软雅黑'</span>, size=<span class="number">11</span>, b=<span class="keyword">True</span>)</span><br><span class="line">font2 = Font(name=<span class="string">'微软雅黑'</span>, size=<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 边框</span></span><br><span class="line">line_t = Side(style=<span class="string">'thin'</span>, color=<span class="string">'000000'</span>)  <span class="comment"># 细边框</span></span><br><span class="line">line_m = Side(style=<span class="string">'medium'</span>, color=<span class="string">'000000'</span>)  <span class="comment"># 粗边框</span></span><br><span class="line">border1 = Border(top=line_m, bottom=line_t, left=line_t, right=line_t)</span><br><span class="line"><span class="comment"># 与标题相邻的边设置与标题一样</span></span><br><span class="line">border2 = Border(top=line_t, bottom=line_t, left=line_t, right=line_t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充</span></span><br><span class="line">fill = PatternFill(<span class="string">'solid'</span>, fgColor=<span class="string">'CFCFCF'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对齐</span></span><br><span class="line">alignment = Alignment(horizontal=<span class="string">'center'</span>, vertical=<span class="string">'center'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将样式打包命名</span></span><br><span class="line">sty1 = NamedStyle(name=<span class="string">'sty1'</span>, font=font1, fill=fill,</span><br><span class="line">                  border=border1, alignment=alignment)</span><br><span class="line">sty2 = NamedStyle(name=<span class="string">'sty2'</span>, font=font2, border=border2, alignment=alignment)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">2</span>, rows+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">1</span>, cols):</span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">2</span>:</span><br><span class="line">            ws.cell(r, c).style = sty1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ws.cell(r, c).style = sty2</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">'./5a.xlsx'</span>)</span><br></pre></td></tr></table></figure>
<img src="/blogs/72901e2/5.png" title="最终效果">
<p>对于，设置标题样式，其实官方也给出了一个<a href="https://openpyxl.readthedocs.io/en/stable/styles.html#styling-merged-cells" target="_blank" rel="noopener">自定义函数</a>,设定范围后，范围内的单元格都会合并，并且应用样式，就像是单个cell一样。在这里就不多赘述了，有兴趣的可以看看。很实用。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>自动化</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>python时间序列基础（一）</title>
    <url>/blogs/3ccb9cc8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><h1 id="Pyhton——时间模块详解"><a href="#Pyhton——时间模块详解" class="headerlink" title="Pyhton——时间模块详解"></a>Pyhton——时间模块详解</h1><blockquote>
<p>Python中提供了多个用于对日期和时间进行操作的内置模块：time模块、datetime模块和calendar模块。其中time模块是通过调用C库实现的，所以有些方法在某些平台上可能无法调用，但是其提供的大部分接口与C标准库time.h基本一致。time模块相比，datetime模块提供的接口更直观、易用，功能也更加强大。<br><a id="more"></a><br>我们先看关于表示时间的几种方法</p>
</blockquote>
<ul>
<li><strong><em>UTC time</em></strong>  世界协调时，又称格林尼治时间，世界标准时。与UTC对应各个时区的localtime,北京东八区比UTC早8小时，所以用UTC+8表示</li>
<li><strong><em>epoch time</em></strong>  表示时间开始的起点；它是一个特定的时间，不同平台上这个时间点的值不太相同，对于Unix而言，epoch time为 1970-01-01 00:00:00 UTC</li>
<li><strong><em>timestamp(时间戳)</em></strong>   也称为Unix时间 或 POSIX时间；它是一种时间表示方式，表示从格林尼治时间1970年1月1日0时0分0秒开始到现在所经过的毫秒数，其值为float类型。 但是有些编程语言的相关方法返回的是秒数（Python就是这样），这个需要看方法的文档说明。需要说明的是时间戳是个差值，其值与时区无关。</li>
<li><strong><em>元组（struct_time）</em></strong>  struct_time元组共有9个元素，返回struct_time的函数主要有gmtime()，localtime()，strptime()。</li>
</ul>
<h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><p>下面我们通过几个常用的实例详细介绍struct_time 中的属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#  time.localtime()  :将一个时间戳转换为当前时区的struct_time</span></span><br><span class="line"></span><br><span class="line">time.localtime()</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以从结果中看到里面有9个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tm_wday=2    代表周二</span></span><br><span class="line"><span class="comment"># tm_yday=73   代表一年中的第73天</span></span><br><span class="line"><span class="comment"># tm_isdst=0     代表是否是夏令时，可取0,1，-1    取不同值可能会影响性能</span></span><br></pre></td></tr></table></figure>
<pre><code>time.struct_time(tm_year=2018, tm_mon=3, tm_mday=14, tm_hour=0, tm_min=24,
                 tm_sec=59, tm_wday=2, tm_yday=73, tm_isdst=0)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = time.time()     <span class="comment">#返回当前时间的时间戳</span></span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'-------'</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)    <span class="comment">#线程推迟指定的时间运行，单位为秒。</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'hello,一秒后输出'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>1520959413.8214176
-------
hello,一秒后输出
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = time.gmtime()<span class="comment">#将一个时间戳转换为UTC时区（0时区）的struct_time。</span></span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'------------'</span>)</span><br><span class="line"></span><br><span class="line">t1 = time.mktime(time.localtime())   <span class="comment">#将一个struct_time 转化为时间戳</span></span><br><span class="line">print(t1)</span><br></pre></td></tr></table></figure>
<pre><code>time.struct_time(tm_year=2018, tm_mon=3, tm_mday=13, tm_hour=16, tm_min=43,
                 tm_sec=19, tm_wday=1, tm_yday=72, tm_isdst=0)
------------
1520959399.0
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = time.asctime()</span><br><span class="line">print(t)</span><br><span class="line"><span class="comment">#  把一个表示时间的元组或者struct_time表示为这种形式：</span></span><br><span class="line"><span class="comment">#  'Sun Jun 20 23:21:05 1993'。如果没有参数，将会将time.localtime()作为参数传入。</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'----------'</span>)</span><br><span class="line"></span><br><span class="line">t1 = time.ctime()</span><br><span class="line">print(t1)</span><br><span class="line"><span class="comment">#把一个时间戳（按秒计算的浮点数）转化为time.asctime()的形式。</span></span><br><span class="line"><span class="comment">#如果参数未给或者为None的时候，将会默认time.time()为参数。它的作用相当于time.asctime(time.localtime(secs))。</span></span><br></pre></td></tr></table></figure>
<pre><code>Wed Mar 14 00:44:22 2018
----------
Wed Mar 14 00:44:22 2018
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(time.strftime(<span class="string">'%Y-%m-%d'</span>,time.localtime()))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">返回字符串表示的当地时间。 </span></span><br><span class="line"><span class="string">把一个代表时间的元组或者struct_time（如由time.localtime()和time.gmtime()返回）转化为格式化的时间字符串，</span></span><br><span class="line"><span class="string">格式由参数format决定。如果未指定，将传入time.localtime()。如果元组中任何一个元素越界，就会抛出ValueError的异常。</span></span><br><span class="line"><span class="string">函数返回的是一个可读表示的本地时间的字符串。 </span></span><br><span class="line"><span class="string">参数：</span></span><br><span class="line"><span class="string">format：格式化字符串</span></span><br><span class="line"><span class="string">t ：可选的参数是一个struct_time对象</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<pre><code>2018-03-14
</code></pre><table>
<thead>
<tr>
<th style="text-align:center">格式化字符</th>
<th style="text-align:center">字符含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%a</td>
<td style="text-align:center">本地（locale）简化星期名称</td>
</tr>
<tr>
<td style="text-align:center">%A</td>
<td style="text-align:center">本地完整星期名称</td>
</tr>
<tr>
<td style="text-align:center">%b</td>
<td style="text-align:center">本地简化月份名称</td>
</tr>
<tr>
<td style="text-align:center">%B</td>
<td style="text-align:center">本地完整月份名称</td>
</tr>
<tr>
<td style="text-align:center">%c</td>
<td style="text-align:center">本地相应的日期和时间表示</td>
</tr>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">一个月中的第几天（01 - 31）</td>
</tr>
<tr>
<td style="text-align:center">%H</td>
<td style="text-align:center">一天中的第几个小时（24小时制，00 - 23）</td>
</tr>
<tr>
<td style="text-align:center">%I</td>
<td style="text-align:center">第几个小时（12小时制，01 - 12）</td>
</tr>
<tr>
<td style="text-align:center">%j</td>
<td style="text-align:center">一年中的第几天（001 - 366）</td>
</tr>
<tr>
<td style="text-align:center">%m</td>
<td style="text-align:center">月份（01 - 12）</td>
</tr>
<tr>
<td style="text-align:center">%M</td>
<td style="text-align:center">分钟数（00 - 59）</td>
</tr>
<tr>
<td style="text-align:center">%p</td>
<td style="text-align:center">本地am或者pm的相应符(“%p”只有与“%I”配合使用才有效果)</td>
</tr>
<tr>
<td style="text-align:center">%S</td>
<td style="text-align:center">秒（01 - 61）(文档中强调确实是0 - 61，而不是59，闰年秒占两秒)</td>
</tr>
<tr>
<td style="text-align:center">%U</td>
<td style="text-align:center">一年中的星期数。（00 - 53星期天是一个星期的开始。）第一个星期天之前的所有天数都放在第0周。</td>
</tr>
<tr>
<td style="text-align:center">%w</td>
<td style="text-align:center">一个星期中的第几天（0 - 6，0是星期天）</td>
</tr>
<tr>
<td style="text-align:center">%W</td>
<td style="text-align:center">和%U基本相同，不同的是%W以星期一为一个星期的开始。</td>
</tr>
<tr>
<td style="text-align:center">%x</td>
<td style="text-align:center">本地相应日期</td>
</tr>
<tr>
<td style="text-align:center">%X</td>
<td style="text-align:center">本地相应时间</td>
</tr>
<tr>
<td style="text-align:center">%y</td>
<td style="text-align:center">去掉世纪的年份（00 - 99）</td>
</tr>
<tr>
<td style="text-align:center">%Y</td>
<td style="text-align:center">完整的年份</td>
</tr>
<tr>
<td style="text-align:center">%Z</td>
<td style="text-align:center">时区的名字（如果不存在为空字符）</td>
</tr>
<tr>
<td style="text-align:center">%%</td>
<td style="text-align:center">‘%’字符</td>
</tr>
</tbody>
</table>
<p><strong>当使用strptime()函数时，只有当在这年中的周数和天数被确定的时候%U和%W才会被计算</strong></p>
<p>综上，time模块总共有三种时间表达方式：</p>
<ul>
<li>timestamp 时间戳</li>
<li>tuple 或者 struct_time</li>
<li>格式化字符串</li>
</ul>
<p>更多相关请查阅 time模块官方文档</p>
<h2 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a>datetime模块</h2><p>datetime是基于time模块封装的，是date和time模块的合集，但是执行效率略低。datetime有两个常量，MAXYEAR和MINYEAR，分别是9999和1。<br>datetime里有四个重要的类：</p>
<ul>
<li>date ：表示日期，年月日</li>
<li>datetime ：表示日期时间，年月日时分秒</li>
<li>time ：表示时间，时分秒</li>
<li>timedelta ：表示时间间隔</li>
</ul>
<h3 id="datetime的date类"><a href="#datetime的date类" class="headerlink" title="datetime的date类"></a>datetime的date类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># datetime.date（year,month,day）:   返回 year-month-day</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># import datetime  </span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"></span><br><span class="line">today = datetime.date.today()      <span class="comment"># datetime.date.today 返回今日</span></span><br><span class="line">print(today,type(today))</span><br><span class="line"><span class="comment"># 输出格式为  date 类</span></span><br><span class="line"></span><br><span class="line">print(str(today),type(str(today)))</span><br><span class="line"></span><br><span class="line">t = datetime.date(<span class="number">2016</span>,<span class="number">1</span>,<span class="number">22</span>)</span><br><span class="line">print(t)</span><br><span class="line"><span class="comment"># (年，月，日) → 直接得到当时日期</span></span><br></pre></td></tr></table></figure>
<pre><code>2018-03-14 &lt;class &apos;datetime.date&apos;&gt;
2018-03-14 &lt;class &apos;str&apos;&gt;
2016-01-22
</code></pre><h3 id="datetime的time类"><a href="#datetime的time类" class="headerlink" title="datetime的time类"></a>datetime的time类</h3><p><strong>time</strong>类由<strong>hour</strong>小时、<strong>minute</strong>分钟、<strong>second</strong>秒、<strong>microsecond</strong>毫秒和<strong>tzinfo</strong>五部分组成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># datetime.time</span></span><br><span class="line"></span><br><span class="line">t1 =datetime.time(<span class="number">2</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">9</span>)</span><br><span class="line">print(t1,type(t1))</span><br><span class="line"></span><br><span class="line">t2 = t1.strftime(<span class="string">'%H:%M:%S'</span>)</span><br><span class="line">print(t2,type(t2))     </span><br><span class="line"><span class="comment"># 把一个datetime.time 类 转化为 str</span></span><br></pre></td></tr></table></figure>
<pre><code>02:22:33.000009 &lt;class &apos;datetime.time&apos;&gt;
02:22:33 &lt;class &apos;str&apos;&gt;
</code></pre><h3 id="datetime的datetime类"><a href="#datetime的datetime类" class="headerlink" title="datetime的datetime类"></a>datetime的datetime类</h3><p>datetime类其实是可以看做是date类和time类的合体，其大部分的方法和属性都继承于这二个类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  datetime.datetime:   datetime对象</span></span><br><span class="line"></span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line">print(now,type(now))</span><br><span class="line"><span class="comment">#输出datetime类</span></span><br><span class="line"></span><br><span class="line">t1 = datetime.datetime(<span class="number">2016</span>,<span class="number">6</span>,<span class="number">1</span>)</span><br><span class="line">t2 = datetime.datetime(<span class="number">2014</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">44</span>,<span class="number">33</span>)</span><br><span class="line">print(t1)</span><br><span class="line">print(t2)</span><br><span class="line"><span class="comment"># (年，月，日，时，分，秒)，至少输入年月日</span></span><br><span class="line"></span><br><span class="line">t2 - t1</span><br><span class="line"><span class="comment"># 相减得到时间差 —— timedelta</span></span><br></pre></td></tr></table></figure>
<pre><code>2018-03-14 22:53:11.224884 &lt;class &apos;datetime.datetime&apos;&gt;
2016-06-01 00:00:00
2014-01-01 12:44:33

datetime.timedelta(-882, 45873)
</code></pre><h3 id="时间差-timedelta"><a href="#时间差-timedelta" class="headerlink" title="时间差 timedelta"></a>时间差 timedelta</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># datetime.timedelta   时间差</span></span><br><span class="line"></span><br><span class="line">today = datetime.datetime.today()</span><br><span class="line">yestoday = today + datetime.timedelta(<span class="number">-1</span>)   <span class="comment">#  -1  代表前一天</span></span><br><span class="line">print(today)</span><br><span class="line">print(yestoday)</span><br><span class="line">print(today - datetime.timedelta(<span class="number">7</span>))</span><br><span class="line"><span class="comment"># 时间差主要用作时间的加减法，相当于可被识别的时间“差值”</span></span><br></pre></td></tr></table></figure>
<pre><code>2018-03-13 21:35:31.238277
2018-03-12 21:35:31.238277
2018-03-06 21:35:31.238277
</code></pre><h2 id="日期字符转换-parser-parse"><a href="#日期字符转换-parser-parse" class="headerlink" title="日期字符转换 parser.parse"></a>日期字符转换 parser.parse</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  parser.parse:日期字符转换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dateutil.parser <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">date = <span class="string">'12-23-2018'</span></span><br><span class="line">date1 = <span class="string">'13/3/2018'</span></span><br><span class="line">print(parse(date),type(parse(date)))</span><br><span class="line">print(parse(date1))</span><br><span class="line"><span class="comment"># 直接将几乎任何类似时间格式的str转化成datetime.datetime</span></span><br><span class="line"></span><br><span class="line">print(parse(<span class="string">'2000-1-1'</span>),<span class="string">'\n'</span>,</span><br><span class="line">     parse(<span class="string">'5/1/2014'</span>),<span class="string">'\n'</span>,</span><br><span class="line">     parse(<span class="string">'5/1/2014'</span>, dayfirst = <span class="keyword">True</span>),<span class="string">'\n'</span>,  <span class="comment"># 国际通用格式中，日在月之前，可以通过dayfirst来设置</span></span><br><span class="line">     parse(<span class="string">'22/1/2014'</span>),<span class="string">'\n'</span>,</span><br><span class="line">     parse(<span class="string">'Jan 31, 1997 10:45 PM'</span>))</span><br><span class="line"><span class="comment"># 各种格式可以解析，但无法支持中文</span></span><br></pre></td></tr></table></figure>
<pre><code>2018-12-23 00:00:00 &lt;class &apos;datetime.datetime&apos;&gt;
2018-03-13 00:00:00
2000-01-01 00:00:00
2014-05-01 00:00:00
2014-01-05 00:00:00
2014-01-22 00:00:00
1997-01-31 22:45:00
</code></pre>]]></content>
      <categories>
        <category>python</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>时间序列</tag>
      </tags>
  </entry>
  <entry>
    <title>统计分析——描述统计之数据水平描述</title>
    <url>/blogs/cf1bfbe2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><p>一组样本数据的数值特征一般来说可以从三个方面来描述：</p>
<ol>
<li><p><strong>数据的水平</strong>（也可以称之为集中趋势或位置度量），反映数据的<strong>数值大小</strong></p>
</li>
<li><p><strong>数据的差异</strong>，反映数据间的<strong>离散程度</strong></p>
</li>
<li><p><strong>数据的分布形状</strong>，反映数据分布的<strong>偏度</strong>和<strong>峰度</strong></p>
<a id="more"></a>
<h2 id="描述水平的统计量"><a href="#描述水平的统计量" class="headerlink" title="描述水平的统计量"></a>描述水平的统计量</h2></li>
</ol>
<p><strong>数据水平是指数值大小</strong>，描述数据水平的统计量有<code>平均数</code>，<code>分位数</code>，<code>众数</code>,同时这几个统计量也可以用来描述数据的<strong>集中趋势度</strong>。</p>
<h3 id="平均数"><a href="#平均数" class="headerlink" title="平均数"></a>平均数</h3><p><strong>简单平均数（simple mean）</strong>的公式：</p>
<p>$$\bar{x} = \frac{x_{1}+x_{2}+x_{3}+…+x_{n}}{n} = \frac{\sum_{i=1}^{n}x_{i}}{n}$$</p>
<p><strong><a href="https://en.wikipedia.org/wiki/Weighted_arithmetic_mean" target="_blank" rel="noopener">加权平均数（weighted mean）</a></strong>：如果样本被分为K组，每组的组中值（组上限与下限的平均数）为m1,m2,..,mk表示各组的频数用f1,f2,…,fk表示，则样本平均数的计算公式为：<br>$$ \bar{x} = \frac{m_{1}f_{1}+m_{2}f_{2}+m_{3}f_{3}+…+m_{k}f_{k}}{f_{1}+f_{2}+f_{3}+…+f_{k}} = \frac{\sum_{i=1}^{k}m_{i}f_{i}}{\sum_{i=1}^{k}f_{i}}$$</p>
<p>一般来说，总体的平均数是无从得知的，因为无法得到总体是数据，所以我们常常从样本的平均数来推测总体的平均数。</p>
<h4 id="R方法"><a href="#R方法" class="headerlink" title="R方法"></a>R方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 R中求简单平均数</span></span><br><span class="line">load(<span class="string">".\\tongjixue\\example\\ch3\\example3_1.RData"</span>)    <span class="comment">#  30名学生的成绩</span></span><br><span class="line">head(example3_1,<span class="number">5</span>)   <span class="comment"># 展示前5名学生的成绩</span></span><br><span class="line">mean(example3_1$分数)  <span class="comment"># 求分数的平均值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mean(x, trim = 0, na.rm = FALSE, ...)</span></span><br><span class="line"><span class="comment">#  x - 向量</span></span><br><span class="line"><span class="comment">#  trim - 取值在0~0.5之间，例如trim=0.1,表示计算之前先排序，然后去掉前10%和后10%的数据，最后计算剩余数据的平均值</span></span><br><span class="line"><span class="comment">#  na.rm - 默认为FALSE，当为TRUE时，表示去掉数据中的缺失值。（当数据中有缺失值时无法计算）</span></span><br></pre></td></tr></table></figure>
<table> <thead><tr><th scope="col">分数</th></tr></thead> <tbody> <tr><td>85</td></tr> <tr><td>55</td></tr> <tr><td>91</td></tr> <tr><td>66</td></tr> <tr><td>79</td></tr> </tbody> </table>

<pre><code>80
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 R中求加权平均数</span></span><br><span class="line">load(<span class="string">".\\tongjixue\\example\\ch3\\example3_2.RData"</span>) </span><br><span class="line">example3_2</span><br><span class="line"></span><br><span class="line">weighted.mean(example3_2$组中值, example3_2$人数)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># weighted.mean(x, w,...,na.rm=FALSE)</span></span><br><span class="line"><span class="comment">#  x - 计算加权平均数的对象，对应公式中的 f</span></span><br><span class="line"><span class="comment">#  w - 相应的权数向量，相当于公式中的 m</span></span><br></pre></td></tr></table></figure>
<table> <thead><tr><th scope="col">分组</th><th scope="col">组中值</th><th scope="col">人数</th></tr></thead> <tbody> <tr><td>60以下</td><td>55    </td><td> 3    </td></tr> <tr><td>60—70 </td><td>65    </td><td> 4    </td></tr> <tr><td>70—80 </td><td>75    </td><td> 4    </td></tr> <tr><td>80—90 </td><td>85    </td><td>10    </td></tr> <tr><td>90—100</td><td>95    </td><td> 9    </td></tr> </tbody> </table>

<pre><code>81
</code></pre><h4 id="python方法"><a href="#python方法" class="headerlink" title="python方法"></a>python方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span>    <span class="comment"># jupyter结果多行显示</span></span><br><span class="line"></span><br><span class="line">data_1 = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])   <span class="comment"># 矩阵</span></span><br><span class="line">data_2 = pd.DataFrame(data_1)  <span class="comment"># 数据框</span></span><br><span class="line">data_2</span><br></pre></td></tr></table></figure>
<div> <style scoped> .dataframe tbody tr th:only-of-type { vertical-align: middle; }  .dataframe tbody tr th { vertical-align: top; }  .dataframe thead th { text-align: right; } </style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>0</th> <th>1</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>1</td> <td>2</td> </tr> <tr> <th>1</th> <td>3</td> <td>4</td> </tr> </tbody> </table> </div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 python中求简单平均数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用数据框自带的方法</span></span><br><span class="line">data_2.mean()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># data.mean(axis=None, skipna=True)</span></span><br><span class="line"><span class="comment">#  axis - 默认为axis=None,即输出每列的平均值</span></span><br><span class="line"><span class="comment">#  skipna：布尔值，默认为True,计算结果时排除NA / null值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 numpy的函数</span></span><br><span class="line">np.mean(data_1,axis=(<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># np.mean(data, axis=None)</span></span><br><span class="line"><span class="comment">#  axis - 默认为axis=None,如果为元组，则计算多轴上的平均值。例如（0,1）计算行和列的所有数据的平均值。</span></span><br></pre></td></tr></table></figure>
<pre><code>0    2.0
1    3.0
dtype: float64

2.5
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line">data_2 = pd.read_csv(<span class="string">'.\\tongjixue\\example\\ch3\\example3_2.csv'</span>,engine=<span class="string">'python'</span>)</span><br><span class="line">data_2</span><br></pre></td></tr></table></figure>
<div> <style scoped> .dataframe tbody tr th:only-of-type { vertical-align: middle; }  .dataframe tbody tr th { vertical-align: top; }  .dataframe thead th { text-align: right; } </style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>分组</th> <th>组中值</th> <th>人数</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>60以下</td> <td>55</td> <td>3</td> </tr> <tr> <th>1</th> <td>60—70</td> <td>65</td> <td>4</td> </tr> <tr> <th>2</th> <td>70—80</td> <td>75</td> <td>4</td> </tr> <tr> <th>3</th> <td>80—90</td> <td>85</td> <td>10</td> </tr> <tr> <th>4</th> <td>90—100</td> <td>95</td> <td>9</td> </tr> </tbody> </table> </div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在python中求 加权平均数</span></span><br><span class="line"></span><br><span class="line">np.average(data_2[<span class="string">'组中值'</span>],weights=data_2[<span class="string">'人数'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy.average(a, axis=None, weights=None,...)</span></span><br><span class="line"><span class="comment">#   a - array_like,计算加权平均数的对象，对应公式中的 f</span></span><br><span class="line"><span class="comment">#   weights - array_like,相应的权数向量，相当于公式中的 m</span></span><br><span class="line"><span class="comment">#   axis - 默认为axis=None,如果为元组，则计算多轴上的平均值。</span></span><br></pre></td></tr></table></figure>
<pre><code>81.0
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = np.arange(<span class="number">6</span>).reshape((<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">data</span><br><span class="line"></span><br><span class="line">np.average(data,axis=<span class="number">1</span>, weights=[<span class="number">1.</span>/<span class="number">4</span>, <span class="number">3.</span>/<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1],
       [2, 3],
       [4, 5]])

array([0.75, 2.75, 4.75])
</code></pre><p>因为加权平均数是使用组中值来代表该组数据的，所以同一组数据，简单平均和加权平均结果不同，除非每组数据在组中值两侧成对称分布，故除非数据本来就是分组情况，一般都用简单平均求平均值。</p>
<h3 id="分位数"><a href="#分位数" class="headerlink" title="分位数"></a>分位数</h3><p>分位数代表数据水平的高低，常用的分位数有<code>四分位数</code>，<code>中位数</code>，<code>百分位数</code></p>
<p><strong>中位数</strong></p>
<p>中位数是一组数据排序后位于中间位置的数值，用Me表示</p>
<p><img src="https://raw.githubusercontent.com/GengDaPeng/GengDaPeng.github.io/hexo/source/_posts/2018-11-26-%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E6%8F%8F%E8%BF%B0%E7%BB%9F%E8%AE%A1%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B0%B4%E5%B9%B3%E6%8F%8F%E8%BF%B0/math-20181126.png" width="300" height="100"></p>
<p>中位数的特点是<strong>不受极端值的影响</strong></p>
<p><strong>四分位数</strong></p>
<p>同中位数,将数据排序后位于1/4和3/4位置的数据。</p>
<p><strong>百分位数</strong></p>
<p>同四分位数，利用99个数据点将数据分为100份，百分位数提供了数据在最大值和最小值期间数据点分布信息。</p>
<h4 id="R方法-1"><a href="#R方法-1" class="headerlink" title="R方法"></a>R方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用之前example3.1的学生成绩数据</span></span><br><span class="line"><span class="comment"># 中位数</span></span><br><span class="line">median(example3_1$分数)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 四分位数</span></span><br><span class="line">quantile(example3_1$分数,probs = c(<span class="number">0.25</span>,<span class="number">0.75</span>))</span><br><span class="line"><span class="comment"># R总计算分位数有9种方法，默认type=7。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#百分位数</span></span><br><span class="line">quantile(example3_1$分数,probs=c(<span class="number">0.1</span>,<span class="number">0.2</span>,<span class="number">0.3</span>,<span class="number">0.4</span>,<span class="number">0.5</span>,<span class="number">0.6</span>,<span class="number">0.7</span>,<span class="number">0.8</span>,<span class="number">0.9</span>))</span><br></pre></td></tr></table></figure>
<pre><code>85

25%     75%
70.5    90

10%     20%     30%     40%     50%     60%     70%     80%     90%
60.4    66.8    74.1    81.6    85      86      89.3    91      92.3
</code></pre><h4 id="python方法-1"><a href="#python方法-1" class="headerlink" title="python方法"></a>python方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_3 = pd.read_csv(<span class="string">'.\\tongjixue\\example\\ch3\\example3_1.csv'</span>,engine=<span class="string">'python'</span>)</span><br><span class="line"></span><br><span class="line">np.percentile(data_3.分数,(<span class="number">25</span>,<span class="number">50</span>,<span class="number">75</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([70.5, 85. , 90. ])
</code></pre><p>求分位数在统计雪上有多种方法，当分位点位于两个数值中间时有不同的取值的方法，这个以后详细讨论。</p>
<h3 id="众数"><a href="#众数" class="headerlink" title="众数"></a>众数</h3><p>一组数据众数数显频数最多的数值，用$M_{0}$表示，众数在数据量比较大时才有意义，众数可能不存在，也可能有2个或者多个。</p>
<p>R中没有直接求出众数的内置函数，所以需要自己写自定义众数函数</p>
<h4 id="R方法-2"><a href="#R方法-2" class="headerlink" title="R方法"></a>R方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义函数</span></span><br><span class="line">getmode &lt;- function(x)&#123;</span><br><span class="line">    y &lt;- sort(unique(x))    <span class="comment"># 去重数值并排序</span></span><br><span class="line">    tab &lt;- tabulate(match(x,y))  <span class="comment"># 比较x与y中的数值，并列出他们在y中的位置，在计算每个位置的频数放入对象tab中</span></span><br><span class="line">    y[tab==max(tab)]   <span class="comment"># 找出y中频数最多的元素</span></span><br><span class="line">&#125;</span><br><span class="line">getmode(example3_1$分数)</span><br></pre></td></tr></table></figure>
<pre><code>86
</code></pre><h4 id="python方法-2"><a href="#python方法-2" class="headerlink" title="python方法"></a>python方法</h4><p>在numpy或者pandas是没有求众数的方法的，但是我们可以利用scipy科学计算库中的mode函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> mode</span><br><span class="line">m0 = mode(data_3[<span class="string">'分数'</span>])[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">print(m0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者利用numpy中的bincount()函数，此函数将数据按直方图统计</span></span><br><span class="line">count = np.bincount(data_3[<span class="string">'分数'</span>])</span><br><span class="line">m0_1 = np.argmax(count)</span><br><span class="line">print(m0_1)</span><br></pre></td></tr></table></figure>
<pre><code>86
86
</code></pre>]]></content>
      <categories>
        <category>统计学习</category>
      </categories>
      <tags>
        <tag>统计学习</tag>
        <tag>特征分析</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言数据处理——缺失值的识别与处理</title>
    <url>/blogs/90825c4b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><p>我们一般拿到的数据并不是完美标准的，并不能马上就能分析使用。常常我们需要对数据做处理，往往这也是最耗时的部分，而这其中缺失值的处理是非常重要的。</p>
<p>缺失值并非都是可以一概删除的无意义的记录。比如周二汽车行驶记录的缺失表明当天车主没有开车，如果长期周二不开车就可以推测车的车牌号是2或者7，因为周二限号嘛。再比如在学生卡的使用记录中，食堂用餐记录的大量缺失有可能是此同学经济条件较好，经常在食堂外用餐。但是天气的缺失纪录难以运用在天气的情况的统计中。<br>以上种种，可以发现我们要<strong>结合实际分析场景，分析的目的来判断缺失值对于分析是否有意义</strong>。<br><a id="more"></a></p>
<h2 id="缺失值的识别"><a href="#缺失值的识别" class="headerlink" title="缺失值的识别"></a>缺失值的识别</h2><p>统计学家通常将缺失数据分为三类。它们都用概率术语进行描述，但思想都非常直观。我们用睡眠研究中对做梦时长的测量（有12个动物有缺失值）来依次阐述三种类型。</p>
<ul>
<li><p>(1) <strong>完全随机缺失</strong>：若某变量的缺失数据与其他任何观测或未观测变量都不相关，则数据为完全随机缺失（MCAR）。若12个动物的做梦时长值缺失不是由于系统原因，那么可认为数据是MCAR。注意，如果每个有缺失值的变量都是MCAR，那么可以将数据完整的实例看做是对更大数据集的一个简单随机抽样。</p>
</li>
<li><p>(2) <strong>随机缺失</strong>： 若某变量上的缺失数据与其他观测变量相关，与它自己的未观测值不相关，则数据为随机缺失（MAR）。例如，体重较小的动物更可能有做梦时长的缺失值（可能因为较小的动物较难观察），“缺失”与动物的做梦时长无关，那么该数据就可以认为是MAR。此时，一旦你控制了体重变量，做梦时长数据的缺失与出现将是随机的。</p>
</li>
<li><p>(3) <strong>非随机缺失</strong>：若缺失数据不属于MCAR或MAR，则数据为非随机缺失（NMAR）。例如，做梦时长越短的动物也更可能有做梦数据的缺失（可能由于难以测量时长较短的事件），那么数据可认为是NMAR。</p>
</li>
</ul>
<p>大部分处理缺失数据的方法都假定数据是MCAR或MAR。此时，你可以忽略缺失数据的生成机制，并且（在替换或删除缺失数据后）可以直接对感兴趣的关系进行建模。当数据是NMAR时，想对它进行恰当地分析比较困难，你既要对感兴趣的关系进行建模，还要对缺失值的生成机制进行建模。（目前分析NMAR数据的方法有模型选择法和模式混合法</p>
<p>在R中，缺失值以符号<code>NA</code>（Not Available，不可用）表示。不可能出现的值（例如，被0除的结果）通过符号 <code>NaN</code>（Not a Number，非数值）来表示<br>is.na()可以检测缺失值，将返回一个与元对象相同形状的布尔对象。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a &lt;- c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">NA</span>,<span class="number">6</span>)</span><br><span class="line">is.na(a)</span><br><span class="line">a[<span class="number">5</span>] == <span class="number">5</span></span><br><span class="line">a[<span class="number">6</span>] == <span class="literal">NA</span>   <span class="comment"># 在R中，缺失值是无法被比较的，所以逻辑运算符无法使用。</span></span><br><span class="line">a[<span class="number">1</span>] + a[<span class="number">6</span>]   <span class="comment"># 运算符也无法使用，必须要先删除缺失值才能计算。</span></span><br><span class="line">mean(a,na.rm = <span class="literal">TRUE</span>)  <span class="comment">#对a 求平均数，必须先去除缺失值。</span></span><br></pre></td></tr></table></figure>
<ol class="list-inline"> <li>FALSE</li> <li>FALSE</li> <li>FALSE</li> <li>FALSE</li> <li>FALSE</li> <li>TRUE</li> <li>FALSE</li> </ol>

<p>TRUE</p>
<p>&lt;NA&gt;</p>
<p>&lt;NA&gt;</p>
<p>3.5</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载VIM包自带的sleep睡眠数据集</span></span><br><span class="line">data(sleep, package=<span class="string">'VIM'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出没有缺失值的行</span></span><br><span class="line">sleep[complete.cases(sleep),][<span class="number">1</span>:<span class="number">3</span>,]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出缺失值所在的行</span></span><br><span class="line">sleep[!complete.cases(sleep),][<span class="number">1</span>:<span class="number">3</span>,]</span><br></pre></td></tr></table></figure>
<table> <thead><tr><th></th><th scope="col">BodyWgt</th><th scope="col">BrainWgt</th><th scope="col">NonD</th><th scope="col">Dream</th><th scope="col">Sleep</th><th scope="col">Span</th><th scope="col">Gest</th><th scope="col">Pred</th><th scope="col">Exp</th><th scope="col">Danger</th></tr></thead> <tbody> <tr><th scope="row">2</th><td>   1.0</td><td>   6.6</td><td>6.3   </td><td>2.0   </td><td>8.3   </td><td> 4.5  </td><td> 42   </td><td>3     </td><td>1     </td><td>3     </td></tr> <tr><th scope="row">5</th><td>2547.0</td><td>4603.0</td><td>2.1   </td><td>1.8   </td><td>3.9   </td><td>69.0  </td><td>624   </td><td>3     </td><td>5     </td><td>4     </td></tr> <tr><th scope="row">6</th><td>  10.6</td><td> 179.5</td><td>9.1   </td><td>0.7   </td><td>9.8   </td><td>27.0  </td><td>180   </td><td>4     </td><td>4     </td><td>4     </td></tr> </tbody> </table>  <table> <thead><tr><th></th><th scope="col">BodyWgt</th><th scope="col">BrainWgt</th><th scope="col">NonD</th><th scope="col">Dream</th><th scope="col">Sleep</th><th scope="col">Span</th><th scope="col">Gest</th><th scope="col">Pred</th><th scope="col">Exp</th><th scope="col">Danger</th></tr></thead> <tbody> <tr><th scope="row">1</th><td>6654.00</td><td>5712.0 </td><td>NA     </td><td>NA     </td><td> 3.3   </td><td>38.6   </td><td>645    </td><td>3      </td><td>5      </td><td>3      </td></tr> <tr><th scope="row">3</th><td>   3.38</td><td>  44.5 </td><td>NA     </td><td>NA     </td><td>12.5   </td><td>14.0   </td><td> 60    </td><td>1      </td><td>1      </td><td>1      </td></tr> <tr><th scope="row">4</th><td>   0.92</td><td>   5.7 </td><td>NA     </td><td>NA     </td><td>16.5   </td><td>  NA   </td><td> 25    </td><td>5      </td><td>2      </td><td>3      </td></tr> </tbody> </table>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sum(is.na(sleep$Dream))    <span class="comment"># 该字段中总共有12个缺失值</span></span><br><span class="line"></span><br><span class="line">mean(is.na(sleep$Dream))    <span class="comment"># 19%的实例在此变量上有缺失值</span></span><br><span class="line"></span><br><span class="line">mean(!complete.cases(sleep))  <span class="comment"># 数据集中32%的实例包含一个或多个缺失值</span></span><br></pre></td></tr></table></figure>
<p>12</p>
<p>0.193548387096774</p>
<p>0.32258064516129</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mice包中的 md.pattern()函数可生成一个以矩阵或数据框形式展示缺失值模式的表格</span></span><br><span class="line"><span class="keyword">library</span>(<span class="string">"mice"</span>)</span><br><span class="line">md.pattern(sleep)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一行表述了“无缺失值”的模式（所有元素都为1）。第二行表述了“除了Span之外无缺失值”的模式。</span></span><br><span class="line"><span class="comment"># 第一列表示各缺失值模式的实例个数，最后一列表示各模式中有缺失值的变量的个数</span></span><br><span class="line"><span class="comment"># 最后一行给出每个变量的缺失值的个数</span></span><br></pre></td></tr></table></figure>
<table> <thead><tr><th></th><th scope="col">BodyWgt</th><th scope="col">BrainWgt</th><th scope="col">Pred</th><th scope="col">Exp</th><th scope="col">Danger</th><th scope="col">Sleep</th><th scope="col">Span</th><th scope="col">Gest</th><th scope="col">Dream</th><th scope="col">NonD</th><th scope="col"></th></tr></thead> <tbody> <tr><th scope="row">42</th><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td> 1</td><td> 1</td><td> 0</td></tr> <tr><th scope="row">9</th><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td> 0</td><td> 0</td><td> 2</td></tr> <tr><th scope="row">3</th><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>0 </td><td> 1</td><td> 1</td><td> 1</td></tr> <tr><th scope="row">2</th><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>0 </td><td>1 </td><td> 1</td><td> 1</td><td> 1</td></tr> <tr><th scope="row">1</th><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>0 </td><td>1 </td><td> 0</td><td> 0</td><td> 3</td></tr> <tr><th scope="row">1</th><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>0 </td><td>0 </td><td> 1</td><td> 1</td><td> 2</td></tr> <tr><th scope="row">2</th><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>0 </td><td>1 </td><td>1 </td><td> 1</td><td> 0</td><td> 2</td></tr> <tr><th scope="row">2</th><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>1 </td><td>0 </td><td>1 </td><td>1 </td><td> 0</td><td> 0</td><td> 3</td></tr> <tr><th scope="row"></th><td>0 </td><td>0 </td><td>0 </td><td>0 </td><td>0 </td><td>4 </td><td>4 </td><td>4 </td><td>12</td><td>14</td><td>38</td></tr> </tbody> </table>

<img src="/blogs/90825c4b/output_7_1.png" title="图1">
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span>(<span class="string">"VIM"</span>)</span><br><span class="line">aggr(sleep, prop=<span class="literal">FALSE</span>, numbers=<span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<img src="/blogs/90825c4b/output_8_0.png" title="图2">
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># matrixplot()函数可生成展示每个实例数据的图形。</span></span><br><span class="line"><span class="comment"># 此处，数值型数据被重新转换到[0, 1]区间，并用灰度来表示大小：浅色表示值小，深色表示值大。默认缺失值为红色。</span></span><br><span class="line"></span><br><span class="line">matrixplot(sleep)</span><br></pre></td></tr></table></figure>
<img src="/blogs/90825c4b/output_9_0.png" title="图3">
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># marginplot()函数可生成一幅散点图，在图形边界展示两个变量的缺失值信息</span></span><br><span class="line"><span class="comment"># 可以看到，做梦时长有4个缺失值，妊娠时长有12个缺失值，两个变量同时确实的实例个数为0（蓝色数字）</span></span><br><span class="line"></span><br><span class="line">marginplot(sleep[c(<span class="string">"Gest"</span>,<span class="string">"Dream"</span>)], pch=c(<span class="number">20</span>),</span><br><span class="line">           col=c(<span class="string">"darkgray"</span>, <span class="string">"red"</span>, <span class="string">"blue"</span>))</span><br></pre></td></tr></table></figure>
<img src="/blogs/90825c4b/output_10_0.png" title="图4">
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 探索缺失值之间的相关性</span></span><br><span class="line"></span><br><span class="line">x &lt;- as.data.frame(abs(is.na(sleep)))   <span class="comment"># 缺失值为1， 其他为0</span></span><br><span class="line">head(x, n=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">y &lt;- x[which(apply(x,<span class="number">2</span>,sum)&gt;<span class="number">0</span>)] <span class="comment"># 按照列求和大于0的列 赋值给 y</span></span><br><span class="line">cor(y)  <span class="comment"># y 的相关性</span></span><br><span class="line"><span class="comment"># 可以看到dream做梦时长和NonD（不做梦时长）有着强相关，两个变量常常同时缺失</span></span><br></pre></td></tr></table></figure>
<table> <thead><tr><th scope="col">BodyWgt</th><th scope="col">BrainWgt</th><th scope="col">NonD</th><th scope="col">Dream</th><th scope="col">Sleep</th><th scope="col">Span</th><th scope="col">Gest</th><th scope="col">Pred</th><th scope="col">Exp</th><th scope="col">Danger</th></tr></thead> <tbody> <tr><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr> <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr> <tr><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr> <tr><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr> <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr> </tbody> </table>  <table> <thead><tr><th></th><th scope="col">NonD</th><th scope="col">Dream</th><th scope="col">Sleep</th><th scope="col">Span</th><th scope="col">Gest</th></tr></thead> <tbody> <tr><th scope="row">NonD</th><td> 1.0000</td><td> 0.9071</td><td> 0.486 </td><td> 0.0152</td><td>-0.142 </td></tr> <tr><th scope="row">Dream</th><td> 0.9071</td><td> 1.0000</td><td> 0.204 </td><td> 0.0375</td><td>-0.129 </td></tr> <tr><th scope="row">Sleep</th><td> 0.4863</td><td> 0.2037</td><td> 1.000 </td><td>-0.0690</td><td>-0.069 </td></tr> <tr><th scope="row">Span</th><td> 0.0152</td><td> 0.0375</td><td>-0.069 </td><td> 1.0000</td><td> 0.198 </td></tr> <tr><th scope="row">Gest</th><td>-0.1418</td><td>-0.1287</td><td>-0.069 </td><td> 0.1983</td><td> 1.000 </td></tr> </tbody> </table>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 含缺失值变量与其他可观测变量间的关系</span></span><br><span class="line">cor(sleep, y, use=<span class="string">"pairwise.complete.obs"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这个相关系数矩阵中，行为可观测变量，列为表示缺失的指示变量。你可以忽略矩阵中的警告信息和NA值</span></span><br><span class="line"><span class="comment"># 从相关系数矩阵的第一列可以看到，体重越大（r = 0.227）、妊娠期越长（r =0.202）、睡眠暴露度越大（r = 0.245）的动物无梦睡眠的评分更可能缺失</span></span><br></pre></td></tr></table></figure>
<pre><code>Warning message in cor(sleep, y, use = &quot;pairwise.complete.obs&quot;):
&quot;标准差为零&quot;
</code></pre><table> <thead><tr><th></th><th scope="col">NonD</th><th scope="col">Dream</th><th scope="col">Sleep</th><th scope="col">Span</th><th scope="col">Gest</th></tr></thead> <tbody> <tr><th scope="row">BodyWgt</th><td> 0.2268 </td><td> 0.2226 </td><td> 0.00168</td><td>-0.0583 </td><td>-0.0540 </td></tr> <tr><th scope="row">BrainWgt</th><td> 0.1795 </td><td> 0.1632 </td><td> 0.00786</td><td>-0.0792 </td><td>-0.0733 </td></tr> <tr><th scope="row">NonD</th><td>     NA </td><td>     NA </td><td>      NA</td><td>-0.0431 </td><td>-0.0455 </td></tr> <tr><th scope="row">Dream</th><td>-0.1890 </td><td>     NA </td><td>-0.18895</td><td> 0.1170 </td><td> 0.2277 </td></tr> <tr><th scope="row">Sleep</th><td>-0.0802 </td><td>-0.0802 </td><td>      NA</td><td> 0.0964 </td><td> 0.0398 </td></tr> <tr><th scope="row">Span</th><td> 0.0834 </td><td> 0.0598 </td><td> 0.00524</td><td>     NA </td><td>-0.0653 </td></tr> <tr><th scope="row">Gest</th><td> 0.2024 </td><td> 0.0514 </td><td> 0.15970</td><td>-0.1750 </td><td>     NA </td></tr> <tr><th scope="row">Pred</th><td> 0.0476 </td><td>-0.0683 </td><td> 0.20246</td><td> 0.0231 </td><td>-0.2010 </td></tr> <tr><th scope="row">Exp</th><td> 0.2455 </td><td> 0.1274 </td><td> 0.26077</td><td>-0.1929 </td><td>-0.1929 </td></tr> <tr><th scope="row">Danger</th><td> 0.0653 </td><td>-0.0672 </td><td> 0.20888</td><td>-0.0667 </td><td>-0.2044 </td></tr> </tbody> </table>

<p>注意，表中的相关系数并不特别大，表明数据是MCAR的可能性比较小，更可能为MAR<br>不过也绝不能排除数据是NMAR的可能性，因为你并不知道缺失数据背后对应的真实数据是怎么样的。比如，你不可能知道哺乳动物做梦时长与该变量数据缺失概率间的关系。当缺乏强力的外部证据时，我们通常假设数据是MCAR或者MAR</p>
<h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><p>对于缺失值的处理我们常常根据数据的实际场景采用以下几种方法：</p>
<ol>
<li>删除</li>
<li>插补法（用中值或均值插值，或者利用回归或者随机森林预测值插值）</li>
<li>作为特征保留</li>
</ol>
<h3 id="删除法"><a href="#删除法" class="headerlink" title="删除法"></a>删除法</h3><h4 id="行删除法"><a href="#行删除法" class="headerlink" title="行删除法"></a>行删除法</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 行删除</span></span><br><span class="line">newdata &lt;- sleep[complete.cases(sleep),]   <span class="comment"># 将没有缺失值的行储存为新数据</span></span><br><span class="line"></span><br><span class="line">newdata &lt;- na.omit(sleep)  <span class="comment"># 或者直接使用 na.omit 函数获得，两者结果一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># options()允许用户设置和检查影响 R计算和显示结果的方式的各种全局选项</span></span><br><span class="line">options(digits=<span class="number">1</span>)   <span class="comment"># 设置打印的有效数字为1</span></span><br><span class="line">cor(na.omit(sleep))</span><br></pre></td></tr></table></figure>
<table> <thead><tr><th></th><th scope="col">BodyWgt</th><th scope="col">BrainWgt</th><th scope="col">NonD</th><th scope="col">Dream</th><th scope="col">Sleep</th><th scope="col">Span</th><th scope="col">Gest</th><th scope="col">Pred</th><th scope="col">Exp</th><th scope="col">Danger</th></tr></thead> <tbody> <tr><th scope="row">BodyWgt</th><td> 1.00</td><td> 0.96</td><td>-0.4 </td><td>-0.07</td><td>-0.3 </td><td> 0.47</td><td> 0.71</td><td> 0.10</td><td> 0.4 </td><td> 0.26</td></tr> <tr><th scope="row">BrainWgt</th><td> 0.96</td><td> 1.00</td><td>-0.4 </td><td>-0.07</td><td>-0.3 </td><td> 0.63</td><td> 0.73</td><td>-0.02</td><td> 0.3 </td><td> 0.15</td></tr> <tr><th scope="row">NonD</th><td>-0.39</td><td>-0.39</td><td> 1.0 </td><td> 0.52</td><td> 1.0 </td><td>-0.37</td><td>-0.61</td><td>-0.35</td><td>-0.6 </td><td>-0.53</td></tr> <tr><th scope="row">Dream</th><td>-0.07</td><td>-0.07</td><td> 0.5 </td><td> 1.00</td><td> 0.7 </td><td>-0.27</td><td>-0.41</td><td>-0.40</td><td>-0.5 </td><td>-0.57</td></tr> <tr><th scope="row">Sleep</th><td>-0.34</td><td>-0.34</td><td> 1.0 </td><td> 0.72</td><td> 1.0 </td><td>-0.38</td><td>-0.61</td><td>-0.40</td><td>-0.6 </td><td>-0.60</td></tr> <tr><th scope="row">Span</th><td> 0.47</td><td> 0.63</td><td>-0.4 </td><td>-0.27</td><td>-0.4 </td><td> 1.00</td><td> 0.65</td><td>-0.17</td><td> 0.3 </td><td> 0.01</td></tr> <tr><th scope="row">Gest</th><td> 0.71</td><td> 0.73</td><td>-0.6 </td><td>-0.41</td><td>-0.6 </td><td> 0.65</td><td> 1.00</td><td> 0.09</td><td> 0.6 </td><td> 0.31</td></tr> <tr><th scope="row">Pred</th><td> 0.10</td><td>-0.02</td><td>-0.4 </td><td>-0.40</td><td>-0.4 </td><td>-0.17</td><td> 0.09</td><td> 1.00</td><td> 0.6 </td><td> 0.93</td></tr> <tr><th scope="row">Exp</th><td> 0.41</td><td> 0.32</td><td>-0.6 </td><td>-0.50</td><td>-0.6 </td><td> 0.32</td><td> 0.57</td><td> 0.63</td><td> 1.0 </td><td> 0.79</td></tr> <tr><th scope="row">Danger</th><td> 0.26</td><td> 0.15</td><td>-0.5 </td><td>-0.57</td><td>-0.6 </td><td> 0.01</td><td> 0.31</td><td> 0.93</td><td> 0.8 </td><td> 1.00</td></tr> </tbody> </table>

<p>表中的相关系数仅通过所有变量均为完整数据的42个动物计算得来。（注意代码<code>cor(sleep,use=&quot;complete.obs&quot;)</code>可生成同样的结果。）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 研究寿命和妊娠期对睡眠中做梦时长的影响，可应用行删除法的线性回归</span></span><br><span class="line">fit &lt;- lm(Dream ~ Span + Gest, data=na.omit(sleep))</span><br><span class="line">summary(fit)</span><br></pre></td></tr></table></figure>
<pre><code>Call:
lm(formula = Dream ~ Span + Gest, data = na.omit(sleep))

Residuals:
   Min     1Q Median     3Q    Max
-2.333 -0.915 -0.221  0.382  4.183

Coefficients:
             Estimate Std. Error t value Pr(&gt;|t|)
(Intercept)  2.480122   0.298476    8.31  3.7e-10 ***
Span        -0.000472   0.013130   -0.04    0.971
Gest        -0.004394   0.002081   -2.11    0.041 *  
---
Signif. codes:  0 &apos;***&apos; 0.001 &apos;**&apos; 0.01 &apos;*&apos; 0.05 &apos;.&apos; 0.1 &apos; &apos; 1

Residual standard error: 1 on 39 degrees of freedom
Multiple R-squared:  0.167, Adjusted R-squared:  0.125
F-statistic: 3.92 on 2 and 39 DF,  p-value: 0.0282
</code></pre><p>此处可以看到，动物妊娠期越短，做梦时长越长（控制寿命不变）；而控制妊娠期不变时，寿命与做梦时长不相关</p>
<h4 id="插补法"><a href="#插补法" class="headerlink" title="插补法"></a>插补法</h4><p>首先是<strong>简单插补法</strong>，就是利用特定值来插补，比如平均值，中位数，众数等。这种方法简单粗暴。只适合某些简单的场景中。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用中位数，平均数做简单插补</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">library</span>(Hmisc)     <span class="comment"># 导入Hmisc包</span></span><br><span class="line">newdata_2 &lt;- sleep</span><br><span class="line">newdata_2$Dream &lt;- impute(newdata_2$Dream, mean)    <span class="comment"># 利用平均值插补，适用于正态分布</span></span><br><span class="line">newdata_2$Span &lt;- impute(newdata_2$Span, median)    <span class="comment"># 利用中位数插补，适用于偏态不严重时</span></span><br><span class="line">newdata_2$Gest &lt;- impute(newdata_2$Gest, <span class="string">"radom"</span>)   <span class="comment"># 随机数插补</span></span><br><span class="line">head(newdata_2,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<table> <thead><tr><th scope="col">BodyWgt</th><th scope="col">BrainWgt</th><th scope="col">NonD</th><th scope="col">Dream</th><th scope="col">Sleep</th><th scope="col">Span</th><th scope="col">Gest</th><th scope="col">Pred</th><th scope="col">Exp</th><th scope="col">Danger</th></tr></thead> <tbody> <tr><td>7e+03</td><td>5712 </td><td>NA   </td><td>2.0  </td><td> 3   </td><td>39   </td><td>645  </td><td>3    </td><td>5    </td><td>3    </td></tr> <tr><td>1e+00</td><td>   7 </td><td> 6   </td><td>2.0  </td><td> 8   </td><td> 4   </td><td>42   </td><td>3    </td><td>1    </td><td>3    </td></tr> <tr><td>3e+00</td><td>  44 </td><td>NA   </td><td>2.0  </td><td>12   </td><td>14   </td><td>60   </td><td>1    </td><td>1    </td><td>1    </td></tr> <tr><td>9e-01</td><td>   6 </td><td>NA   </td><td>2.0  </td><td>16   </td><td>15   </td><td>25   </td><td>5    </td><td>2    </td><td>3    </td></tr> <tr><td>3e+03</td><td>4603 </td><td> 2   </td><td>1.8  </td><td> 4   </td><td>69   </td><td>624  </td><td>3    </td><td>5    </td><td>4    </td></tr> <tr><td>1e+01</td><td> 180 </td><td> 9   </td><td>0.7  </td><td>10   </td><td>27   </td><td>180  </td><td>4    </td><td>4    </td><td>4    </td></tr> </tbody> </table>

<p>然后是<strong>多重插补法</strong>， 多重插补（MI）是一种基于重复模拟的处理缺失值的方法。在面对复杂的缺失值问题时，MI是最常选用的方法。<br>它利用蒙特卡洛方法来填补缺失值从而生成一组完整的数据集（通常是3到10个）。此时，标准的统计方法便可应用到每个模拟的数据集上，通过组合输出结果给出估计的结果  </p>
<p><img src="https://raw.githubusercontent.com/GengDaPeng/code-learning/master/R/RiA2-master/%E5%8E%9F%E4%B9%A6%E5%BD%A9%E5%9B%BE/%E5%88%A9%E7%94%A8mice%E5%8C%85%E5%A4%9A%E9%87%8D%E6%8F%92%E8%A1%A5%E6%B3%95%E5%8E%9F%E7%90%86.png" style="width:550px;height:250px;float:" alt="利用mice包多重插补法原理">  </p>
<p>第一步，<strong>mice()</strong>函数首先从一个包含缺失数据的数据框开始，然后返回一个包含多个（默认为5个）完整数据集的对象。每个完整数据集都是通过对原始数据框中的缺失数据进行插补而生成的。 由于插补有随机的成分，因此每个完整数据集都略有不同。<br>第二步，<strong>with()</strong>函数可依次对每个完整数据集应用统计模型（如线性模型 lm() 或广义线性模型 glm()）。<br>第三步，<strong>pool()</strong>函数将这些单独的分析结果整合为一组结果。最终模型的标准误和p值都将准确地反映出由于缺失值和多重插补而产生的不确定性。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多重插补法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # options()允许用户设置和检查影响 R计算和显示结果的方式的各种全局选项</span></span><br><span class="line">options(digits=<span class="number">3</span>)   <span class="comment"># 设置打印的有效数字为3</span></span><br><span class="line"><span class="keyword">library</span>(mice)     <span class="comment"># 加载 mice包</span></span><br><span class="line">data(sleep, package=<span class="string">"VIM"</span>)  <span class="comment"># 加载数据</span></span><br><span class="line">imp &lt;- mice(sleep, seed=<span class="number">1234</span>)</span><br><span class="line">fit &lt;- with(imp, lm(Dream ~ Span + Gest))   <span class="comment"># 利用线性回归，Dream为因变量，Span和Gest是自变量 用+号隔开</span></span><br><span class="line">pooled &lt;- pool(fit)    <span class="comment"># pooled：一个包含m个统计分析平均结果的列表对象。</span></span><br><span class="line">summary(pooled)</span><br></pre></td></tr></table></figure>
<pre><code>iter imp variable
 1   1  NonD  Dream  Sleep  Span  Gest
 1   2  NonD  Dream  Sleep  Span  Gest
 1   3  NonD  Dream  Sleep  Span  Gest
 1   4  NonD  Dream  Sleep  Span  Gest
 1   5  NonD  Dream  Sleep  Span  Gest
 2   1  NonD  Dream  Sleep  Span  Gest
 2   2  NonD  Dream  Sleep  Span  Gest
 2   3  NonD  Dream  Sleep  Span  Gest
 2   4  NonD  Dream  Sleep  Span  Gest
 2   5  NonD  Dream  Sleep  Span  Gest
 3   1  NonD  Dream  Sleep  Span  Gest
 3   2  NonD  Dream  Sleep  Span  Gest
 3   3  NonD  Dream  Sleep  Span  Gest
 3   4  NonD  Dream  Sleep  Span  Gest
 3   5  NonD  Dream  Sleep  Span  Gest
 4   1  NonD  Dream  Sleep  Span  Gest
 4   2  NonD  Dream  Sleep  Span  Gest
 4   3  NonD  Dream  Sleep  Span  Gest
 4   4  NonD  Dream  Sleep  Span  Gest
 4   5  NonD  Dream  Sleep  Span  Gest
 5   1  NonD  Dream  Sleep  Span  Gest
 5   2  NonD  Dream  Sleep  Span  Gest
 5   3  NonD  Dream  Sleep  Span  Gest
 5   4  NonD  Dream  Sleep  Span  Gest
 5   5  NonD  Dream  Sleep  Span  Gest
</code></pre><table> <thead><tr><th></th><th scope="col">estimate</th><th scope="col">std.error</th><th scope="col">statistic</th><th scope="col">df</th><th scope="col">p.value</th></tr></thead> <tbody> <tr><th scope="row">(Intercept)</th><td> 2.62893</td><td>0.26086 </td><td>10.078  </td><td>53.3    </td><td>3.80e-14</td></tr> <tr><th scope="row">Span</th><td>-0.00335</td><td>0.01233 </td><td>-0.272  </td><td>55.5    </td><td>7.87e-01</td></tr> <tr><th scope="row">Gest</th><td>-0.00425</td><td>0.00154 </td><td>-2.755  </td><td>54.4    </td><td>7.92e-03</td></tr> </tbody> </table>

<p>你可以看到Span的回归系数不显著（p ≈ 0.08 ）， Gest的系数在 p &lt; 0.01的水平下很显著。若将这些结果与利用行删除法所得的结果对比，你会发现背离的结论相同。当控制寿命不变时，妊娠期与做梦时长有一个（统计）显著的、负相关的关系。行删除法基于42个有完整数据的动物，而此处的分析法基于整个数据集中全部62个动物的数据</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 imp汇总信息</span></span><br><span class="line">imp</span><br></pre></td></tr></table></figure>
<pre><code>Class: mids
Number of multiple imputations:  5 
Imputation methods:
 BodyWgt BrainWgt     NonD    Dream    Sleep     Span     Gest     Pred 
      &quot;&quot;       &quot;&quot;    &quot;pmm&quot;    &quot;pmm&quot;    &quot;pmm&quot;    &quot;pmm&quot;    &quot;pmm&quot;       &quot;&quot; 
     Exp   Danger 
      &quot;&quot;       &quot;&quot; 
PredictorMatrix:
         BodyWgt BrainWgt NonD Dream Sleep Span Gest Pred Exp Danger
BodyWgt        0        1    1     1     1    1    1    1   1      1
BrainWgt       1        0    1     1     1    1    1    1   1      1
NonD           1        1    0     1     1    1    1    1   1      1
Dream          1        1    1     0     1    1    1    1   1      1
Sleep          1        1    1     1     0    1    1    1   1      1
Span           1        1    1     1     1    0    1    1   1      1
Number of logged events:  5 
  it im  dep meth   out
1  1  2 Span  pmm Sleep
2  2  5 Span  pmm Sleep
3  2  5 Gest  pmm Sleep
4  5  5 Span  pmm Sleep
5  5  5 Gest  pmm Sleep
</code></pre><ul>
<li><p>Number of multiple imputations：表示多重插补的数量，5次；</p>
</li>
<li><p>Missing cells per column ： 表示每列变量缺失值包含的数量，如NonD包含14个缺失值；</p>
</li>
<li><p>Imputation methods ： 可以看出对于有缺失值的变量采用了pmm（预测均值）的方法来插补。BodyWgt、BrainWgt、Pred、Exp、Danger没有进行插补，因为这些变量没有缺失数据；</p>
</li>
<li><p>VisitSequence(如果有的话) ： 从左至右展示了插补的变量，这里进行插补的分别是sleep数据集中的第3到7列变量；</p>
</li>
<li><p>PredictorMatrix ： 是预测变量矩阵，行代表插补变量，列代表为插补提供信息的变量，1和0表示使用和未使用。NonD到Gest这5行有缺失值，所以只有这5行进行了插补，每个含有缺失值的变量都利用了其他变量提供的信息来进行插补；</p>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过提取imp对象的子成分，可以观测到实际的插补值</span></span><br><span class="line"></span><br><span class="line">imp$imp$Span</span><br></pre></td></tr></table></figure>
 <table> <thead><tr><th></th><th scope="col">1</th><th scope="col">2</th><th scope="col">3</th><th scope="col">4</th><th scope="col">5</th></tr></thead> <tbody> <tr><th scope="row">4</th><td> 3  </td><td> 2.0</td><td> 2.0</td><td> 9.0</td><td> 4.5</td></tr> <tr><th scope="row">13</th><td>13  </td><td> 3.2</td><td> 7.0</td><td> 3.9</td><td> 2.6</td></tr> <tr><th scope="row">35</th><td>24  </td><td>12.0</td><td>20.2</td><td>20.0</td><td>12.0</td></tr> <tr><th scope="row">36</th><td> 3  </td><td> 3.0</td><td> 4.5</td><td> 3.0</td><td> 3.0</td></tr> </tbody> </table>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用complete()函数可以观察m个插补数据集中的任意一个</span></span><br><span class="line"></span><br><span class="line">dataset &lt;- complete(imp, action=<span class="number">3</span>)</span><br><span class="line">head(dataset, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
 <table> <thead><tr><th scope="col">BodyWgt</th><th scope="col">BrainWgt</th><th scope="col">NonD</th><th scope="col">Dream</th><th scope="col">Sleep</th><th scope="col">Span</th><th scope="col">Gest</th><th scope="col">Pred</th><th scope="col">Exp</th><th scope="col">Danger</th></tr></thead> <tbody> <tr><td>6654.000</td><td>5712.0  </td><td> 3.3    </td><td>0.5     </td><td> 3.3    </td><td>38.6    </td><td>645     </td><td>3       </td><td>5       </td><td>3       </td></tr> <tr><td>   1.000</td><td>   6.6  </td><td> 6.3    </td><td>2.0     </td><td> 8.3    </td><td> 4.5    </td><td> 42     </td><td>3       </td><td>1       </td><td>3       </td></tr> <tr><td>   3.385</td><td>  44.5  </td><td>10.4    </td><td>2.3     </td><td>12.5    </td><td>14.0    </td><td> 60     </td><td>1       </td><td>1       </td><td>1       </td></tr> <tr><td>   0.920</td><td>   5.7  </td><td>14.3    </td><td>2.2     </td><td>16.5    </td><td> 2.0    </td><td> 25     </td><td>5       </td><td>2       </td><td>3       </td></tr> <tr><td>2547.000</td><td>4603.0  </td><td> 2.1    </td><td>1.8     </td><td> 3.9    </td><td>69.0    </td><td>624     </td><td>3       </td><td>5       </td><td>4       </td></tr> <tr><td>  10.550</td><td> 179.5  </td><td> 9.1    </td><td>0.7     </td><td> 9.8    </td><td>27.0    </td><td>180     </td><td>4       </td><td>4       </td><td>4       </td></tr> <tr><td>   0.023</td><td>   0.3  </td><td>15.8    </td><td>3.9     </td><td>19.7    </td><td>19.0    </td><td> 35     </td><td>1       </td><td>1       </td><td>1       </td></tr> <tr><td> 160.000</td><td> 169.0  </td><td> 5.2    </td><td>1.0     </td><td> 6.2    </td><td>30.4    </td><td>392     </td><td>4       </td><td>5       </td><td>4       </td></tr> <tr><td>   3.300</td><td>  25.6  </td><td>10.9    </td><td>3.6     </td><td>14.5    </td><td>28.0    </td><td> 63     </td><td>1       </td><td>2       </td><td>1       </td></tr> <tr><td>  52.160</td><td> 440.0  </td><td> 8.3    </td><td>1.4     </td><td> 9.7    </td><td>50.0    </td><td>230     </td><td>1       </td><td>1       </td><td>1       </td></tr> </tbody> </table>

<p>在R语言中，能够处理确实值的包有很多，这个只是比较常见的其中之一。说到底，这篇文章也只是《R语言实战》的抄写而已。我对此的理解也是表面而已。<br>唯有在实际应用中，才能更深刻的理解和掌握缺失值的处理方法及适用范围。希望自己能常常总结分析，在这篇文章里加入更多自己的东西。</p>
]]></content>
      <categories>
        <category>R</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>数据管理</tag>
      </tags>
  </entry>
  <entry>
    <title>R可视化之图形参数基础</title>
    <url>/blogs/1f7e6963/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><p>R语言的图形参数主要由par()函数控制，图形布局主要由layout()函数控制</p>
<h2 id="图形参数"><a href="#图形参数" class="headerlink" title="图形参数"></a>图形参数</h2><p>我们以如下数据为例</p>
<table>
<thead>
<tr>
<th>剂量(dose)</th>
<th>对药物A的响应(drugA)</th>
<th>对药物B的响应(drugB)</th>
</tr>
</thead>
<tbody>
<tr>
<td>20</td>
<td>16</td>
<td>15</td>
</tr>
<tr>
<td>30</td>
<td>20</td>
<td>18</td>
</tr>
<tr>
<td>40</td>
<td>27</td>
<td>25</td>
</tr>
<tr>
<td>45</td>
<td>40</td>
<td>31</td>
</tr>
<tr>
<td>60</td>
<td>60</td>
<td>40</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dose  &lt;- c(<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">60</span>)</span><br><span class="line">drugA &lt;- c(<span class="number">16</span>, <span class="number">20</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">60</span>)</span><br><span class="line">drugB &lt;- c(<span class="number">15</span>, <span class="number">18</span>, <span class="number">25</span>, <span class="number">31</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># par()函数作用是全局的,使用par()修改过的参数除非会话结束，否则将一直保留，之后画</span></span><br><span class="line"><span class="comment"># 的图形将一直使用修改过的参数绘制。</span></span><br><span class="line">opar &lt;- par(no.readonly=<span class="literal">TRUE</span>)  <span class="comment"># 保存原始的par参数</span></span><br><span class="line">par(lty=<span class="number">3</span>,pch=<span class="number">8</span>)    <span class="comment"># 设置线型线宽</span></span><br><span class="line">plot(dose,drugA,type=<span class="string">'b'</span>)  <span class="comment"># 绘制图形</span></span><br><span class="line">par(opar)  <span class="comment"># 将参数恢复为原始参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type='b'  表示同时绘制点和线</span></span><br><span class="line"><span class="comment"># type='p'  表示只绘制点</span></span><br><span class="line"><span class="comment"># type='l'  表示只绘制线</span></span><br><span class="line"><span class="comment"># type='o'  表示绘制的线穿过点</span></span><br><span class="line"><span class="comment"># type='c'  表示只绘制线且空出有点的地方（实际就是b模式把点去掉）</span></span><br></pre></td></tr></table></figure>
<img src="/blogs/1f7e6963/output_2_0.jpg" title="图1">
<h3 id="符号和线型线宽"><a href="#符号和线型线宽" class="headerlink" title="符号和线型线宽"></a>符号和线型线宽</h3><table>
<thead>
<tr>
<th style="text-align:right">参数</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">lty</td>
<td style="text-align:center">线条类型</td>
<td style="text-align:center">solid(即1)</td>
</tr>
<tr>
<td style="text-align:right">lwd</td>
<td style="text-align:center">线条宽度</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:right">pch</td>
<td style="text-align:center">设置绘图点和符号的类型</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:right">cex</td>
<td style="text-align:center">控制文字和绘图符号的大小，cex=1表示正常大小，0.8表示正常大小的80%</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/GengDaPeng/GengDaPeng.github.io/hexo/source/_posts/2018-09-23-R%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B9%8B%E5%9B%BE%E5%BD%A2%E5%8F%82%E6%95%B0%E5%9F%BA%E7%A1%80/pch.png" alt="参数pch对应的绘图符号"></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># R中的线型和线宽</span></span><br><span class="line">plot.new()</span><br><span class="line">plot.window(xlim = c(<span class="number">0</span>, <span class="number">6</span>), ylim =  c(<span class="number">0</span>, <span class="number">6</span>), ann = <span class="literal">F</span>, asp = <span class="number">1</span>)</span><br><span class="line">int &lt;-  <span class="number">0</span>:<span class="number">5</span>+<span class="number">0.5</span></span><br><span class="line">abline(h = int, lty = <span class="number">1</span>:<span class="number">6</span>, lwd = <span class="number">1</span>:<span class="number">6</span>)</span><br><span class="line">text(<span class="number">1</span>, int, paste(rep(<span class="string">"lty = "</span>, <span class="number">6</span>), <span class="number">1</span>:<span class="number">6</span>, rep(<span class="string">", lwd = "</span>, <span class="number">6</span>), <span class="number">1</span>:<span class="number">6</span>), pos = <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<img src="/blogs/1f7e6963/output_5_0.jpg" title="图2">
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot(dose,drugA,type=<span class="string">'b'</span>,lty=<span class="number">3</span>,lwd=<span class="number">4</span>,pch=<span class="number">15</span>,cex=<span class="number">3</span>)</span><br><span class="line"><span class="comment">#绘制一幅图形，其线条类型为点线，宽度为默认宽度的4倍，点的符号为实心正方形，大小为默认符号大小的3倍</span></span><br></pre></td></tr></table></figure>
<img src="/blogs/1f7e6963/output_6_0.jpg" title="图3">
<h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>在R中，可以通过颜色下标、颜色名称、十六进制的颜色值、RGB值或HSV值来指定颜色。举例来说，col=1、col=”white”、col=”#FFFFFF”、col=rgb(1,1,1) 和 col=hsv(0,0,1) 都是表示白色的等价方式.colors()可以返回所有可用的颜色。当需要连续的颜色时，可以使用rainbow()函数来生成。</p>
<table>
<thead>
<tr>
<th style="text-align:right">参数</th>
<th style="text-align:left">描述</th>
<th style="text-align:right">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">col</td>
<td style="text-align:left">默认的绘图颜色。某些函数（如lines和pie）可以接受一个含有颜色值的向量并自动循环使用。例如，如果设定col=c(“red”, “blue”)并需要绘制三条线，则第一条线将为红色，第二条线为蓝色，第三条线又将为红色</td>
<td style="text-align:right">‘black’</td>
</tr>
<tr>
<td style="text-align:right">col.axis</td>
<td style="text-align:left">坐标轴刻度文字的颜色</td>
<td style="text-align:right">‘black’</td>
</tr>
<tr>
<td style="text-align:right">col.lab</td>
<td style="text-align:left">坐标轴标签（名称）的颜色</td>
<td style="text-align:right">‘black’</td>
</tr>
<tr>
<td style="text-align:right">col.main</td>
<td style="text-align:left">标题颜色</td>
<td style="text-align:right">‘black’</td>
</tr>
<tr>
<td style="text-align:right">col.sub</td>
<td style="text-align:left">副标题颜色</td>
<td style="text-align:right">‘black’</td>
</tr>
<tr>
<td style="text-align:right">fg</td>
<td style="text-align:left">图形的前景色</td>
<td style="text-align:right">‘black’</td>
</tr>
<tr>
<td style="text-align:right">bg</td>
<td style="text-align:left">图形的背景色</td>
<td style="text-align:right">‘white’</td>
</tr>
</tbody>
</table>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mycolors &lt;- rainbow(<span class="number">5</span>)   <span class="comment"># 参数为整数，表示要生成的颜色数量</span></span><br><span class="line">pie(rep(<span class="number">1</span>,<span class="number">5</span>), labels=mycolors, col=mycolors)</span><br><span class="line">mygrays &lt;- gray(<span class="number">0</span>:<span class="number">5</span>/<span class="number">5</span>)   <span class="comment"># 生成 5阶灰度色</span></span><br><span class="line">pie(rep(<span class="number">1</span>, <span class="number">5</span>), labels=mygrays, col=mygrays)</span><br></pre></td></tr></table></figure>
<img src="/blogs/1f7e6963/output_9_0.jpg" title="图4">
<img src="/blogs/1f7e6963/output_9_1.jpg" title="图5">
<h3 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h3><p>控制字号，字体， 字样</p>
<table>
<thead>
<tr>
<th style="text-align:right">参数</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">cex</td>
<td style="text-align:center">控制文字和绘图符号的大小，cex=1表示正常大小，0.8表示正常大小的80%</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:right">cex.axis</td>
<td style="text-align:center">坐标轴刻度位子的缩放倍数</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:right">cex.lab</td>
<td style="text-align:center">坐标轴标签（名称）的缩放倍数</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:right">cex.main</td>
<td style="text-align:center">主标题文字缩放倍数</td>
<td style="text-align:center">1.2</td>
</tr>
<tr>
<td style="text-align:right">cex.sub</td>
<td style="text-align:center">副标题的缩放倍数</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:right">font</td>
<td style="text-align:center">整数。用于指定绘图使用的字体样式。1=常规，2=粗体，3=斜体，4=粗斜体，5=符号字体(以Adobe符号编码表示)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:right">font.axis</td>
<td style="text-align:center">坐标轴刻度文字的字体样式</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:right">font.lab</td>
<td style="text-align:center">坐标轴标签的字体</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:right">font.main</td>
<td style="text-align:center">主标题的字体</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:right">font.sub</td>
<td style="text-align:center">副标题的字体样式</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:right">ps</td>
<td style="text-align:center">字体磅值（1磅约为1/72英寸）.文本的最终大小为 ps*cex</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:right">family</td>
<td style="text-align:center">绘制文本时使用的字体族。标准的取值为serif（衬线）、sans（无衬线）和mono（等宽）</td>
<td style="text-align:center">‘’</td>
</tr>
</tbody>
</table>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot(dose,drugA,type=<span class="string">'b'</span>,font.lab=<span class="number">2</span>, cex.lab=<span class="number">1.5</span>)  <span class="comment"># 坐标轴标签字体斜体且放大1.5倍</span></span><br><span class="line">text(dose-<span class="number">1</span>,drugA+<span class="number">1</span>,drugA,cex=<span class="number">0.8</span>, font=<span class="number">4</span>)  <span class="comment"># 添加文本</span></span><br></pre></td></tr></table></figure>
<img src="/blogs/1f7e6963/output_12_0.jpg" title="图6">
<h3 id="图形尺寸和边界尺寸"><a href="#图形尺寸和边界尺寸" class="headerlink" title="图形尺寸和边界尺寸"></a>图形尺寸和边界尺寸</h3><table>
<thead>
<tr>
<th style="text-align:right">参数</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">pin</td>
<td style="text-align:center">数值型向量c(宽，高)，以英寸表示的图形尺寸</td>
<td style="text-align:center">(5.4,4.8)</td>
</tr>
<tr>
<td style="text-align:right">mai</td>
<td style="text-align:center">数值型向量 c(底部，左侧，上方，右侧)，设置图形边距大小，单位英寸</td>
<td style="text-align:center">c(1,0.8,0.8,0.4)+0.02</td>
</tr>
<tr>
<td style="text-align:right">mar</td>
<td style="text-align:center">数值型向量 c(底部，左侧，上方，右侧)，设置图形边距大小，单位英分</td>
<td style="text-align:center">c(5, 4, 4, 2) + 0.1</td>
</tr>
</tbody>
</table>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">opar &lt;- par(no.readonly=<span class="literal">TRUE</span>)</span><br><span class="line">par(pin=c(<span class="number">2</span>, <span class="number">3</span>),mfcol=c(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">par(lwd=<span class="number">2</span>, cex=<span class="number">1.5</span>)</span><br><span class="line">par(cex.axis=<span class="number">.75</span>, font.axis=<span class="number">3</span>)</span><br><span class="line">plot(dose, drugA, type=<span class="string">"b"</span>, pch=<span class="number">19</span>, lty=<span class="number">2</span>, col=<span class="string">"red"</span>)</span><br><span class="line">plot(dose, drugB, type=<span class="string">"b"</span>, pch=<span class="number">23</span>, lty=<span class="number">6</span>, col=<span class="string">"blue"</span>, bg=<span class="string">"green"</span>)</span><br><span class="line">par(opar)</span><br></pre></td></tr></table></figure>
<img src="/blogs/1f7e6963/output_15_0.jpg" title="图7">
<h3 id="添加文本，自定义坐标轴和图例"><a href="#添加文本，自定义坐标轴和图例" class="headerlink" title="添加文本，自定义坐标轴和图例"></a>添加文本，自定义坐标轴和图例</h3><table>
<thead>
<tr>
<th style="text-align:right">参数</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">ann</td>
<td style="text-align:center">控制高水平绘图函数的主标题和坐标轴标题注释，若ann=FALSE，将不显示这些注释</td>
<td style="text-align:center">TRUE</td>
</tr>
<tr>
<td style="text-align:right">side</td>
<td style="text-align:center">一个整数，表示在图形的哪边绘制坐标轴（1=下，2=左，3=上，4=右)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right">at</td>
<td style="text-align:center">一个数值型向量，表示需要绘制刻度线的位置</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right">labels</td>
<td style="text-align:center">一个字符型向量，表示置于刻度线旁边的文字标签（如果为NULL，则将直接使用at中的值</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right">pos</td>
<td style="text-align:center">坐标轴线绘制位置的坐标（即与另一条坐标轴相交位置的值）</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right">las</td>
<td style="text-align:center">标签是否平行于（=0）或垂直于（=2）坐标轴</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:right">tck</td>
<td style="text-align:center">刻度线的长度，以相对于绘图区域大小的分数表示（负值表示在图形外侧，正值表示在图形内侧，0表示禁用刻度，1表示绘制网格线）；默认值为-0.01）</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right">xaxt</td>
<td style="text-align:center">设置x轴类型，xaxt=”n” 表示没有坐标轴，取其它值都会画出坐标轴</td>
<td style="text-align:center">s</td>
</tr>
<tr>
<td style="text-align:right">yaxt</td>
<td style="text-align:center">设置y轴类型，同上</td>
<td style="text-align:center">s</td>
</tr>
</tbody>
</table>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot(dose, drugA, type=<span class="string">"b"</span>,  </span><br><span class="line">     col=<span class="string">"red"</span>, lty=<span class="number">2</span>, pch=<span class="number">2</span>, lwd=<span class="number">2</span>,</span><br><span class="line">     main=<span class="string">"Clinical Trials for Drug A"</span>,     <span class="comment"># 主标题</span></span><br><span class="line">     sub=<span class="string">"This is hypothetical data"</span>,     <span class="comment"># 副标题</span></span><br><span class="line">     xlab=<span class="string">"Dosage"</span>, ylab=<span class="string">"Drug Response"</span>,    <span class="comment"># x,y轴标签</span></span><br><span class="line">     xlim=c(<span class="number">0</span>, <span class="number">60</span>), ylim=c(<span class="number">0</span>, <span class="number">70</span>))  <span class="comment">#  x,y轴的范围</span></span><br></pre></td></tr></table></figure>
<img src="/blogs/1f7e6963/output_18_0.jpg" title="图8">
<p>在高级绘图函数中，都是自带坐标轴标题等属性的。如果想自定义，就要使用ann=FALSE 来禁用坐标轴注释</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x &lt;- c(<span class="number">1</span>:<span class="number">10</span>)</span><br><span class="line">y &lt;- x</span><br><span class="line">z &lt;- <span class="number">10</span>/x</span><br><span class="line">opar &lt;- par(no.readonly=<span class="literal">TRUE</span>)</span><br><span class="line">par(mar=c(<span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">8</span>) + <span class="number">0.1</span>)  <span class="comment"># 设置边界大小</span></span><br><span class="line">plot(x, y, type=<span class="string">"b"</span>,</span><br><span class="line">     pch=<span class="number">21</span>, col=<span class="string">"red"</span>,  <span class="comment"># 设置符号类型及线颜色</span></span><br><span class="line">     yaxt=<span class="string">"n"</span>, lty=<span class="number">3</span>, ann=<span class="literal">FALSE</span>)  <span class="comment"># 关闭坐标轴及坐标轴注释</span></span><br><span class="line">lines(x, z, type=<span class="string">"b"</span>, pch=<span class="number">22</span>, col=<span class="string">"blue"</span>, lty=<span class="number">2</span>)  <span class="comment"># 绘制 z线</span></span><br><span class="line">axis(<span class="number">2</span>, at=x, labels=x, col.axis=<span class="string">"red"</span>, las=<span class="number">2</span>)  <span class="comment"># 绘制自定义x 轴</span></span><br><span class="line">axis(<span class="number">4</span>, at=z, labels=round(z, digits=<span class="number">2</span>),   <span class="comment"># 绘制自定义y轴</span></span><br><span class="line">     col.axis=<span class="string">"blue"</span>, las=<span class="number">2</span>, cex.axis=<span class="number">0.7</span>, tck=-<span class="number">.01</span>)</span><br><span class="line">mtext(<span class="string">"y=1/x"</span>, side=<span class="number">4</span>, line=<span class="number">3</span>, cex.lab=<span class="number">1</span>, las=<span class="number">2</span>, col=<span class="string">"blue"</span>)   <span class="comment">#坐标轴标签</span></span><br><span class="line">title(<span class="string">"An Example of Creative Axes"</span>,   <span class="comment"># 标题</span></span><br><span class="line">      xlab=<span class="string">"X values"</span>,</span><br><span class="line">      ylab=<span class="string">"Y=X"</span>)</span><br><span class="line">par(opar)</span><br></pre></td></tr></table></figure>
<img src="/blogs/1f7e6963/output_20_0.jpg" title="图9">
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参考线</span></span><br><span class="line"></span><br><span class="line">abline(h=c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), v=(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment"># 在y轴1,2,3处，x轴4,5,6处添加参考线</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 图例</span></span><br><span class="line"></span><br><span class="line">legend(location,title,legend....)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>location</td>
<td>有许多方式可以指定图例的位置。你可以直接给定图例左上角的x、y坐标，也可以执行locator(1)，然后通过鼠标单击给出图例的位置，还可以使用关键字bottom、bottomleft、left、topleft、top、topright、right、bottomright或center放置图例。如果你使用了以上某个关键字，那么可以同时使用参数inset=指定图例向图形内侧移动的大小（以绘图区域大小的分数表示）  </td>
</tr>
<tr>
<td>title</td>
<td>图例标题的字符串（可选）</td>
</tr>
<tr>
<td>legend</td>
<td>图例标签组成的字符型向量</td>
</tr>
<tr>
<td>…</td>
<td>其他选项。如果图例标示的是颜色不同的线条，需要指定col=加上颜色值组成的向量。如果图例标示的是符号不同的点，则需指定pch=加上符号的代码组成的向量。如果图例标示的是不同的线条宽度或线条类型，请使用lwd=或lty=加上宽度值或类型值组成的向量。要为图例创建颜色填充的盒形（常见于条形图、箱线图或饼图），需要使用参数fill=加上颜色值组成的向量</td>
</tr>
</tbody>
</table>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dose &lt;- c(<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">60</span>)</span><br><span class="line">drugA &lt;- c(<span class="number">16</span>, <span class="number">20</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">60</span>)</span><br><span class="line">drugB &lt;- c(<span class="number">15</span>, <span class="number">18</span>, <span class="number">25</span>, <span class="number">31</span>, <span class="number">40</span>)    <span class="comment"># 输入数据</span></span><br><span class="line">opar &lt;- par(no.readonly=<span class="literal">TRUE</span>)    <span class="comment"># 保存原始参数</span></span><br><span class="line">par(lwd=<span class="number">2</span>, cex=<span class="number">1.5</span>, font.lab=<span class="number">2</span>)    <span class="comment"># 设置线宽， 放大1.5倍， 坐标轴标签字体 粗体</span></span><br><span class="line">plot(dose, drugA, type=<span class="string">"b"</span>,</span><br><span class="line">     pch=<span class="number">15</span>, lty=<span class="number">1</span>, col=<span class="string">"red"</span>, ylim=c(<span class="number">0</span>, <span class="number">60</span>),     <span class="comment"># 设置符号类型，线型， 颜色， y轴取值范围</span></span><br><span class="line">     main=<span class="string">"Drug A vs. Drug B"</span>,     <span class="comment"># 主标题</span></span><br><span class="line">     xlab=<span class="string">"Drug Dosage"</span>, ylab=<span class="string">"Drug Response"</span>)</span><br><span class="line">text(dose-<span class="number">1</span>, drugA+<span class="number">1.8</span>, drugA, col=<span class="string">'red'</span>,cex=<span class="number">0.5</span>,font=<span class="number">2</span>)    <span class="comment"># 添加文本</span></span><br><span class="line">text(dose, drugB-<span class="number">2</span>, drugB, col=<span class="string">'blue'</span>,cex=<span class="number">0.5</span>,font=<span class="number">2</span>)   <span class="comment"># 添加文本</span></span><br><span class="line">lines(dose, drugB, type=<span class="string">"b"</span>,</span><br><span class="line">      pch=<span class="number">17</span>, lty=<span class="number">2</span>, col=<span class="string">"blue"</span>)</span><br><span class="line">abline(h=c(<span class="number">30</span>), lwd=<span class="number">1.5</span>, lty=<span class="number">2</span>, col=<span class="string">"gray"</span>)    <span class="comment"># 参考线</span></span><br><span class="line"><span class="keyword">library</span>(Hmisc)       <span class="comment"># 载入包</span></span><br><span class="line">minor.tick(nx=<span class="number">3</span>, ny=<span class="number">3</span>, tick.ratio=<span class="number">0.5</span>)    <span class="comment"># 添加次要刻度线</span></span><br><span class="line">legend(<span class="string">"topleft"</span>, inset=<span class="number">.05</span>, title=<span class="string">"Drug Type"</span>, c(<span class="string">"A"</span>,<span class="string">"B"</span>),    <span class="comment"># 图例</span></span><br><span class="line">       lty=c(<span class="number">1</span>, <span class="number">2</span>), pch=c(<span class="number">15</span>, <span class="number">17</span>), col=c(<span class="string">"red"</span>, <span class="string">"blue"</span>))</span><br><span class="line">par(opar)</span><br></pre></td></tr></table></figure>
<img src="/blogs/1f7e6963/output_24_0.jpg" title="图10">
<p>text()可向绘图区域内部添加文本，而mtext()则向图形的四个边界之一添加文本。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>location</td>
<td>文本的位置参数。可为一对x,y坐标，也可通过指定location为locator(1)使用鼠标交互式地确定摆放位置</td>
</tr>
<tr>
<td>pos</td>
<td>文本相对于位置参数的方位。1=下，2=左，3=上，4=右。如果指定了pos，就可以同时指定参数offset=作为偏移量，以相对于单个字符宽度的比例表示</td>
</tr>
<tr>
<td>side</td>
<td>指定用来放置文本的边。1=下，2=左，3=上，4=右。你可以指定参数line=来内移或外移文本，随着值的增加，文本将外移。也可使用adj=0将文本向左下对齐，或使用adj=1右上对齐</td>
</tr>
</tbody>
</table>
<p>text(lacation, “text”, pos,…)<br>mtext(“text”, side, line=n,…)</p>
<h2 id="图形布局"><a href="#图形布局" class="headerlink" title="图形布局"></a>图形布局</h2><p>使用layout（）函数可以很容易的绘制出不同布局的拼图。<br>layout(mat,widthhs=rep.int(1,ncol(mat)), height=rep.int(1,nrow(mat)), respect=FALSE)</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">mat</td>
<td>矩阵，描述绘图环境，比如matrix(c(1,2,3,3),nrow=2,ncol=2,byrow=TRUE)表示见绘图区域分割成2行2列，按列填充。第三张图占据整个第二行，前两张图平分第一行</td>
</tr>
<tr>
<td style="text-align:left">widths</td>
<td>向量，分割区域宽度，widths=(2,1)表示绘图区宽度按照2:1划分</td>
</tr>
<tr>
<td style="text-align:left">heights</td>
<td>向量，分割区域高度，heights=(3,1)表示绘图区高度按照3:1划分</td>
</tr>
</tbody>
</table>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在par()函数中使用图形参数 mfrow=c(nrows, ncols)来创建按行填充的、行数为nrows、列数为ncols的图形矩阵。</span></span><br><span class="line"><span class="comment"># nfcol=c(nrows, ncols)按列填充矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">attach</span>(mtcars)</span><br><span class="line">opar &lt;- par(no.readonly=<span class="literal">TRUE</span>)</span><br><span class="line">par(mfrow=c(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">plot(wt,mpg, main=<span class="string">"Scatterplot of wt vs. mpg"</span>)</span><br><span class="line">plot(wt,disp, main=<span class="string">"Scatterplot of wt vs. disp"</span>)</span><br><span class="line">hist(wt, main=<span class="string">"Histogram of wt"</span>)</span><br><span class="line">boxplot(wt, main=<span class="string">"Boxplot of wt"</span>)</span><br><span class="line">par(opar)</span><br><span class="line"><span class="keyword">detach</span>(mtcars)</span><br></pre></td></tr></table></figure>
<img src="/blogs/1f7e6963/output_27_0.jpg" title="图11">
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># layout（）函数</span></span><br><span class="line">layout(matrix(c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>), nrow=<span class="number">2</span>, ncol=<span class="number">2</span>), widths=c(<span class="number">2</span>,<span class="number">1</span>))  <span class="comment"># 设置布局 2行2列 默认列填充， 第三幅图占据3,4号位，且宽度是1,2的1/2</span></span><br><span class="line">opar &lt;- par(no.readonly=<span class="literal">TRUE</span>)</span><br><span class="line">par(mai=c(<span class="number">0.6</span>,<span class="number">0.6</span>,<span class="number">0.1</span>,<span class="number">0.1</span>),cex=<span class="number">0.7</span>)      <span class="comment"># 设置图形边距及缩放0.7</span></span><br><span class="line">x &lt;- rnorm(<span class="number">5000</span>)    <span class="comment"># 生成5000个标准正态分布的随机数</span></span><br><span class="line">y &lt;- rchisq(<span class="number">5000</span>, <span class="number">10</span>)    <span class="comment"># 生成5000个卡方分布的随机数</span></span><br><span class="line">hist(x, prob=<span class="literal">TRUE</span>, col=<span class="string">'lightblue'</span>,  <span class="comment"># x 的直方图，</span></span><br><span class="line">     xlab=<span class="string">'x'</span>, ylab=<span class="string">'Density'</span>,  <span class="comment"># 设置坐标轴注释</span></span><br><span class="line">     ylim=c(<span class="number">0</span>,<span class="number">0.4</span>),main=<span class="string">""</span>)   <span class="comment"># 设置y轴范围，禁用主标题</span></span><br><span class="line">hist(y, freq=<span class="literal">FALSE</span>, col=<span class="string">'pink'</span>, xlab=<span class="string">"y"</span>, ylab=<span class="string">'Density'</span>, main=<span class="string">""</span>)</span><br><span class="line">boxplot(x, col=<span class="string">'red'</span>, lwd=<span class="number">1</span>)</span><br><span class="line">par(opar)</span><br></pre></td></tr></table></figure>
<img src="/blogs/1f7e6963/output_28_0.jpg" title="图12">
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">attach</span>(mtcars)</span><br><span class="line">layout(matrix(c(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="number">2</span>, <span class="number">2</span>, byrow = <span class="literal">TRUE</span>),</span><br><span class="line">       widths=c(<span class="number">3</span>, <span class="number">1</span>), heights=c(<span class="number">1</span>, <span class="number">2</span>))   <span class="comment"># 第二行高度是第一行的2倍，第三幅图的宽度是第二幅图的 1/3</span></span><br><span class="line">hist(wt)</span><br><span class="line">hist(mpg)</span><br><span class="line">hist(disp)</span><br><span class="line"><span class="keyword">detach</span>(mtcars)</span><br></pre></td></tr></table></figure>
<img src="/blogs/1f7e6963/output_29_0.jpg" title="图13">
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  更精细的控制图形，可以使多张图组合成一张有实际意义的图形</span></span><br><span class="line"><span class="comment">#  利用 fig= 参数来精确的控制绘图，参数fig=的取值是一个形如c(x1, x2, y1, y2)的数值向量</span></span><br><span class="line"><span class="comment">#  想想绘图区域是一个宽为 1 ，高为 1 的矩形，则x1, x2, y1, y2的范围就是[0,1]</span></span><br><span class="line"><span class="comment">#  fig= 默认 会新建一幅图形，所以在添加一幅图到一幅现有图形上时，请设定参数new=TRUE。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">opar &lt;- par(no.readonly=<span class="literal">TRUE</span>)</span><br><span class="line">par(fig=c(<span class="number">0</span>, <span class="number">0.8</span>, <span class="number">0</span>, <span class="number">0.8</span>))    <span class="comment"># 设置散点图范围</span></span><br><span class="line">plot(mtcars$mpg, mtcars$wt,    <span class="comment">#  散点图</span></span><br><span class="line">     xlab=<span class="string">"Miles Per Gallon"</span>,</span><br><span class="line">     ylab=<span class="string">"Car Weight"</span>)</span><br><span class="line">par(fig=c(<span class="number">0</span>, <span class="number">0.8</span>, <span class="number">0.5</span>, <span class="number">1</span>), new=<span class="literal">TRUE</span>)   <span class="comment"># 设置上方箱线图范围，宽于散点图一致，高度范围在0.5-1,。</span></span><br><span class="line">boxplot(mtcars$mpg, horizontal=<span class="literal">TRUE</span>, axes=<span class="literal">FALSE</span>)   <span class="comment"># 上方添加箱线图， 禁用坐标轴</span></span><br><span class="line">par(fig=c(<span class="number">0.6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0.8</span>), new=<span class="literal">TRUE</span>)   <span class="comment"># 设置右边箱线图，高度与散点图一直，宽度范围在0.6-1.</span></span><br><span class="line">boxplot(mtcars$wt, axes=<span class="literal">FALSE</span>)    <span class="comment"># 右边添加箱线图，禁用坐标轴</span></span><br><span class="line">mtext(<span class="string">"Enhanced Scatterplot"</span>, side=<span class="number">3</span>, outer=<span class="literal">TRUE</span>, line=-<span class="number">3</span>)</span><br><span class="line">par(opar)</span><br></pre></td></tr></table></figure>
<img src="/blogs/1f7e6963/output_30_0.jpg" title="图14">]]></content>
      <categories>
        <category>R</category>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言的基础语法及常用命令</title>
    <url>/blogs/db1af4ba/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><p>R其实对于数据分析来说只是工具而已，所以刚开始不需要学习多么深多么细，只需要能够满足当前需求就行，之后的在实践中慢慢学习。<br>毕竟想要把R学精并不是容易的事情。正确的做法就是边做边学，不会就google翻文档。<br>本片主要是R的基础语法及常用的命令操作<br><a id="more"></a></p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>R赋值采用<code>&lt;-</code>或者<code>-&gt;</code>或者<code>=</code>，建议采用标准的第一个。<br><strong>由于R中内置了同名函数c()，最好不要在编码时使用c作为对象名，否则可能产生一些不易察觉的问题</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a &lt;- <span class="number">133</span></span><br><span class="line"><span class="string">"hello"</span> -&gt; b  <span class="comment"># 注意无论哪种写法，大于或小于号都是指向变量名</span></span><br><span class="line">d = <span class="string">'This'</span>  <span class="comment"># 不建议这么用，有可能会造成问题</span></span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<pre><code>133

&apos;hello&apos;

&apos;This&apos;
</code></pre><h2 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">help(mean)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">?mean</span><br></pre></td></tr></table></figure>
<h2 id="包的安装和加载"><a href="#包的安装和加载" class="headerlink" title="包的安装和加载"></a>包的安装和加载</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取包含R包的库位置</span></span><br><span class="line">.libPaths()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已经安装的包</span></span><br><span class="line"><span class="keyword">library</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">install.packages(<span class="string">"packagename"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载包</span></span><br><span class="line"><span class="keyword">library</span>(packagesname)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已经加载的包</span></span><br><span class="line">(.packages())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载加载的包（注意不是删除包）</span></span><br><span class="line"><span class="keyword">detach</span>(<span class="string">"package:packagename"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除包</span></span><br><span class="line">remove.packages(<span class="string">"packagename"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="数据的读取与保存"><a href="#数据的读取与保存" class="headerlink" title="数据的读取与保存"></a>数据的读取与保存</h2><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取csv</span></span><br><span class="line">data &lt;- read.csv(<span class="string">'.\\统计学\\example\\ch1\\table1_1.csv'</span>) </span><br><span class="line">head(data,<span class="number">6</span>)    <span class="comment"># 读取前 6行的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 Excel数据</span></span><br><span class="line"><span class="keyword">library</span>(xlsx)    <span class="comment">#需要安装 xlsx 包</span></span><br><span class="line">data &lt;- read.xlsx(<span class="string">"file"</span>,n)    <span class="comment"># n 为要导入工作表的序号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 spss数据</span></span><br><span class="line"><span class="keyword">library</span>(foregin) <span class="comment"># 已经默认安装</span></span><br><span class="line">data &lt;- read.spss(<span class="string">"file"</span>,use.value.labels=<span class="literal">TRUE</span>,as.data.frame=<span class="literal">TRUE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 R格式数据</span></span><br><span class="line">data &lt;- load(<span class="string">'.\\统计学\\example\\ch1\\example1_1.RData'</span>)</span><br></pre></td></tr></table></figure>
<table> <thead><tr><th scope="col">学生姓名</th><th scope="col">统计学</th><th scope="col">数学</th><th scope="col">营销学</th><th scope="col">管理学</th><th scope="col">会计学</th></tr></thead> <tbody> <tr><td>张青松</td><td>68    </td><td> 85   </td><td>84    </td><td>89    </td><td>86    </td></tr> <tr><td>王宇翔</td><td>85    </td><td> 91   </td><td>63    </td><td>76    </td><td>66    </td></tr> <tr><td>田思雨</td><td>74    </td><td> 74   </td><td>61    </td><td>80    </td><td>69    </td></tr> <tr><td>徐丽娜</td><td>88    </td><td>100   </td><td>49    </td><td>71    </td><td>66    </td></tr> <tr><td>张志杰</td><td>63    </td><td> 82   </td><td>89    </td><td>78    </td><td>80    </td></tr> <tr><td>赵颖颖</td><td>78    </td><td> 84   </td><td>51    </td><td>60    </td><td>60    </td></tr> </tbody> </table>

<h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存 R格式数据</span></span><br><span class="line">save(data,file = <span class="string">'.\\...\\name.Rdata'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存 csv格式数据</span></span><br><span class="line">write.csv(data,file = <span class="string">'.\\...\\name.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存 xlsx格式</span></span><br><span class="line"><span class="keyword">library</span>(xlsx)</span><br><span class="line">write.xlsx(data, <span class="string">"data.xlsx"</span>,sheet.name=<span class="string">"sheet1"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x &lt;- <span class="number">30L</span>  <span class="comment"># R语言中，在正整数后加 L来表示整型数据（正整数）</span></span><br><span class="line"><span class="keyword">if</span>(is.integer(x)) &#123;</span><br><span class="line">   print(<span class="string">"X is an Integer"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>[1] &quot;X is an Integer&quot;
</code></pre><h3 id="if…else语句"><a href="#if…else语句" class="headerlink" title="if…else语句"></a>if…else语句</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">y &lt;- list(<span class="string">'a'</span>, <span class="string">'v'</span>, <span class="string">'d'</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="string">'a'</span> %<span class="keyword">in</span>% y)&#123;    <span class="comment"># %in% 运算符 检查元素是否在向量中</span></span><br><span class="line">    print(<span class="string">'a is in list'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;      <span class="comment"># 注意这里的 else语句并不在if的花括号当中</span></span><br><span class="line">    print(<span class="string">'a is not in list'</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>[1] &quot;a is in list&quot;
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x &lt;- c(<span class="string">"what"</span>,<span class="string">"is"</span>,<span class="string">"truth"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"Truth"</span> %<span class="keyword">in</span>% x) &#123;</span><br><span class="line">   print(<span class="string">"Truth is found the first time"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"truth"</span> %<span class="keyword">in</span>% x) &#123;</span><br><span class="line">   print(<span class="string">"truth is found the second time"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   print(<span class="string">"No truth found"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>[1] &quot;truth is found the second time&quot;
</code></pre><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个函数，输入的值和选择的函数类型来输出结果。</span></span><br><span class="line">centre &lt;- <span class="keyword">function</span>(x, type) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(type,</span><br><span class="line"></span><br><span class="line">       mean = mean(x),</span><br><span class="line"></span><br><span class="line">       median = median(x),</span><br><span class="line"></span><br><span class="line">       trimmed = mean(x, trim = <span class="number">.1</span>))</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">centre(c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>),<span class="string">'mean'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>3
</code></pre><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ant &lt;- <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span>(ant&lt;<span class="number">5</span>)&#123;</span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line">    ant = ant + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>[1] &quot;hello&quot;
[1] &quot;hello&quot;
[1] &quot;hello&quot;
</code></pre><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">v &lt;- LETTERS[<span class="number">1</span>:<span class="number">4</span>]  <span class="comment"># LETTERS为26个大写字母向量。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> v)&#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>[1] &quot;A&quot;
[1] &quot;B&quot;
[1] &quot;C&quot;
[1] &quot;D&quot;
</code></pre><h3 id="repeat循环"><a href="#repeat循环" class="headerlink" title="repeat循环"></a>repeat循环</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">i &lt;- <span class="number">1</span></span><br><span class="line">sum &lt;- <span class="number">0</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">&#123;</span><br><span class="line">   sum = sum + i</span><br><span class="line">   <span class="keyword">if</span>( i &gt;= <span class="number">100</span>)   <span class="comment">#如果已循环加到了100，则使用break跳出repeat循环</span></span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">   i &lt;- i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>
<pre><code>[1] 5050
</code></pre><h3 id="next语句"><a href="#next语句" class="headerlink" title="next语句"></a>next语句</h3><p>R语言存在next语句，当我们想跳过循环的当前迭代而不终止它时便可使用next。 遇到next时，R解析器跳过本次迭代，并开始循环的下一次迭代。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">k &lt;- LETTERS[<span class="number">1</span>:<span class="number">6</span>]</span><br><span class="line"><span class="keyword">for</span> ( i <span class="keyword">in</span> k) &#123;</span><br><span class="line">   <span class="keyword">if</span> (i == <span class="string">"D"</span>) &#123;</span><br><span class="line">      <span class="keyword">next</span></span><br><span class="line">   &#125;</span><br><span class="line">   print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>[1] &quot;A&quot;
[1] &quot;B&quot;
[1] &quot;C&quot;
[1] &quot;E&quot;
[1] &quot;F&quot;
</code></pre><h2 id="R常用的常量"><a href="#R常用的常量" class="headerlink" title="R常用的常量"></a>R常用的常量</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 26个大写字母</span></span><br><span class="line">LETTERS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 26个小写字母</span></span><br><span class="line">letters</span><br><span class="line"></span><br><span class="line"><span class="comment"># 月份简写</span></span><br><span class="line">month.abb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 月份名称</span></span><br><span class="line">month.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># π 值</span></span><br><span class="line">pi</span><br></pre></td></tr></table></figure>
<pre><code>&apos;A&apos; &apos;B&apos; &apos;C&apos; &apos;D&apos; &apos;E&apos; &apos;F&apos; &apos;G&apos; &apos;H&apos; &apos;I&apos; &apos;J&apos; &apos;K&apos; &apos;L&apos; &apos;M&apos; &apos;N&apos; &apos;O&apos; &apos;P&apos; &apos;Q&apos; &apos;R&apos; &apos;S&apos; &apos;T&apos; &apos;U&apos; &apos;V&apos; &apos;W&apos; &apos;X&apos; &apos;Y&apos; &apos;Z&apos;
&apos;a&apos; &apos;b&apos; &apos;c&apos; &apos;d&apos; &apos;e&apos; &apos;f&apos; &apos;g&apos; &apos;h&apos; &apos;i&apos; &apos;j&apos; &apos;k&apos; &apos;l&apos; &apos;m&apos; &apos;n&apos; &apos;o&apos; &apos;p&apos; &apos;q&apos; &apos;r&apos; &apos;s&apos; &apos;t&apos; &apos;u&apos; &apos;v&apos; &apos;w&apos; &apos;x&apos; &apos;y&apos; &apos;z&apos;
&apos;Jan&apos; &apos;Feb&apos; &apos;Mar&apos; &apos;Apr&apos; &apos;May&apos; &apos;Jun&apos; &apos;Jul&apos; &apos;Aug&apos; &apos;Sep&apos; &apos;Oct&apos; &apos;Nov&apos; &apos;Dec&apos;
&apos;January&apos; &apos;February&apos; &apos;March&apos; &apos;April&apos; &apos;May&apos; &apos;June&apos; &apos;July&apos; &apos;August&apos; &apos;September&apos; &apos;October&apos; &apos;November&apos; &apos;December&apos;
3.14159265358979
</code></pre>]]></content>
      <categories>
        <category>R</category>
        <category>基础语法</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言的数据结构</title>
    <url>/blogs/8afb62cf/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><p>R共有<strong>6种储存数据的对象类型</strong></p>
<ul>
<li>向量</li>
<li>列表</li>
<li>数组</li>
<li>数据框</li>
<li>矩阵</li>
<li>因子<a id="more"></a>
<img src="/blogs/8afb62cf/数据结构示意.png" title="R中的数据结构">
</li>
</ul>
<h2 id="向量-Vectors"><a href="#向量-Vectors" class="headerlink" title="向量(Vectors)"></a>向量(Vectors)</h2><p>向量是用于存储数值型、字符型或逻辑型数据的<strong>一维数组</strong>。执行组合功能的函数c()可用来创建向量。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个向量</span></span><br><span class="line">apple &lt;- c(<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">"yellow"</span>)</span><br><span class="line">num &lt;- c(<span class="number">12</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">78</span>, <span class="number">83</span>)</span><br><span class="line">print(apple)</span><br><span class="line">print(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看向量的类型.</span></span><br><span class="line">print(class(apple))</span><br></pre></td></tr></table></figure>
<pre><code>[1] &quot;red&quot;    &quot;green&quot;  &quot;yellow&quot;
[1] 12 23 34 56 78 83
[1] &quot;character&quot;
</code></pre><p><strong> !!! 单个向量中，数据的类型必须是相同的</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向量元素的选取</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 与其他编程语言索引从0计数不同的是，R语言的索引从1开始计数</span></span><br><span class="line">num[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选取多个元素</span></span><br><span class="line">num[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 索引前加 - 号代表除去这个元素的其他元素，可以看到结果中没有第二个元素</span></span><br><span class="line">apple[-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选取除了第2个和第3个元素外的其他元素</span></span><br><span class="line">num[-(<span class="number">2</span>:<span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
<pre><code>12
12 23 34
&apos;red&apos; &apos;yellow&apos;
12 56 78 83
</code></pre><h2 id="矩阵-Matrix"><a href="#矩阵-Matrix" class="headerlink" title="矩阵(Matrix)"></a>矩阵(Matrix)</h2><p>矩阵是一个<strong>二维数组</strong>，只是每个元素都拥有相同的模式（数值型、字符型或逻辑型）。可通过函数matrix创建矩阵。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># matrix(data = ,nrow = n,ncol = n,byrow = ,dimnames =list(row_vector,col_vector) )</span></span><br><span class="line"><span class="comment"># data包含了矩阵的元素</span></span><br><span class="line"><span class="comment"># nrow和ncol用以指定行和列的维数</span></span><br><span class="line"><span class="comment"># dimnames包含了可选的、以字符型向量表示的行名和列名</span></span><br><span class="line"><span class="comment"># byrow则表明矩阵应当按行填充（byrow=TRUE）还是按列填充（byrow=FALSE），默认情况下按列填充。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a matrix.</span></span><br><span class="line">M = matrix( num, nrow = <span class="number">2</span>, ncol = <span class="number">3</span>, byrow = <span class="literal">TRUE</span>, dimnames = list(c(<span class="string">'人口'</span>,<span class="string">'面积'</span>),c(<span class="string">'北京'</span>,<span class="string">'广州'</span>, <span class="string">'上海'</span>)))</span><br><span class="line">print(M)</span><br></pre></td></tr></table></figure>
<pre><code>     北京 广州 上海
人口   12   23   34
面积   56   78   83
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">M1 &lt;- matrix(<span class="number">1</span>:<span class="number">20</span>, nrow=<span class="number">5</span>, ncol=<span class="number">4</span>)</span><br><span class="line">print(M1)</span><br></pre></td></tr></table></figure>
<pre><code>     [,1] [,2] [,3] [,4]
[1,]    1    6   11   16
[2,]    2    7   12   17
[3,]    3    8   13   18
[4,]    4    9   14   19
[5,]    5   10   15   20
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 矩阵元素选取</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选取列</span></span><br><span class="line">M1[,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选取行</span></span><br><span class="line">M1[<span class="number">1</span>,]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选取单个元素</span></span><br><span class="line">M1[<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选取符合要求的元素</span></span><br><span class="line">M1[M1&gt;<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<pre><code>6 7 8 9 10
1 6 11 16
18
11 12 13 14 15 16 17 18 19 20
</code></pre><h2 id="数据框-data-frame"><a href="#数据框-data-frame" class="headerlink" title="数据框(data frame)"></a>数据框(data frame)</h2><p>数据框是表格数据对象。与矩阵一样都是二维的，但是不同的是每列可以包含不同的数据模式。 第一列可以是数字，而第二列可以是字符，第三列可以是逻辑的。它是等长度的向量的列表。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df &lt;- data.frame(</span><br><span class="line">   gender = c(<span class="string">"Male"</span>, <span class="string">"Male"</span>,<span class="string">"Female"</span>), </span><br><span class="line">   height = c(<span class="number">152</span>, <span class="number">171.5</span>, <span class="number">165</span>), </span><br><span class="line">   weight = c(<span class="number">81</span>,<span class="number">93</span>, <span class="number">78</span>),</span><br><span class="line">   Age = c(<span class="number">42</span>,<span class="number">38</span>,<span class="number">26</span>)</span><br><span class="line">)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<table> <thead><tr><th scope="col">gender</th><th scope="col">height</th><th scope="col">weight</th><th scope="col">Age</th></tr></thead> <tbody> <tr><td>Male  </td><td>152.0 </td><td>81    </td><td>42    </td></tr> <tr><td>Male  </td><td>171.5 </td><td>93    </td><td>38    </td></tr> <tr><td>Female</td><td>165.0 </td><td>78    </td><td>26    </td></tr> </tbody> </table>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">patientID &lt;- c(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">age &lt;- c(<span class="number">25</span>, <span class="number">34</span>, <span class="number">28</span>, <span class="number">52</span>)</span><br><span class="line">diabetes &lt;- c(<span class="string">"Type1"</span>, <span class="string">"Type2"</span>, <span class="string">"Type1"</span>, <span class="string">"Type1"</span>)</span><br><span class="line">status &lt;- c(<span class="string">"Poor"</span>, <span class="string">"Improved"</span>, <span class="string">"Excellent"</span>, <span class="string">"Poor"</span>)</span><br><span class="line">patientdata &lt;- data.frame(patientID, age, diabetes, status)</span><br><span class="line">patientdata</span><br></pre></td></tr></table></figure>
<table> <thead><tr><th scope="col">patientID</th><th scope="col">age</th><th scope="col">diabetes</th><th scope="col">status</th></tr></thead> <tbody> <tr><td>1        </td><td>25       </td><td>Type1    </td><td>Poor     </td></tr> <tr><td>2        </td><td>34       </td><td>Type2    </td><td>Improved </td></tr> <tr><td>3        </td><td>28       </td><td>Type1    </td><td>Excellent</td></tr> <tr><td>4        </td><td>52       </td><td>Type1    </td><td>Poor     </td></tr> </tbody> </table>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 索引列</span></span><br><span class="line">print(df$gender)</span><br><span class="line">print(df[,<span class="number">2</span>])</span><br><span class="line">print(df[<span class="number">1</span>:<span class="number">2</span>])</span><br><span class="line">print(df[[<span class="string">'Age'</span>]])</span><br></pre></td></tr></table></figure>
<pre><code>[1] Male   Male   Female
Levels: Female Male
[1] 152.0 171.5 165.0
  gender height
1   Male  152.0
2   Male  171.5
3 Female  165.0
[1] 42 38 26
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 索引行</span></span><br><span class="line">print(df[<span class="number">2</span>:<span class="number">3</span>,])</span><br></pre></td></tr></table></figure>
<pre><code>  gender height weight Age
2   Male  171.5     93  38
3 Female  165.0     78  26
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 特定条件索引</span></span><br><span class="line">df[df$Age &gt; <span class="number">30</span>]</span><br></pre></td></tr></table></figure>
<table> <thead><tr><th scope="col">gender</th><th scope="col">height</th><th scope="col">Age</th></tr></thead> <tbody> <tr><td>Male  </td><td>152.0 </td><td>42    </td></tr> <tr><td>Male  </td><td>171.5 </td><td>38    </td></tr> <tr><td>Female</td><td>165.0 </td><td>26    </td></tr> </tbody> </table>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 索引元素</span></span><br><span class="line">print(patientdata[<span class="number">1</span>,<span class="number">3</span>])   <span class="comment"># 第一列第三行</span></span><br><span class="line"></span><br><span class="line">print(df$Age[<span class="number">1</span>])    <span class="comment"># Age列第一行</span></span><br><span class="line"></span><br><span class="line">print(df[[<span class="number">2</span>]][<span class="number">1</span>])  <span class="comment"># 第二列第一行</span></span><br><span class="line"></span><br><span class="line">print(df[[<span class="string">'Age'</span>]][<span class="number">1</span>])  <span class="comment"># Age列第一行</span></span><br></pre></td></tr></table></figure>
<pre><code>[1] Type1
Levels: Type1 Type2
[1] 42
[1] 152
[1] 42
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成成糖尿病类型变量diabetes和病情变量status的列联表</span></span><br><span class="line">table(patientdata$diabetes, patientdata$status)</span><br></pre></td></tr></table></figure>
<pre><code>      Excellent Improved Poor
Type1         1        0    2
Type2         0        1    0
</code></pre><h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h2><p>虽然矩阵被限制为二维，但数组可以<strong>具有任何数量的维度</strong>。 数组函数使用一个<strong>dim属性</strong>创建所需的维数。 在下面的例子中，我们创建了一个包含两个元素的数组，每个元素为3x3个矩阵。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create an array.</span></span><br><span class="line">a &lt;- array(c(<span class="string">'green'</span>,<span class="string">'yellow'</span>),dim = c(<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<pre><code>, , 1

     [,1]     [,2]     [,3]    
[1,] &quot;green&quot;  &quot;yellow&quot; &quot;green&quot; 
[2,] &quot;yellow&quot; &quot;green&quot;  &quot;yellow&quot;
[3,] &quot;green&quot;  &quot;yellow&quot; &quot;green&quot; 

, , 2

     [,1]     [,2]     [,3]    
[1,] &quot;yellow&quot; &quot;green&quot;  &quot;yellow&quot;
[2,] &quot;green&quot;  &quot;yellow&quot; &quot;green&quot; 
[3,] &quot;yellow&quot; &quot;green&quot;  &quot;yellow&quot;
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dim1 &lt;- c(<span class="string">"A1"</span>, <span class="string">"A2"</span>)</span><br><span class="line">dim2 &lt;- c(<span class="string">"B1"</span>, <span class="string">"B2"</span>, <span class="string">"B3"</span>)</span><br><span class="line">dim3 &lt;- c(<span class="string">"C1"</span>, <span class="string">"C2"</span>, <span class="string">"C3"</span>, <span class="string">"C4"</span>)</span><br><span class="line">z &lt;- array(<span class="number">1</span>:<span class="number">24</span>, c(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), dimnames=list(dim1, dim2, dim3))</span><br><span class="line">print(z)</span><br></pre></td></tr></table></figure>
<pre><code>, , C1

   B1 B2 B3
A1  1  3  5
A2  2  4  6

, , C2

   B1 B2 B3
A1  7  9 11
A2  8 10 12

, , C3

   B1 B2 B3
A1 13 15 17
A2 14 16 18

, , C4

   B1 B2 B3
A1 19 21 23
A2 20 22 24
</code></pre><p>数组的索引同矩阵，只不过下标从2个变成了3个，<strong>数组同矩阵一样，数据类型必须一样</strong></p>
<h2 id="因子-Factors"><a href="#因子-Factors" class="headerlink" title="因子(Factors)"></a>因子(Factors)</h2><p>我们都知道，变量的类型可以分为如下几种  </p>
<ul>
<li><strong>类别变量（定性变量）</strong><ul>
<li>无序类别变量（名义值）：类别无法排序，没有顺序关系，比如行业类别，性别</li>
<li>有序类别变量（顺序值）：类别之间有顺序关系，比如等级，评价‘差’，‘一般’，‘很好’</li>
</ul>
</li>
<li><strong>数值变量（定量变量）</strong><ul>
<li>离散变量（有限值）： 只能去有限个值的变量，可以一一列举。</li>
<li>连续变量（无限值）：在一个或多个区间内取任何值，连续不断不可一一列举，比如温度，身高。</li>
</ul>
</li>
</ul>
<p>类别变量在R中被称为<strong>因子</strong>，函数factor()以一个整数向量的形式存储类别值，整数的取值范围是[1-k ]（其中k 是名义型变量中唯一值的个数），同时一个由字符串（原始值）组成的内部向量将映射到这些整数上。这种做法类似于python特征分子中的将类别变量dummy化  </p>
<p>对于有序变量，我们还可以指定变量对应的编码，使编码与逻辑顺序相一致，比如low,mid,high对应1,2,3</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">patientID &lt;- c(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">age &lt;- c(<span class="number">25</span>, <span class="number">34</span>, <span class="number">28</span>, <span class="number">52</span>)</span><br><span class="line">diabetes &lt;- c(<span class="string">"Type1"</span>, <span class="string">"Type2"</span>, <span class="string">"Type1"</span>, <span class="string">"Type1"</span>)</span><br><span class="line">status &lt;- c(<span class="string">"Poor"</span>, <span class="string">"Improved"</span>, <span class="string">"Excellent"</span>, <span class="string">"Poor"</span>)</span><br><span class="line">diabetes &lt;- factor(diabetes)</span><br><span class="line">status &lt;- factor(status, order=<span class="literal">TRUE</span>)  <span class="comment"># order=TRUE R将此变量当做有序变量对待</span></span><br><span class="line">patientdata &lt;- data.frame(patientID, age, diabetes, status)</span><br><span class="line">str(patientdata）   <span class="comment"># 数据的信息，相当于pandas中的info</span></span><br><span class="line">summary(patientdata)  <span class="comment"># 描述性统计</span></span><br><span class="line"><span class="comment"># 可以看到，描述性统计中，R对数值型分析了最大最小值等，而对因子采用了频数统计。</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;data.frame&apos;:    4 obs. of  4 variables:
 $ patientID: num  1 2 3 4
 $ age      : num  25 34 28 52
 $ diabetes : Factor w/ 2 levels &quot;Type1&quot;,&quot;Type2&quot;: 1 2 1 1
 $ status   : Ord.factor w/ 3 levels &quot;Excellent&quot;&lt;&quot;Improved&quot;&lt;..: 3 2 1 3



   patientID         age         diabetes       status 
 Min.   :1.00   Min.   :25.00   Type1:3   Excellent:1  
 1st Qu.:1.75   1st Qu.:27.25   Type2:1   Improved :1  
 Median :2.50   Median :31.00             Poor     :2  
 Mean   :2.50   Mean   :34.75                          
 3rd Qu.:3.25   3rd Qu.:38.50                          
 Max.   :4.00   Max.   :52.00                          
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果变量的默认顺序不是按照逻辑顺序排列的，比如status如果是按照improved,poor,excellent排列，</span></span><br><span class="line"><span class="comment"># 那么默认的顺序就无法代表真实逻辑顺序。</span></span><br><span class="line"><span class="comment"># 因此，可以添加levels变量</span></span><br><span class="line">status &lt;- factor(status,order=<span class="literal">TRUE</span>,levels = c(<span class="string">"poor"</span>, <span class="string">"improved"</span>, <span class="string">"excellent"</span>))</span><br><span class="line"><span class="comment"># 这样就相当于指定了顺序，任何在数据中出现而未在参数中列举的数据都将被设为缺失值</span></span><br></pre></td></tr></table></figure>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>R中的列表比较像python中的列表，列表中的元素可以是单个字符，数值，也可以是向量，矩阵，数组等<br>列表就是一些<strong>对象的有序集合</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create a list.</span></span><br><span class="line">list1 &lt;- list(c(<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>),<span class="number">21.3</span>,sin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the list.</span></span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure>
<pre><code>[[1]]
[1] 2 5 3

[[2]]
[1] 21.3

[[3]]
function (x)  .Primitive(&quot;sin&quot;)
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">g &lt;- <span class="string">"My First List"</span></span><br><span class="line">h &lt;- c(<span class="number">25</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">39</span>)</span><br><span class="line">j &lt;- matrix(<span class="number">1</span>:<span class="number">10</span>, nrow=<span class="number">5</span>)</span><br><span class="line">k &lt;- c(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</span><br><span class="line">mylist &lt;- list(title=g, ages=h, j, k)</span><br><span class="line">print(mylistlist)</span><br></pre></td></tr></table></figure>
<pre><code>$title
[1] &quot;My First List&quot;

$ages
[1] 25 26 18 39

[[3]]
     [,1] [,2]
[1,]    1    6
[2,]    2    7
[3,]    3    8
[4,]    4    9
[5,]    5   10

[[4]]
[1] &quot;one&quot;   &quot;two&quot;   &quot;three&quot;
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mylist[[<span class="string">'ages'</span>]]  <span class="comment"># 输出ages</span></span><br><span class="line">mylist[[<span class="number">2</span>]]   <span class="comment"># 输出第二个元素</span></span><br></pre></td></tr></table></figure>
<pre><code>25 26 18 39
25 26 18 39
</code></pre><h2 id="处理数据的常用函数"><a href="#处理数据的常用函数" class="headerlink" title="处理数据的常用函数"></a>处理数据的常用函数</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">length(object) </span><br><span class="line"><span class="comment"># 显示对象中元素/成分的数量</span></span><br><span class="line"></span><br><span class="line">dim(object)     </span><br><span class="line"><span class="comment"># 显示某个对象的维度</span></span><br><span class="line"></span><br><span class="line">str(object)     </span><br><span class="line"><span class="comment"># 显示某个对象的结构</span></span><br><span class="line"></span><br><span class="line">class(object)     </span><br><span class="line"><span class="comment"># 显示某个对象的类或类型</span></span><br><span class="line"></span><br><span class="line">mode(object)     </span><br><span class="line"><span class="comment"># 显示某个对象的模式</span></span><br><span class="line"></span><br><span class="line">names(object)     </span><br><span class="line"><span class="comment"># 显示某对象中各成分的名称</span></span><br><span class="line"></span><br><span class="line">c(object, object,…)     </span><br><span class="line"><span class="comment"># 将对象合并入一个向量</span></span><br><span class="line"></span><br><span class="line">cbind(object, object, …) </span><br><span class="line"><span class="comment"># 按列合并对象</span></span><br><span class="line"></span><br><span class="line">rbind(object, object, …) </span><br><span class="line"><span class="comment"># 按行合并对象</span></span><br><span class="line"></span><br><span class="line">Object </span><br><span class="line"><span class="comment"># 输出某个对象</span></span><br><span class="line"></span><br><span class="line">head(object) </span><br><span class="line"><span class="comment"># 列出某个对象的开始部分</span></span><br><span class="line"></span><br><span class="line">tail(object) </span><br><span class="line"><span class="comment"># 列出某个对象的最后部分</span></span><br><span class="line"></span><br><span class="line">ls() </span><br><span class="line"><span class="comment"># 显示当前的对象列表</span></span><br><span class="line"></span><br><span class="line">rm(object, object, …) </span><br><span class="line"><span class="comment"># 删除一个或更多个对象。语句rm(list = ls())将删除当前工作环境中的几乎所有对象,以句点.开头的隐藏对象将不受影响</span></span><br><span class="line"></span><br><span class="line">newobject &lt;- edit(object) </span><br><span class="line"><span class="comment"># 编辑对象并另存为newobject</span></span><br><span class="line"></span><br><span class="line">fix(object) </span><br><span class="line"><span class="comment"># 直接编辑对象</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>R</category>
        <category>基础语法</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>在jupyter notebook中使用R</title>
    <url>/blogs/2f83e5a7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><p>  本来我是不打算学习R语言的，毕竟学习了python，已经能够满足大部分需求了。但是最近报了人大的统计学在职研究生，老师说以后的论文是必须要用R语言来写的。(￣▽￣)~*<br>  那就学吧。因为之前一直在用jupyter notebook来写分析报告，所以我就想也用jupyter写R，这样子就很方便了。高兴的是确实可以在jupyter中使用R，但是在网上很难找到教程，好在翻了官网说明后终于搞定了，在这里记录下方法。供日后查阅。(*^▽^*)<br><a id="more"></a></p>
<h2 id="R的安装"><a href="#R的安装" class="headerlink" title="R的安装"></a>R的安装</h2><p>R的安装网上教程很多，我就不多赘述了，挺简单的。直接去官网下载文件一路火花带闪电的下一步就可以了。<br>下载地址：<a href="https://cloud.r-project.org/" target="_blank" rel="noopener">R官网下载地址</a></p>
<h2 id="Rstudio的安装"><a href="#Rstudio的安装" class="headerlink" title="Rstudio的安装"></a>Rstudio的安装</h2><p>毕竟jupyter多用在展示报告上面，并不适合写工程化的程序。而R的IDE还是推荐Rstudio的，有免费版，可以满足大部分需求。<br>下载地址：<a href="https://www.rstudio.com/products/rstudio/download/" target="_blank" rel="noopener">Rstudio下载地址</a></p>
<h2 id="关联jupyter-notebook"><a href="#关联jupyter-notebook" class="headerlink" title="关联jupyter notebook"></a>关联jupyter notebook</h2><p>如果你没有安装jupyter notebook，需要先安装。我推荐直接使用anaconda，上面自带jupyter notebook而且环境配置都帮你搞定了，自带python<br>相当于最后R和python都可以用。<br>首先我们打开R的命令行，如果不知道可以直接打开Rsudio，在左下角的console里写如下命令：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(c(<span class="string">'repr'</span>, <span class="string">'IRdisplay'</span>, <span class="string">'evaluate'</span>, <span class="string">'crayon'</span>, <span class="string">'pbdZMQ'</span>, <span class="string">'devtools'</span>, <span class="string">'uuid'</span>, <span class="string">'digest'</span>))</span><br><span class="line">devtools::install_github(<span class="string">'IRkernel/IRkernel'</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码会自动分两步执行，执行完后，在输入如下代码中的一个：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只在当前用户下安装</span></span><br><span class="line">IRkernel::installspec()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者是在系统下安装</span></span><br><span class="line">IRkernel::installspec(user = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>
<p>等待执行完毕，打开jupyter就可以新建R的notebook了。<br><img src="/blogs/2f83e5a7/notebook_R.png" title="新建notebook"><br>恩~ 就是这么简单，接下来就可以愉快的写R了<br><img src="/blogs/2f83e5a7/R1.png" title="愉快的编写R语句"></p>
]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>jupyter notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>ACG音乐推荐(1) —— 那些最喜欢的</title>
    <url>/blogs/c784bcde/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><p>想想算来入宅3有余，看了也有200多部动漫了 ，喜欢的动画音乐也不计其数。动画音乐自出生起就有动画本身所赋予的情感生命。所以，对于我来说每一首动画音乐都是有生命的，都是来自某个动画世界里的声音。</p>
<p>但是，人的精力总归是有限的，不可每天都能把所有的听一遍，所以这里就要发挥人类喜欢排名这个喜好了。在这里推荐一些我最喜欢的ACG音乐。</p>
<p><strong>我一直相信好的音乐是能够与心共鸣的。</strong></p>
<a id="more"></a>
<h2 id="さようなら（再见）——《小林家的龙女仆》"><a href="#さようなら（再见）——《小林家的龙女仆》" class="headerlink" title="さようなら（再见）——《小林家的龙女仆》"></a>さようなら（再见）——《小林家的龙女仆》</h2>
    <div id="aplayer-bQffWNgb" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="471403837" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>
<p>人和龙这样差别如此巨大的生物能否生活在一起呢？或者说观念和经历迥然不同的两个人能否做朋友甚至家人呢？</p>
<div align="center"><em>“人类有能相处的和不能相处的”</em><br><em>“不能相处的人类一眼就能看出”</em><br><em>“能相处的人类却要花时间才能了解”</em><br><em>“为了区区人类花费这些时间太麻烦了”</em><br><em>“对我而言”</em><br><em>“人类只是随意踏入别人居所”</em><br><em>“欲图夺走宝藏的生物就足够了”</em><br><em>“但是……”</em><br></div>

<p>只要相互尊重，相互了解，便能彼此靠近。毕竟即使是高高在上的龙，也有一颗孤独，渴望被理解的心呐。</p>
<p>人总是把习以为常当做理所应当，在失去的时候才知道有多么宝贵。</p>
<div align="center"><em>“早知道会这样，真应该多夸夸她做的蛋包饭……”</em><br></div>

<p>对于托尔来说，小林的一生只相当于龙的几个月而已,转眼就是生死离别。</p>
<div align="center"><em>“可是，我最喜欢小林了”</em><br></div>

<p>若是惧怕彼此伤害而选择不靠近，那么一切都没有了意义。正是因为有了幸福的记忆，分别才会伤感。既然分别不可避免，何不珍惜如今的每一刻。<br>每当听到这首音乐，不论开心，还是不开心，无论生活如何欺骗我，让我有着怎么样的心情，都能让我瞬间平静，去接纳我所经历的每一刻。去期待未来的每一种可能。</p>
<h2 id="きみにとどけ-留在你身边）-——-《好想告诉你》"><a href="#きみにとどけ-留在你身边）-——-《好想告诉你》" class="headerlink" title="きみにとどけ(留在你身边） —— 《好想告诉你》"></a>きみにとどけ(留在你身边） —— 《好想告诉你》</h2>
    <div id="aplayer-KgslgwKu" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="528047" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>
<div align="center"><em>这份天真烂漫的心情也好<br>那一同开怀大笑的日子也好<br>我都想慎重地培养好它们<br>你穿过断断续续的时空<br>给了我许多的第一次<br>连接起来 到达你身边</em><br></div>

<p>这首歌是少有的我没看完动画但依然百听不厌的。（剧情真的快急死我了，真不愧“好想急死你”）<br>老夫的少女心啊~~~<br>我想谈恋爱~<br>每次听这首歌心情都能好起来，可能是因为这首歌将那份青涩的爱情完美的传达了吧。</p>
<h2 id="ヒャダインとももクロのじょーじょーゆーじょー-——-《日常》OP2"><a href="#ヒャダインとももクロのじょーじょーゆーじょー-——-《日常》OP2" class="headerlink" title="ヒャダインとももクロのじょーじょーゆーじょー  —— 《日常》OP2"></a>ヒャダインとももクロのじょーじょーゆーじょー  —— 《日常》OP2</h2>
    <div id="aplayer-gsdxiLyv" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="29789597" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>
<div align="center"><br><em>我们每天度过的所谓的日常，说不定是一个个连续的奇迹呢<br> 　　　　　　　　　　　　　　　　　　　　　　　　　　　最上川</em><br></div>

<h2 id="i-do-——-《攻壳机动队》"><a href="#i-do-——-《攻壳机动队》" class="headerlink" title="i do —— 《攻壳机动队》"></a>i do —— 《攻壳机动队》</h2>
    <div id="aplayer-lCssCXzp" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="590011" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>
<p>其实在入宅之前就听过攻壳的大名，但知道入宅很久后，也一直没有看。直到听到这首歌（话说我的很多补番都是因为先听歌然后才去看的动画）。才开始慢慢补动画。<br>不过到现在也没看完，或许等到补完。对于这首歌能有更多的感触。</p>
<h2 id="again-——-《钢之炼金术师》"><a href="#again-——-《钢之炼金术师》" class="headerlink" title="again —— 《钢之炼金术师》"></a>again —— 《钢之炼金术师》</h2><h2 id="ブラーチヤ-——《钢之炼金术师》"><a href="#ブラーチヤ-——《钢之炼金术师》" class="headerlink" title="ブラーチヤ ——《钢之炼金术师》"></a>ブラーチヤ ——《钢之炼金术师》</h2>
    <div id="aplayer-YeWCwgfV" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="28272045" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>

    <div id="aplayer-PKgbZwqj" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="636882" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>
<p>钢炼无疑是一部极为优秀的动画，但相较于动画，我更喜欢这两首音乐。特别是第二首兄弟</p>
<div align="center"><em>亲爱的妈妈！你是如此温柔！<br>我們很爱你。<br>但我們所有的努力<br>竟都是徒劳无功的。<br>我自己被美丽的希望所诱惑<br>想要回到我們的家<br>我的兄弟，都是我的错。<br>但我们应该怎么办？</em><br></div>

<p>可以说是完美的表现了那场禁忌术式之后兄弟二人复活母亲愿望破灭后的痛苦，哥哥另弟弟失去身体的自责和懊悔，和兄弟二人擦干眼泪决心向前的心情。</p>
<h2 id="となりのトトロ-——-《龙猫》"><a href="#となりのトトロ-——-《龙猫》" class="headerlink" title="となりのトトロ —— 《龙猫》"></a>となりのトトロ —— 《龙猫》</h2>
    <div id="aplayer-iGJvQEGW" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="4879357" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>
<p>永远不会忘记两个小女孩围着一夜长出来的小树高兴的一遍一遍喊道：</p>
<div align="center"><em>“好像在做梦”<br>“可是不是梦”</em><br></div>

<p>也永远不会忘记猫巴士在田野上奔驰的身影。<br><em>人们说，长大了，就在也看不到龙猫了。是么？</em><br>另外，伊藤サチコ老师的吉卜力翻唱集里翻唱了很多宫崎骏动画的歌曲，也很不错。推荐。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=584136&auto=1&height=66"></iframe>

<h2 id="今まで何度も-——-《火影忍者》"><a href="#今まで何度も-——-《火影忍者》" class="headerlink" title="今まで何度も —— 《火影忍者》"></a>今まで何度も —— 《火影忍者》</h2>
    <div id="aplayer-uuoPlCVY" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="27672061" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>
<p>作为从小学追火影十几年到大学的人，实在不知道那首歌是最喜欢的。记得小时候除了电视里放的龙珠，数码宝贝这些，火影只能从哥哥给我的盗版光盘里看到。所以前100多集不知道在DVD里看了多少遍，里面的音乐都成为了童年珍贵的记忆，况且确实很棒。不过非要我选一首的话，我选择这首今まで何度も，即使现在我还常听。</p>
<div align="center"><em>今まで何度も なんとかあきらめずに<br>迄今为止 有数次 总之别放弃<br>今まで何度も 立ちあがってきたじゃないか<br>迄今为止 有数次 为何不能重新振作<br>今まで何度も 僕ら 何度も 信じて 何度も 夢見て<br>迄今为止 有数次 重新相信 有数次 梦见<br>何度も…<br>有数次…<br>今まで何度も バカを見てきたじゃないか<br>迄今为止 有数次 都是懊恼万分<br>今まで何度も 人のかげに立ってきたじゃないか<br>迄今为止 有数次 在逆境中成长<br>さぁ 主役だよ 自分の夢くらい わがままでいさせて</em><br></div>

<p>这就是坚强的意志 放任自己去追求心中的梦想吧<br><img src="/blogs/c784bcde/huoying.png" title="木叶十二小强集体照"></p>
<p>这首歌就是那时我对火影里人物的印象，一群无论有什么困难，无论失败多少次都能再次站起来追求梦想的人。没有转世什么的……<br>还有，那时的火影拯救了我。</p>
<h2 id="One-more-time-One-more-chance-——-《秒速五厘米》"><a href="#One-more-time-One-more-chance-——-《秒速五厘米》" class="headerlink" title="One more time, One more chance —— 《秒速五厘米》"></a>One more time, One more chance —— 《秒速五厘米》</h2>
    <div id="aplayer-sDXhEUVs" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="540968" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>
<div align="center"><br><em>呐，你知道吗？听说樱花飘落的速度是秒速五厘米哦</em><br></div>

<p>这首我觉得就不需要多说了。</p>
<h2 id="For-フルーツバスケット-——-《水果篮子》"><a href="#For-フルーツバスケット-——-《水果篮子》" class="headerlink" title="For フルーツバスケット —— 《水果篮子》"></a>For フルーツバスケット —— 《水果篮子》</h2>
    <div id="aplayer-HoXoRbsa" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="632485" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>
<p>记得是小时候应该星空卫视播放过，虽然我一点都不记得动画讲的什么，后来遇到这首歌，如此柔软的声音，我想动画里也一定有如此温柔的人吧。<br>直到现在我都没看这部动画，没有各种原因，只是觉得这首歌就够了，听了这首歌仿佛就能感受到动画里传达的感情。</p>
<div align="center"><em>たとえ苦しい今日だとしても<br>即使今天充满痛苦<br>いつかあたたかな想い出になる<br>总有一天 它会成为温馨的回忆<br>心ごとすべてなげだせたなら<br>只要我们的心被感动<br>ここに生きてる意味がわかるよ<br>我明白生存在这的意义<br>生まれおちた歓びを知る<br>也了解诞生于世的快乐<br>Let’s stay together いつも<br>让我们永远在一起</em><br></div>

<p>如此美丽的声音，却因癌症在04年离而消逝。</p>
<h2 id="secret-base-君がくれたもの-10-years-after-Ver-——-《未闻花名》"><a href="#secret-base-君がくれたもの-10-years-after-Ver-——-《未闻花名》" class="headerlink" title="secret base ~君がくれたもの~ (10 years after Ver.) —— 《未闻花名》"></a>secret base ~君がくれたもの~ (10 years after Ver.) —— 《未闻花名》</h2>
    <div id="aplayer-iiAmINMc" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="27674995" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>
<p>虽然这首歌不是动画原创，但是我觉得还是写上来吧。</p>
<div align="center"><em>最喜欢仁太了，是想成为仁太新娘的那种喜欢<br>面码，找到你了</em><br></div>

<p>催人泪下的剧情，加上这音乐，每到关键时刻这首歌就会响起，于是搞得眼泪在不停的在眼里打转。第一次感受到了音乐出现时机的重要性。</p>
<h2 id="あなたがいた森-曾有你的森林-——《Fate-Stay-night-》"><a href="#あなたがいた森-曾有你的森林-——《Fate-Stay-night-》" class="headerlink" title="あなたがいた森 (曾有你的森林)——《Fate/Stay night 》"></a>あなたがいた森 (曾有你的森林)——《Fate/Stay night 》</h2>
    <div id="aplayer-LCcfRTVF" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="448155" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>
<p>每次听到这首歌就想到吾王站在草原上杵着剑，微风吹过金发的样子，好美。</p>
<div align="center"><em>遵从召唤而来，我问你，你是我的Master吗?<br>贝狄威尔，不要露出这样的表情. 剑鞘正在治疗我的伤， 我不会就这样一睡不醒的.<br>抱歉贝狄威尔 这次我将会…睡得…久一点…</em><br></div>

<h2 id="God-knows-——-《凉宫春日的忧郁》"><a href="#God-knows-——-《凉宫春日的忧郁》" class="headerlink" title="God knows —— 《凉宫春日的忧郁》"></a>God knows —— 《凉宫春日的忧郁》</h2>
    <div id="aplayer-GWArzfcB" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="27876224" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>
<h2 id="いつもの風景-——-《凉宫春日的忧郁》"><a href="#いつもの風景-——-《凉宫春日的忧郁》" class="headerlink" title="いつもの風景 —— 《凉宫春日的忧郁》"></a>いつもの風景 —— 《凉宫春日的忧郁》</h2>
    <div id="aplayer-MAQsNtsJ" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="29849547" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>
<p>第一首相信不用多提，即使没看过凉宫，那个文化祭的演唱片段也一定会看过。最令我印象深刻的就是大明神的吉他了，我不懂音乐，但我就是觉得好听，厉害。从此越来越多的动画开起了演唱会，但令我无法忘记的只有这一个。<br>第二首如果看过凉宫一定不会陌生，它常常伴随着阿虚的吐槽出现。每当听到这首歌，都会想起阿虚那关于外星人的开场吐槽。心情大好。</p>
<h2 id="いのちの名前-——-《千与千寻》"><a href="#いのちの名前-——-《千与千寻》" class="headerlink" title="いのちの名前 —— 《千与千寻》"></a>いのちの名前 —— 《千与千寻》</h2>
    <div id="aplayer-DrCLGuyK" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="605745" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>
<div align="center"><br><em>不要吃得太胖哦 会被杀掉的</em><br></div><br>没记错的话这首歌在动画里只是插曲，且没有人声的。但是比起纯音乐的版本，我更喜欢这个有歌词的版本。没到那个听到这首歌<br>总能想起千寻倔强的要婆婆给她一份工作<br>想起千寻为河神洗澡时跌入淤泥里的样子<br>想起千寻对父母大喊不要吃太胖哦，会被杀掉的<br>想起千寻与无脸男在坐在海面上的火车缓缓前行和在车站上永远在等待的小女孩<br><div align="center"><em>不要忘记自己的名字，你就能找到回去的路</em><br></div>

<p>音乐这东西，好听不好听全凭个人喜好，<br><strong>讨厌可以有很多理由，但是喜欢就是喜欢，不需要什么理由</strong><br>只要这个音乐能打动你，能与你的心共鸣，就是好音乐。<br>我喜欢的音乐还有很多，我只是把我百听不厌的一部分写了出来。剩下没写的和未来喜欢的，就在未来某时某刻我再来补充吧。</p>
]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title>kaggle：泰坦尼克幸存者预测</title>
    <url>/blogs/f4fe8c7c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><img src="/blogs/f4fe8c7c/titanic-bg.jpg" title="泰坦尼克号">
<blockquote>
<p><em>泰坦尼克号是当时（1912年）世界上体积最庞大、内部设施最豪华的客运轮船，有“永不沉没”的美誉 。然而在首次航行中，泰坦尼克号与一座冰山相撞，逾1500人丧生，其中仅333具罹难者遗体被寻回。泰坦尼克号沉没事故为和平时期死伤人数最惨重的海难之一，其残骸直至1985年才被再度发现，目前受到联合国教育、科学及文化组织的保护。本次竞赛以此为背景，根据提供的乘客数据来预测这些乘客能否生还（当然真实的情况要比这复杂得多）。</em></p>
</blockquote>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.rcParams[<span class="string">'axes.unicode_minus'</span>]=<span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">titanic = pd.read_csv(<span class="string">r'E:\DataScience\ML\Titanic\train.csv'</span>)</span><br><span class="line"></span><br><span class="line">titanic_test = pd.read_csv(<span class="string">r'E:\DataScience\ML\Titanic\test.csv'</span>)</span><br><span class="line"></span><br><span class="line">titanic.head(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<div><style scoped>.dataframe tbody tr th:only-of-type {vertical-align: middle;}.dataframe tbody tr th {vertical-align: top;}.dataframe thead th {text-align: right;}</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>PassengerId</th><th>Survived</th><th>Pclass</th><th>Name</th><th>Sex</th><th>Age</th><th>SibSp</th><th>Parch</th><th>Ticket</th><th>Fare</th><th>Cabin</th><th>Embarked</th></tr></thead><tbody><tr><th>0</th><td>1</td><td>0</td><td>3</td><td>Braund, Mr. Owen Harris</td><td>male</td><td>22.0</td><td>1</td><td>0</td><td>A/5 21171</td><td>7.2500</td><td>NaN</td><td>S</td></tr><tr><th>1</th><td>2</td><td>1</td><td>1</td><td>Cumings, Mrs. John Bradley (Florence Briggs Th…</td><td>female</td><td>38.0</td><td>1</td><td>0</td><td>PC 17599</td><td>71.2833</td><td>C85</td><td>C</td></tr><tr><th>2</th><td>3</td><td>1</td><td>3</td><td>Heikkinen, Miss. Laina</td><td>female</td><td>26.0</td><td>0</td><td>0</td><td>STON/O2. 3101282</td><td>7.9250</td><td>NaN</td><td>S</td></tr><tr><th>3</th><td>4</td><td>1</td><td>1</td><td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td><td>female</td><td>35.0</td><td>1</td><td>0</td><td>113803</td><td>53.1000</td><td>C123</td><td>S</td></tr><tr><th>4</th><td>5</td><td>0</td><td>3</td><td>Allen, Mr. William Henry</td><td>male</td><td>35.0</td><td>0</td><td>0</td><td>373450</td><td>8.0500</td><td>NaN</td><td>S</td></tr><tr><th>5</th><td>6</td><td>0</td><td>3</td><td>Moran, Mr. James</td><td>male</td><td>NaN</td><td>0</td><td>0</td><td>330877</td><td>8.4583</td><td>NaN</td><td>Q</td></tr><tr><th>6</th><td>7</td><td>0</td><td>1</td><td>McCarthy, Mr. Timothy J</td><td>male</td><td>54.0</td><td>0</td><td>0</td><td>17463</td><td>51.8625</td><td>E46</td><td>S</td></tr><tr><th>7</th><td>8</td><td>0</td><td>3</td><td>Palsson, Master. Gosta Leonard</td><td>male</td><td>2.0</td><td>3</td><td>1</td><td>349909</td><td>21.0750</td><td>NaN</td><td>S</td></tr><tr><th>8</th><td>9</td><td>1</td><td>3</td><td>Johnson, Mrs. Oscar W (Elisabeth Vilhelmina Berg)</td><td>female</td><td>27.0</td><td>0</td><td>2</td><td>347742</td><td>11.1333</td><td>NaN</td><td>S</td></tr><tr><th>9</th><td>10</td><td>1</td><td>2</td><td>Nasser, Mrs. Nicholas (Adele Achem)</td><td>female</td><td>14.0</td><td>1</td><td>0</td><td>237736</td><td>30.0708</td><td>NaN</td><td>C</td></tr></tbody></table></div>

<table>
<thead>
<tr>
<th style="text-align:center">单词</th>
<th style="text-align:right">翻译</th>
<th style="text-align:center">Key</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">survival</td>
<td style="text-align:right">是否幸存</td>
<td style="text-align:center">0 = No, 1 = Yes</td>
</tr>
<tr>
<td style="text-align:center">pclass</td>
<td style="text-align:right">社会阶层</td>
<td style="text-align:center">1 = 精英, 2 = 中层 , 3 = 普通民众</td>
</tr>
<tr>
<td style="text-align:center">sex</td>
<td style="text-align:right">性别</td>
</tr>
<tr>
<td style="text-align:center">Age</td>
<td style="text-align:right">年龄</td>
</tr>
<tr>
<td style="text-align:center">sibsp</td>
<td style="text-align:right">船上兄弟/姐妹的个数</td>
</tr>
<tr>
<td style="text-align:center">parch</td>
<td style="text-align:right">船上父母/孩子的个数</td>
</tr>
<tr>
<td style="text-align:center">ticket</td>
<td style="text-align:right">船票号</td>
</tr>
<tr>
<td style="text-align:center">fare</td>
<td style="text-align:right">船票价格</td>
</tr>
<tr>
<td style="text-align:center">cabin</td>
<td style="text-align:right">船舱号码</td>
</tr>
<tr>
<td style="text-align:center">embarked</td>
<td style="text-align:right">登船口</td>
<td style="text-align:center">C = Cherbourg, Q = Queenstown, S = Southampton</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看数据简单的统计</span></span><br><span class="line"></span><br><span class="line">titanic.describe()</span><br></pre></td></tr></table></figure>
<div> <style scoped> .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } </style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>PassengerId</th> <th>Survived</th> <th>Pclass</th> <th>Age</th> <th>SibSp</th> <th>Parch</th> <th>Fare</th> </tr> </thead> <tbody> <tr> <th>count</th> <td>891.000000</td> <td>891.000000</td> <td>891.000000</td> <td>714.000000</td> <td>891.000000</td> <td>891.000000</td> <td>891.000000</td> </tr> <tr> <th>mean</th> <td>446.000000</td> <td>0.383838</td> <td>2.308642</td> <td>29.699118</td> <td>0.523008</td> <td>0.381594</td> <td>32.204208</td> </tr> <tr> <th>std</th> <td>257.353842</td> <td>0.486592</td> <td>0.836071</td> <td>14.526497</td> <td>1.102743</td> <td>0.806057</td> <td>49.693429</td> </tr> <tr> <th>min</th> <td>1.000000</td> <td>0.000000</td> <td>1.000000</td> <td>0.420000</td> <td>0.000000</td> <td>0.000000</td> <td>0.000000</td> </tr> <tr> <th>25%</th> <td>223.500000</td> <td>0.000000</td> <td>2.000000</td> <td>20.125000</td> <td>0.000000</td> <td>0.000000</td> <td>7.910400</td> </tr> <tr> <th>50%</th> <td>446.000000</td> <td>0.000000</td> <td>3.000000</td> <td>28.000000</td> <td>0.000000</td> <td>0.000000</td> <td>14.454200</td> </tr> <tr> <th>75%</th> <td>668.500000</td> <td>1.000000</td> <td>3.000000</td> <td>38.000000</td> <td>1.000000</td> <td>0.000000</td> <td>31.000000</td> </tr> <tr> <th>max</th> <td>891.000000</td> <td>1.000000</td> <td>3.000000</td> <td>80.000000</td> <td>8.000000</td> <td>6.000000</td> <td>512.329200</td> </tr> </tbody> </table> </div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看数据概要</span></span><br><span class="line"></span><br><span class="line">titanic.info()</span><br></pre></td></tr></table></figure>
<pre><code>&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;
RangeIndex: 891 entries, 0 to 890
Data columns (total 12 columns):
PassengerId    891 non-null int64
Survived       891 non-null int64
Pclass         891 non-null int64
Name           891 non-null object
Sex            891 non-null object
Age            714 non-null float64
SibSp          891 non-null int64
Parch          891 non-null int64
Ticket         891 non-null object
Fare           891 non-null float64
Cabin          204 non-null object
Embarked       889 non-null object
dtypes: float64(2), int64(5), object(5)
memory usage: 83.6+ KB
</code></pre><p>从上可以看出，Age,Cabin,Fare,Embarked几个特征存在空值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计空值</span></span><br><span class="line"></span><br><span class="line">print(titanic.isnull().sum())</span><br></pre></td></tr></table></figure>
<pre><code>PassengerId      0
Survived         0
Pclass           0
Name             0
Sex              0
Age            177
SibSp            0
Parch            0
Ticket           0
Fare             0
Cabin          687
Embarked         2
dtype: int64
</code></pre><h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><h3 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以填充整个dataframe的空值</span></span><br><span class="line"><span class="comment"># titanic.fillna(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以单独填充一列</span></span><br><span class="line"><span class="comment"># titanic.Age.fillna(0)</span></span><br><span class="line"></span><br><span class="line">titanic.Age.fillna(<span class="number">-30</span>, inplace=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看为空的数据</span></span><br><span class="line">titanic.isnull().sum()</span><br></pre></td></tr></table></figure>
<pre><code>PassengerId      0
Survived         0
Pclass           0
Name             0
Sex              0
Age              0
SibSp            0
Parch            0
Ticket           0
Fare             0
Cabin          687
Embarked         2
dtype: int64
</code></pre><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><h3 id="性别Sex对生还与否的影响"><a href="#性别Sex对生还与否的影响" class="headerlink" title="性别Sex对生还与否的影响"></a>性别Sex对生还与否的影响</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 做简单是汇总统计</span></span><br><span class="line">titanic.groupby([<span class="string">'Sex'</span>,<span class="string">'Survived'</span>])[<span class="string">'Survived'</span>].count()</span><br></pre></td></tr></table></figure>
<pre><code>Sex     Survived
female  0            81
        1           233
male    0           468
        1           109
Name: Survived, dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生还率统计</span></span><br><span class="line"></span><br><span class="line">df_sex = titanic[[<span class="string">'Sex'</span>,<span class="string">'Survived'</span>]].groupby([<span class="string">'Sex'</span>]).mean()</span><br><span class="line">df_sex</span><br></pre></td></tr></table></figure>
<div> <style scoped> .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } </style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>Survived</th> </tr> <tr> <th>Sex</th> <th></th> </tr> </thead> <tbody> <tr> <th>female</th> <td>0.742038</td> </tr> <tr> <th>male</th> <td>0.188908</td> </tr> </tbody> </table> </div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制柱状图</span></span><br><span class="line"></span><br><span class="line">df_sex.plot(kind=<span class="string">'bar'</span>,</span><br><span class="line">            figsize=(<span class="number">8</span>,<span class="number">6</span>),</span><br><span class="line">            rot=<span class="number">0</span>,</span><br><span class="line">            fontsize=<span class="number">18</span>,</span><br><span class="line">            stacked=<span class="keyword">True</span>)</span><br><span class="line">plt.grid(<span class="keyword">True</span>, linestyle=<span class="string">'--'</span>)</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_14_0.png" title="p2">
<p><strong> 从上面可以发现，事实是与男性比女性的生存能力更强的经验常识相悖的，可以推测Lady First起到了很大的作用 </strong></p>
<h3 id="社会阶层-Pclass与生还与否的关系"><a href="#社会阶层-Pclass与生还与否的关系" class="headerlink" title="社会阶层 Pclass与生还与否的关系"></a>社会阶层 Pclass与生还与否的关系</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计</span></span><br><span class="line">titanic.groupby([<span class="string">'Pclass'</span>, <span class="string">'Survived'</span>])[<span class="string">'Pclass'</span>].count()</span><br></pre></td></tr></table></figure>
<pre><code>Pclass  Survived
1       0            80
        1           136
2       0            97
        1            87
3       0           372
        1           119
Name: Pclass, dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_pclass = titanic[[<span class="string">'Pclass'</span>, <span class="string">'Survived'</span>]].groupby([<span class="string">'Pclass'</span>]).mean()</span><br><span class="line">df_pclass</span><br></pre></td></tr></table></figure>
<div> <style scoped> .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } </style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>Survived</th> </tr> <tr> <th>Pclass</th> <th></th> </tr> </thead> <tbody> <tr> <th>1</th> <td>0.629630</td> </tr> <tr> <th>2</th> <td>0.472826</td> </tr> <tr> <th>3</th> <td>0.242363</td> </tr> </tbody> </table> </div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制柱状图</span></span><br><span class="line"></span><br><span class="line">df_pclass.plot(kind=<span class="string">'bar'</span>,</span><br><span class="line">               rot=<span class="number">0</span>,</span><br><span class="line">               fontsize=<span class="number">18</span>,</span><br><span class="line">               figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_20_0.png" title="p3">
<p>可以看到，等级越高的人，生存几率越大，那么ladyfirst能否跨越等级界限呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_psex = titanic[[<span class="string">'Pclass'</span>, <span class="string">'Sex'</span>, <span class="string">'Survived'</span>]].groupby([<span class="string">'Pclass'</span>, <span class="string">'Sex'</span>]).mean()</span><br><span class="line">df_psex</span><br></pre></td></tr></table></figure>
<div> <style scoped> .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } </style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th></th> <th>Survived</th> </tr> <tr> <th>Pclass</th> <th>Sex</th> <th></th> </tr> </thead> <tbody> <tr> <th rowspan="2" valign="top">1</th> <th>female</th> <td>0.968085</td> </tr> <tr> <th>male</th> <td>0.368852</td> </tr> <tr> <th rowspan="2" valign="top">2</th> <th>female</th> <td>0.921053</td> </tr> <tr> <th>male</th> <td>0.157407</td> </tr> <tr> <th rowspan="2" valign="top">3</th> <th>female</th> <td>0.500000</td> </tr> <tr> <th>male</th> <td>0.135447</td> </tr> </tbody> </table> </div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_psex.plot(kind=<span class="string">'bar'</span>,</span><br><span class="line">             rot=<span class="number">0</span>,</span><br><span class="line">             fontsize=<span class="number">12</span>,</span><br><span class="line">             figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_23_0.png" title="p4">
<p>可以看到，ladyfirst确实跨越了社会等级界限，普通阶层的女性的生还率都高于精英阶层的男性生还率。<br>不过，无法忽视的是，不同等级的生还率还是有一定区别的。</p>
<h3 id="年龄Age对生还与否的影响"><a href="#年龄Age对生还与否的影响" class="headerlink" title="年龄Age对生还与否的影响"></a>年龄Age对生还与否的影响</h3><p>绘图分析不同阶层和不同性别下的年龄分布情况以及与生还的关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘图分析不同阶层和不同性别下的年龄分布情况以及与生还的关系</span></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">18</span>,<span class="number">8</span>))</span><br><span class="line">sns.violinplot(<span class="string">'Pclass'</span>,<span class="string">'Age'</span>, hue=<span class="string">'Survived'</span>, data=titanic, split=<span class="keyword">True</span>, ax=ax[<span class="number">0</span>])</span><br><span class="line">ax[<span class="number">0</span>].set_title(<span class="string">'Pclass and Age  vs  Survived'</span>,size=<span class="number">18</span>)</span><br><span class="line">ax[<span class="number">0</span>].set_yticks(range(<span class="number">0</span>, <span class="number">110</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">sns.violinplot(<span class="string">"Sex"</span>, <span class="string">"Age"</span>, hue=<span class="string">"Survived"</span>, data=titanic, split=<span class="keyword">True</span>, ax=ax[<span class="number">1</span>])</span><br><span class="line">ax[<span class="number">1</span>].set_title(<span class="string">'Sex and Age  vs  Survived'</span>,size=<span class="number">18</span>)</span><br><span class="line">ax[<span class="number">1</span>].set_yticks(range(<span class="number">0</span>, <span class="number">110</span>, <span class="number">10</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_27_0.png" title="p5">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计总体的年龄分布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">titanic[<span class="string">'Age'</span>].hist(bins=<span class="number">20</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Num'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">titanic.boxplot(column=<span class="string">'Age'</span>, showfliers=<span class="keyword">False</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_28_0.png" title="p6">
<p>因为年龄缺失值填充的问题，所以中间高出很多</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">page = sns.FacetGrid(titanic, hue=<span class="string">"Survived"</span>,aspect=<span class="number">4</span>)</span><br><span class="line">page.map(sns.kdeplot,<span class="string">'Age'</span>,shade= <span class="keyword">True</span>)</span><br><span class="line">page.set(xlim=(<span class="number">-40</span>, titanic[<span class="string">'Age'</span>].max()))</span><br><span class="line">page.add_legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_30_0.png" title="p7">
<p>可以看到，孩子和中年人更容易获救。那么规则就是 <strong>lady and children first</strong>，缺省值中死亡更多<br>所以无法统计到年龄</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f, ax = plt.subplots(figsize=(<span class="number">8</span>,<span class="number">3</span>))</span><br><span class="line">ax.set_title(<span class="string">'Sex Age dist'</span>, size=<span class="number">20</span>)</span><br><span class="line">sns.distplot(titanic[titanic.Sex==<span class="string">'female'</span>].dropna().Age, hist=<span class="keyword">False</span>, color=<span class="string">'pink'</span>, label=<span class="string">'female'</span>)</span><br><span class="line">sns.distplot(titanic[titanic.Sex==<span class="string">'male'</span>].dropna().Age, hist=<span class="keyword">False</span>, color=<span class="string">'blue'</span>, label=<span class="string">'male'</span>)</span><br><span class="line">ax.legend(fontsize=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_32_0.png" title="p8">
<p>可以看到，女性更加年轻些，孩子和中老年人中男性更多</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f, ax = plt.subplots(figsize=(<span class="number">8</span>,<span class="number">3</span>))</span><br><span class="line">ax.set_title(<span class="string">'Pclass Age dist'</span>, size=<span class="number">20</span>)</span><br><span class="line">sns.distplot(titanic[titanic.Pclass==<span class="number">1</span>].dropna().Age, hist=<span class="keyword">False</span>, color=<span class="string">'pink'</span>, label=<span class="string">'P1'</span>,rug=<span class="keyword">True</span>)</span><br><span class="line">sns.distplot(titanic[titanic.Pclass==<span class="number">2</span>].dropna().Age, hist=<span class="keyword">False</span>, color=<span class="string">'blue'</span>, label=<span class="string">'p2'</span>,rug=<span class="keyword">True</span>)</span><br><span class="line">sns.distplot(titanic[titanic.Pclass==<span class="number">3</span>].dropna().Age, hist=<span class="keyword">False</span>, color=<span class="string">'g'</span>, label=<span class="string">'p3'</span>,rug=<span class="keyword">True</span>)</span><br><span class="line">ax.legend(fontsize=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_34_0.png" title="p9">
<p>阶层越高，年纪更老龄化</p>
<h3 id="有无兄弟姐妹-SibSp-对生还与否的影响"><a href="#有无兄弟姐妹-SibSp-对生还与否的影响" class="headerlink" title="有无兄弟姐妹 SibSp 对生还与否的影响"></a>有无兄弟姐妹 SibSp 对生还与否的影响</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先将数据分为有兄弟姐妹和没有兄弟姐妹两组</span></span><br><span class="line"></span><br><span class="line">df_sibsp = titanic[titanic[<span class="string">'SibSp'</span>] != <span class="number">0</span>]</span><br><span class="line">df_sibsp_no = titanic[titanic[<span class="string">'SibSp'</span>] == <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">6</span>))</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">df_sibsp[<span class="string">'Survived'</span>].value_counts().plot(kind=<span class="string">'pie'</span>,labels=[<span class="string">'No Survived'</span>, <span class="string">'Survived'</span>], autopct = <span class="string">'%1.1f%%'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'sibsp'</span>,fontsize=<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">df_sibsp_no[<span class="string">'Survived'</span>].value_counts().plot(kind=<span class="string">'pie'</span>,labels=[<span class="string">'No Survived'</span>, <span class="string">'Survived'</span>], autopct = <span class="string">'%1.1f%%'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'sibsp_no'</span>,fontsize=<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_38_0.png" title="p10">
<p>有了兄弟姐妹的帮助，似乎更能在险境中存活</p>
<h3 id="有无父母孩子-Parch-对生还与否的影响"><a href="#有无父母孩子-Parch-对生还与否的影响" class="headerlink" title="有无父母孩子 Parch 对生还与否的影响"></a>有无父母孩子 Parch 对生还与否的影响</h3><p>方法同上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照有无父母孩子分组</span></span><br><span class="line">df_parch = titanic[titanic[<span class="string">'Parch'</span>] != <span class="number">0</span>]</span><br><span class="line">df_parch_no = titanic[titanic[<span class="string">'Parch'</span>] == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">6</span>))</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">df_sibsp[<span class="string">'Survived'</span>].value_counts().plot(kind=<span class="string">'pie'</span>,labels=[<span class="string">'No Survived'</span>, <span class="string">'Survived'</span>], autopct = <span class="string">'%1.1f%%'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Parch'</span>,fontsize=<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">df_sibsp_no[<span class="string">'Survived'</span>].value_counts().plot(kind=<span class="string">'pie'</span>,labels=[<span class="string">'No Survived'</span>, <span class="string">'Survived'</span>], autopct = <span class="string">'%1.1f%%'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Parch_no'</span>,fontsize=<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_41_0.png" title="p11">
<p>从之前的分析中知道，孩子是特殊照顾的对象，而孩子一般是有父母跟随的。即使都是成年人，互相帮助存活概率也更高。</p>
<h3 id="亲人数量对生还与否的影响"><a href="#亲人数量对生还与否的影响" class="headerlink" title="亲人数量对生还与否的影响"></a>亲人数量对生还与否的影响</h3><p>是否亲人越多，生还可能性越大呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig,ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">12</span>,<span class="number">8</span>))</span><br><span class="line">titanic[[<span class="string">'Parch'</span>,<span class="string">'Survived'</span>]].groupby([<span class="string">'Parch'</span>]).mean().plot(kind=<span class="string">'bar'</span>,ax=ax[<span class="number">0</span>])</span><br><span class="line">ax[<span class="number">0</span>].set_title(<span class="string">'Parch and Survived'</span>)</span><br><span class="line"></span><br><span class="line">titanic[[<span class="string">'SibSp'</span>,<span class="string">'Survived'</span>]].groupby([<span class="string">'SibSp'</span>]).mean().plot.bar(ax=ax[<span class="number">1</span>])</span><br><span class="line">ax[<span class="number">1</span>].set_title(<span class="string">'SibSp and Survived'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_44_0.png" title="p12">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">titanic[<span class="string">'fam_size'</span>] = titanic[<span class="string">'SibSp'</span>] + titanic[<span class="string">'Parch'</span>] + <span class="number">1</span></span><br><span class="line">titanic[[<span class="string">'fam_size'</span>,<span class="string">'Survived'</span>]].groupby([<span class="string">'fam_size'</span>]).mean().plot.bar(figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_45_0.png" title="p13">
<p>从上可以看出，家庭成员在1-4人生还率最高，推测应该是这样正好组成了可以互帮互助，行动又不臃肿从小组。<br>而后面7人家庭成员的存活率上升，推测应该是人数上升后，至少存活一人的概率增加。</p>
<h3 id="票价-Fare-对生还与否的影响"><a href="#票价-Fare-对生还与否的影响" class="headerlink" title="票价 Fare 对生还与否的影响"></a>票价 Fare 对生还与否的影响</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制票价分布图</span></span><br><span class="line">titanic[<span class="string">'Fare'</span>].plot(kind=<span class="string">'hist'</span>,bins=<span class="number">100</span>,figsize=(<span class="number">10</span>,<span class="number">6</span>), grid=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">titanic.boxplot(column=<span class="string">'Fare'</span>, by=<span class="string">'Pclass'</span>,showfliers=<span class="keyword">False</span>,figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_48_0.png" title="p14">
<img src="/blogs/f4fe8c7c/output_48_1.png" title="p15">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">titanic[<span class="string">'Fare'</span>].describe()</span><br></pre></td></tr></table></figure>
<pre><code>count    891.000000
mean      32.204208
std       49.693429
min        0.000000
25%        7.910400
50%       14.454200
75%       31.000000
max      512.329200
Name: Fare, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制生还者非生还者票价分析</span></span><br><span class="line">titanic.boxplot(column=<span class="string">'Fare'</span>, by=<span class="string">'Survived'</span>,showfliers=<span class="keyword">False</span>,showmeans=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_50_1.png" title="p15">
<p>可以看到，幸存者的票价普遍更高，符合之前阶层越高，生还几率越大的推测</p>
<h3 id="船舱号码-Cabin-对生还与否的影响"><a href="#船舱号码-Cabin-对生还与否的影响" class="headerlink" title="船舱号码 Cabin 对生还与否的影响"></a>船舱号码 Cabin 对生还与否的影响</h3><p>按照查询的资料，我认为乘客所处的船舱应该是跟是否生还有很大关系的，特别是下层的乘客，下部船舱快速进水，通向甲板的路不难想象也是混作一团，这就大大减少了生还可能。但是，此字段缺失数据多达600多个，所以只做下简单的数据分析。（不过我认为，票价和船舱应该有对应关系，如果能知道票价与船舱对应的史料就最好了）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">titanic.Cabin.isnull().value_counts()</span><br></pre></td></tr></table></figure>
<pre><code>True     687
False    204
Name: Cabin, dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">titanic.groupby(by=titanic.Cabin.isnull())[<span class="string">'Survived'</span>].mean()</span><br></pre></td></tr></table></figure>
<pre><code>Cabin
False    0.666667
True     0.299854
Name: Survived, dtype: float64
</code></pre><p>由上可知，缺失值的生存率很低，那么可以将<strong>Cabin是否为空</strong>作为一个特征！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">titanic[<span class="string">'Cabin_fir'</span>] = titanic.Cabin.fillna(<span class="string">'0'</span>).str.split(<span class="string">' '</span>).apply(<span class="keyword">lambda</span> x: x[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">df_cabin_fir = titanic.groupby(by=<span class="string">'Cabin_fir'</span>)[<span class="string">'Survived'</span>].mean()</span><br><span class="line">print(df_cabin_fir)</span><br><span class="line"></span><br><span class="line">df_cabin_fir.plot(kind=<span class="string">'bar'</span>,</span><br><span class="line">                 rot=<span class="number">0</span>,</span><br><span class="line">                 legend=<span class="keyword">True</span>,figsize=(<span class="number">10</span>,<span class="number">8</span>),</span><br><span class="line">                 fontsize=<span class="number">12</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<pre><code>Cabin_fir
0    0.299854
A    0.466667
B    0.744681
C    0.593220
D    0.757576
E    0.750000
F    0.615385
G    0.500000
T    0.000000
Name: Survived, dtype: float64
</code></pre><img src="/blogs/f4fe8c7c/output_56_1.png" title="p16">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_cabin_fare = titanic.groupby(by=<span class="string">'Cabin_fir'</span>)[<span class="string">'Fare'</span>,<span class="string">'Survived'</span>].mean()</span><br><span class="line">df_cabin_fare</span><br></pre></td></tr></table></figure>
<div> <style scoped> .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } </style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>Fare</th> <th>Survived</th> </tr> <tr> <th>Cabin_fir</th> <th></th> <th></th> </tr> </thead> <tbody> <tr> <th>0</th> <td>19.157325</td> <td>0.299854</td> </tr> <tr> <th>A</th> <td>39.623887</td> <td>0.466667</td> </tr> <tr> <th>B</th> <td>113.505764</td> <td>0.744681</td> </tr> <tr> <th>C</th> <td>100.151341</td> <td>0.593220</td> </tr> <tr> <th>D</th> <td>57.244576</td> <td>0.757576</td> </tr> <tr> <th>E</th> <td>46.026694</td> <td>0.750000</td> </tr> <tr> <th>F</th> <td>18.696792</td> <td>0.615385</td> </tr> <tr> <th>G</th> <td>13.581250</td> <td>0.500000</td> </tr> <tr> <th>T</th> <td>35.500000</td> <td>0.000000</td> </tr> </tbody> </table> </div>

<p>在有记录的乘客中，可以发现，BC舱位总统套间，掏钱最多，DE为贵宾舱，费用中等，其余为普通舱。生还率大致符合阶层的情况。至于为何C舱生还率<br>低于BDE，暂不分析，推测应该与所处舱位位置不佳，男性占比大，年龄偏大有关。</p>
<h3 id="登船地点-Embarked-对生还与否的影响"><a href="#登船地点-Embarked-对生还与否的影响" class="headerlink" title="登船地点 Embarked 对生还与否的影响"></a>登船地点 Embarked 对生还与否的影响</h3><blockquote>
<p>泰坦尼克号从英国南安普敦出发，途经法国瑟堡-奥克特维尔以及爱尔兰昆士敦 —— 百度百科</p>
</blockquote>
<p>南安普顿对应 S = Southampton， 瑟堡-奥克特维尔对应 C = Cherbourg，昆士敦对应 Q = Queenstown</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">titanic.groupby(by=<span class="string">'Embarked'</span>)[<span class="string">'Survived'</span>].mean().plot(kind=<span class="string">'bar'</span>, rot=<span class="number">0</span>, fontsize=<span class="number">15</span>, legend=<span class="keyword">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_61_0.png" title="p17">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_embarked = titanic.groupby(by=<span class="string">'Embarked'</span>)[<span class="string">'Survived'</span>,<span class="string">'Fare'</span>].agg([<span class="string">'mean'</span>, <span class="string">'count'</span>])</span><br><span class="line">df_embarked</span><br></pre></td></tr></table></figure>
<div> <style scoped> .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead tr th { text-align: left; }  .dataframe thead tr:last-of-type th { text-align: right; } </style> <table border="1" class="dataframe"> <thead> <tr> <th></th> <th colspan="2" halign="left">Survived</th> <th colspan="2" halign="left">Fare</th> </tr> <tr> <th></th> <th>mean</th> <th>count</th> <th>mean</th> <th>count</th> </tr> <tr> <th>Embarked</th> <th></th> <th></th> <th></th> <th></th> </tr> </thead> <tbody> <tr> <th>C</th> <td>0.553571</td> <td>168</td> <td>59.954144</td> <td>168</td> </tr> <tr> <th>Q</th> <td>0.389610</td> <td>77</td> <td>13.276030</td> <td>77</td> </tr> <tr> <th>S</th> <td>0.336957</td> <td>644</td> <td>27.079812</td> <td>644</td> </tr> </tbody> </table> </div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax = plt.figure(figsize=(<span class="number">10</span>,<span class="number">6</span>)).add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.set_xlim([<span class="number">-40</span>, <span class="number">80</span>])</span><br><span class="line">sns.kdeplot(titanic[titanic.Embarked==<span class="string">'C'</span>].Age, ax=ax, label=<span class="string">'C'</span>)</span><br><span class="line">sns.kdeplot(titanic[titanic.Embarked==<span class="string">'Q'</span>].Age, ax=ax, label=<span class="string">'Q'</span>)</span><br><span class="line">sns.kdeplot(titanic[titanic.Embarked==<span class="string">'S'</span>].Age, ax=ax, label=<span class="string">'S'</span>)</span><br><span class="line">ax.legend(fontsize=<span class="number">18</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_63_0.png" title="p18">
<p>C和S上岸的乘客的年龄分布较为相似，Q上岸的人很多没有年龄。<br>C和S比较，C口岸的人中有更多的孩子和老人</p>
<h3 id="名字-Name-对生还与否的影响"><a href="#名字-Name-对生还与否的影响" class="headerlink" title="名字 Name 对生还与否的影响\"></a>名字 Name 对生还与否的影响\</h3><p>通过对名字该字段的初步观察，发现名字中不但透漏出性别，还代表着一个人的地位，年龄，职业等<br>比如Master，Miss等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 称谓统计</span></span><br><span class="line">titanic[<span class="string">'Title'</span>] = titanic.Name.apply(<span class="keyword">lambda</span> x: x.split(<span class="string">','</span>)[<span class="number">1</span>].split(<span class="string">'.'</span>)[<span class="number">0</span>])</span><br><span class="line">titanic[<span class="string">'Title'</span>].value_counts()</span><br></pre></td></tr></table></figure>
<pre><code> Mr              517
 Miss            182
 Mrs             125
 Master           40
 Dr                7
 Rev               6
 Mlle              2
 Major             2
 Col               2
 the Countess      1
 Don               1
 Jonkheer          1
 Mme               1
 Capt              1
 Sir               1
 Lady              1
 Ms                1
Name: Title, dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 姓氏统计</span></span><br><span class="line">titanic.Name.apply(<span class="keyword">lambda</span> x: x.split(<span class="string">','</span>)[<span class="number">1</span>].split(<span class="string">'.'</span>)[<span class="number">1</span>]).value_counts()[:<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<pre><code> John             9
 James            7
 Mary             6
 William          6
 William Henry    4
 Bertha           4
 Ivan             4
 William John     4
 Samuel           3
 Patrick          3
Name: Name, dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">titanic[[<span class="string">'Title'</span>,<span class="string">'Survived'</span>]].groupby([<span class="string">'Title'</span>]).mean()</span><br></pre></td></tr></table></figure>
<div> <style scoped> .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } </style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>Survived</th> </tr> <tr> <th>Title</th> <th></th> </tr> </thead> <tbody> <tr> <th>Capt</th> <td>0.000000</td> </tr> <tr> <th>Col</th> <td>0.500000</td> </tr> <tr> <th>Don</th> <td>0.000000</td> </tr> <tr> <th>Dr</th> <td>0.428571</td> </tr> <tr> <th>Jonkheer</th> <td>0.000000</td> </tr> <tr> <th>Lady</th> <td>1.000000</td> </tr> <tr> <th>Major</th> <td>0.500000</td> </tr> <tr> <th>Master</th> <td>0.575000</td> </tr> <tr> <th>Miss</th> <td>0.697802</td> </tr> <tr> <th>Mlle</th> <td>1.000000</td> </tr> <tr> <th>Mme</th> <td>1.000000</td> </tr> <tr> <th>Mr</th> <td>0.156673</td> </tr> <tr> <th>Mrs</th> <td>0.792000</td> </tr> <tr> <th>Ms</th> <td>1.000000</td> </tr> <tr> <th>Rev</th> <td>0.000000</td> </tr> <tr> <th>Sir</th> <td>1.000000</td> </tr> <tr> <th>the Countess</th> <td>1.000000</td> </tr> </tbody> </table> </div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不同称呼的生存率统计</span></span><br><span class="line">titanic[[<span class="string">'Title'</span>,<span class="string">'Survived'</span>]].groupby([<span class="string">'Title'</span>]).mean().plot.bar(rot=<span class="number">45</span>, figsize=(<span class="number">15</span>,<span class="number">6</span>), fontsize=<span class="number">12</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_69_0.png" title="p19">
<p>可以看到，称谓确实与获救率有关，以为称谓往往与人的性别，地位有关。</p>
<p>换个角度，我们知道，歪果仁的名字中通常会加入家族名字，爵位等，所以是不是名字越长就越能像是一个家族的历史和地位呢？<strong>那么名字的长短是否能够显示出人的地位从而影响到是否获救？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">titanic[<span class="string">'name_len'</span>] = titanic[<span class="string">'Name'</span>].apply(len)</span><br><span class="line">df_namelen = titanic[[<span class="string">'name_len'</span>,<span class="string">'Survived'</span>]].groupby([<span class="string">'name_len'</span>],as_index=<span class="keyword">False</span>).mean()</span><br><span class="line">df_namelen.plot.bar(x=<span class="string">'name_len'</span>,y=<span class="string">'Survived'</span>,figsize=(<span class="number">18</span>,<span class="number">6</span>),rot=<span class="number">0</span>,colormap=<span class="string">'Blues_r'</span>,alpha=<span class="number">0.6</span>,fontsize=<span class="number">12</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_71_0.png" title="p20">
<p>看来猜想是正确的，名字的长度确实与是否获救有一定关系</p>
<h3 id="Ticket"><a href="#Ticket" class="headerlink" title="Ticket"></a>Ticket</h3><p>类别比较大，观察可以发现，票号开头应该代表着船舱区域，故提取分析</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">titanic[<span class="string">'Ticket_Lett'</span>] = titanic[<span class="string">'Ticket'</span>].apply(<span class="keyword">lambda</span> x: str(x)[<span class="number">0</span>])</span><br><span class="line">titanic[<span class="string">'Ticket_Lett'</span>] = titanic[<span class="string">'Ticket_Lett'</span>].apply(<span class="keyword">lambda</span> x: str(x))</span><br><span class="line">titanic.groupby(titanic[<span class="string">'Ticket_Lett'</span>])[<span class="string">'Survived'</span>].mean()</span><br></pre></td></tr></table></figure>
<pre><code>Ticket_Lett
1    0.630137
2    0.464481
3    0.239203
4    0.200000
5    0.000000
6    0.166667
7    0.111111
8    0.000000
9    1.000000
A    0.068966
C    0.340426
F    0.571429
L    0.250000
P    0.646154
S    0.323077
W    0.153846
Name: Survived, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">titanic.groupby(titanic[<span class="string">'Ticket_Lett'</span>])[<span class="string">'Survived'</span>].mean().plot.bar(rot=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<img src="/blogs/f4fe8c7c/output_75_1.png" title="p21">
<p>可以看到，船票不同开头的生存率不同，可以作为一个特征</p>
<p>通过以上的分析，我们发现，乘客获救与否，与多种因素有关。包括性别，年龄，阶级等。在这大灾难面前，强壮的男人死亡率反常的高，而女人和孩子反而更易存活，这不正常，但也是正常的，这应该就是文明发展的结果。</p>
<p>那么，如果你当时在泰坦尼克上，你是否会成功获救呢？下篇文章，将通过机器学习算法，来预测另一批乘客是否会活下来。</p>
<h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><h3 id="变量转换"><a href="#变量转换" class="headerlink" title="变量转换"></a>变量转换</h3><blockquote>
<p>变量转换的目的是将数据转换为适用于模型使用的数据，不同模型接受不同类型的数据，<strong>Scikit-learn要求数据都是数字型numeric</strong>，所以我们要将一些非数字型的原始数据转换为数字型numeric</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBClassifier</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.chdir(<span class="string">'E:\DataScience\ML\Titanic'</span>)</span><br><span class="line">data_train = pd.read_csv(<span class="string">'train.csv'</span>)</span><br><span class="line">data_test = pd.read_csv(<span class="string">'test.csv'</span>)</span><br><span class="line">combine = pd.concat([data_train,data_test])</span><br></pre></td></tr></table></figure>
<p>对数据进行特征工程，也就是从各项参数中提取出对输出结果有或大或小的影响的特征，将这些特征作为训练模型的依据。 一般来说，我们会先从含有缺失值的特征开始</p>
<h3 id="Embarked"><a href="#Embarked" class="headerlink" title="Embarked"></a>Embarked</h3><p>因为该项的缺失值没几个，所以这里我们以众数来填充：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 缺失值填充，众数为 S</span></span><br><span class="line">combine[<span class="string">'Embarked'</span>] = combine[<span class="string">'Embarked'</span>].fillna(<span class="string">'S'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dummy处理</span></span><br><span class="line">df = pd.get_dummies(combine[<span class="string">'Embarked'</span>], prefix=<span class="string">'Embarked'</span>)</span><br><span class="line">combine = pd.concat([combine, df], axis=<span class="number">1</span>).drop(<span class="string">'Embarked'</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Name-length"><a href="#Name-length" class="headerlink" title="Name_length"></a>Name_length</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combine[<span class="string">'Name_length'</span>] = combine[<span class="string">'Name'</span>].apply(len)</span><br></pre></td></tr></table></figure>
<h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combine[<span class="string">'Title'</span>] = combine[<span class="string">'Name'</span>].apply(<span class="keyword">lambda</span> x: x.split(<span class="string">','</span>)[<span class="number">1</span>]).apply(<span class="keyword">lambda</span> x:x.split(<span class="string">'.'</span>)[<span class="number">0</span>])</span><br><span class="line">combine[<span class="string">'Title'</span>] = combine[<span class="string">'Title'</span>].apply(<span class="keyword">lambda</span> x: x.strip())</span><br><span class="line">combine[<span class="string">'Title'</span>] = combine[<span class="string">'Title'</span>].replace([<span class="string">'Major'</span>,<span class="string">'Capt'</span>,<span class="string">'Rev'</span>,<span class="string">'Col'</span>,<span class="string">'Dr'</span>],<span class="string">'officer'</span>)</span><br><span class="line">combine[<span class="string">'Title'</span>] = combine[<span class="string">'Title'</span>].replace([<span class="string">'Mlle'</span>,<span class="string">'Miss'</span>], <span class="string">'Miss'</span>)</span><br><span class="line">combine[<span class="string">'Title'</span>] = combine[<span class="string">'Title'</span>].replace([<span class="string">'Mme'</span>,<span class="string">'Ms'</span>,<span class="string">'Mrs'</span>], <span class="string">'Mrs'</span>)</span><br><span class="line">combine[<span class="string">'Title'</span>] = combine[<span class="string">'Title'</span>].replace([<span class="string">'Master'</span>,<span class="string">'Jonkheer'</span>], <span class="string">'Master'</span>)</span><br><span class="line">combine[<span class="string">'Title'</span>] = combine[<span class="string">'Title'</span>].replace([<span class="string">'Don'</span>, <span class="string">'Sir'</span>, <span class="string">'the Countess'</span>, <span class="string">'Dona'</span>, <span class="string">'Lady'</span>], <span class="string">'Royalty'</span>)</span><br><span class="line">df = pd.get_dummies(combine[<span class="string">'Title'</span>],prefix=<span class="string">'Title'</span>)</span><br><span class="line">combine = pd.concat([combine,df], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Fare"><a href="#Fare" class="headerlink" title="Fare"></a>Fare</h3><p>该项只有一个缺失值，对该值进行填充,我们可以按照阶级均价来填充</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combine[<span class="string">'Fare'</span>] = combine[<span class="string">'Fare'</span>].fillna(combine.groupby(<span class="string">'Pclass'</span>)[<span class="string">'Fare'</span>].transform(np.mean))</span><br></pre></td></tr></table></figure>
<p>通过对Ticket简单的统计，我们可以看到部分票号数据有重复，同时结合亲属人数及名字的数据，和票价船舱等级对比，我们可以知道购买的票中有团体票，所以我们需要将团体票的票价分配到每个人的头上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combine[<span class="string">'Group_Ticket'</span>] = combine[<span class="string">'Fare'</span>].groupby(by=combine[<span class="string">'Ticket'</span>]).transform(<span class="string">'count'</span>)</span><br><span class="line">combine[<span class="string">'Fare'</span>] = combine[<span class="string">'Fare'</span>] / combine[<span class="string">'Group_Ticket'</span>]</span><br><span class="line">combine.drop([<span class="string">'Group_Ticket'</span>], axis=<span class="number">1</span>, inplace=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  分级</span></span><br><span class="line">combine[<span class="string">'Fare_1'</span>] = np.where(combine[<span class="string">'Fare'</span>] &lt;= <span class="number">7.91</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">combine[<span class="string">'Fare_2'</span>] = np.where((combine[<span class="string">'Fare'</span>] &gt; <span class="number">7.91</span>) &amp; (combine[<span class="string">'Fare'</span>] &lt;= <span class="number">14.454</span>),<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">combine[<span class="string">'Fare_3'</span>] = np.where((combine[<span class="string">'Fare'</span>] &gt; <span class="number">14.454</span>)&amp; (combine[<span class="string">'Fare'</span>] &lt;= <span class="number">31</span>),<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">combine[<span class="string">'Fare_4'</span>] = np.where((combine[<span class="string">'Fare'</span>] &gt; <span class="number">31</span>),<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">combine = combine.drop(<span class="string">'Fare'</span>,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Dead-female-family-amp-Survive-male-family"><a href="#Dead-female-family-amp-Survive-male-family" class="headerlink" title="Dead_female_family &amp; Survive_male_family"></a>Dead_female_family &amp; Survive_male_family</h3><p>前面分析可以知道，家庭的行为具有一致性，那么如果家族中有一个女的死亡，那么其他女性也倾向于死亡，反之，如果有男性生还，其他男性也会倾向于生还，为了防止模型无脑判断女性生还和男性死亡，在这里分出这两类情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combine[<span class="string">'Fname'</span>] = combine[<span class="string">'Name'</span>].apply(<span class="keyword">lambda</span> x:x.split(<span class="string">','</span>)[<span class="number">0</span>])</span><br><span class="line">combine[<span class="string">'Familysize'</span>] = combine[<span class="string">'SibSp'</span>]+combine[<span class="string">'Parch'</span>]</span><br><span class="line">dead_female_Fname = list(set(combine[(combine.Sex==<span class="string">'female'</span>) &amp; (combine.Age&gt;=<span class="number">12</span>) &amp; (combine.Survived==<span class="number">0</span>) &amp; (combine.Familysize&gt;<span class="number">1</span>)][<span class="string">'Fname'</span>].values))</span><br><span class="line">survive_male_Fname = list(set(combine[(combine.Sex==<span class="string">'male'</span>) &amp; (combine.Age&gt;=<span class="number">12</span>) &amp; (combine.Survived==<span class="number">1</span>) &amp; (combine.Familysize&gt;<span class="number">1</span>)][<span class="string">'Fname'</span>].values))</span><br><span class="line">combine[<span class="string">'Dead_female_family'</span>] = np.where(combine[<span class="string">'Fname'</span>].isin(dead_female_Fname),<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">combine[<span class="string">'Survive_male_family'</span>] = np.where(combine[<span class="string">'Fname'</span>].isin(survive_male_Fname),<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">combine = combine.drop([<span class="string">'Name'</span>,<span class="string">'Fname'</span>,<span class="string">'Familysize'</span>],axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h3><p>Age缺失值太多，可以按照阶级性别的平均年龄填充，也可以利用机器学习算法来预测,这里我们采用第一种方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">group = combine.groupby([<span class="string">'Title'</span>, <span class="string">'Pclass'</span>])[<span class="string">'Age'</span>]</span><br><span class="line">combine[<span class="string">'Age'</span>] = group.transform(<span class="keyword">lambda</span> x: x.fillna(x.median()))</span><br><span class="line">combine[<span class="string">'IsChild'</span>] = np.where(combine[<span class="string">'Age'</span>]&lt;=<span class="number">12</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># combine['Age'] = pd.cut(combine['Age'],5)</span></span><br><span class="line">combine = combine.drop([<span class="string">'Title'</span>],axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Cabin"><a href="#Cabin" class="headerlink" title="Cabin"></a>Cabin</h3><p>Cabin的缺失值太多，但是根据之前的分析，该特征值的有无与生还与否也相关性，所以我们将其分为两类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combine[<span class="string">'Cabin_0'</span>] = np.where(combine[<span class="string">'Cabin'</span>].isnull(),<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">combine[<span class="string">'Cabin_1'</span>] = np.where(combine[<span class="string">'Cabin'</span>].isnull(),<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">combine = combine.drop(<span class="string">'Cabin'</span>,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Pclass"><a href="#Pclass" class="headerlink" title="Pclass"></a>Pclass</h3><p>Pclass这一项，只需要将其转换为dummy形式就可以了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.get_dummies(combine[<span class="string">'Pclass'</span>], prefix=<span class="string">'Pclass'</span>)</span><br><span class="line">combine = pd.concat([combine, df], axis=<span class="number">1</span>).drop(<span class="string">'Pclass'</span>,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Ticket-1"><a href="#Ticket-1" class="headerlink" title="Ticket"></a>Ticket</h3><p>Ticket 在前面并没有分析，主要是因为里面有英文有数字，难以分析出规律，但是只看英文数字结合的票号，不难发现，票号前面的英文应该代表着位置信息，那么位置影响逃生路线，故将这部分提取出来做特征处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combine[<span class="string">'Ticket_Lett'</span>] = combine[<span class="string">'Ticket'</span>].apply(<span class="keyword">lambda</span> x: str(x)[<span class="number">0</span>])</span><br><span class="line">combine[<span class="string">'Ticket_Lett'</span>] = combine[<span class="string">'Ticket_Lett'</span>].apply(<span class="keyword">lambda</span> x: str(x))</span><br><span class="line"></span><br><span class="line">combine[<span class="string">'High_Survival_Ticket'</span>] = np.where(combine[<span class="string">'Ticket_Lett'</span>].isin([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'P'</span>,<span class="string">'9'</span>,<span class="string">'F'</span>]),<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">combine[<span class="string">'mid_Survival_Ticket'</span>] = np.where(combine[<span class="string">'Ticket_Lett'</span>].isin([<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'L'</span>,<span class="string">'S'</span>]),<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">combine[<span class="string">'Low_Survival_Ticket'</span>] = np.where(combine[<span class="string">'Ticket_Lett'</span>].isin([<span class="string">'A'</span>,<span class="string">'W'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>]),<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">combine = combine.drop([<span class="string">'Ticket'</span>,<span class="string">'Ticket_Lett'</span>],axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Sex"><a href="#Sex" class="headerlink" title="Sex"></a>Sex</h3><p>对Sex进行one-hot编码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.get_dummies(combine[<span class="string">'Sex'</span>], prefix=<span class="string">'Sex'</span>)</span><br><span class="line">combine = pd.concat([combine, df],axis=<span class="number">1</span>).drop(<span class="string">'Sex'</span>,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Parch-and-SibSp"><a href="#Parch-and-SibSp" class="headerlink" title="Parch and SibSp"></a>Parch and SibSp</h3><p>亲友数量是会影响到生存率的，那么将这两项合为一项</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combine[<span class="string">'Family_size'</span>] = np.where((combine[<span class="string">'Parch'</span>]+combine[<span class="string">'SibSp'</span>]==<span class="number">0</span>),<span class="string">'Alone'</span>,</span><br><span class="line">                                  np.where((combine[<span class="string">'Parch'</span>]+combine[<span class="string">'SibSp'</span>]&lt;=<span class="number">3</span>),<span class="string">'Small'</span>,<span class="string">'Big'</span>))</span><br><span class="line"></span><br><span class="line">df = pd.get_dummies(combine[<span class="string">'Family_size'</span>], prefix=<span class="string">'Family_size'</span>)</span><br><span class="line">combine = pd.concat([combine,df],axis=<span class="number">1</span>).drop([<span class="string">'SibSp'</span>,<span class="string">'Parch'</span>,<span class="string">'Family_size'</span>],axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="将所有特征转换正数值型编码"><a href="#将所有特征转换正数值型编码" class="headerlink" title="将所有特征转换正数值型编码"></a>将所有特征转换正数值型编码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">features = combine.drop([<span class="string">"PassengerId"</span>,<span class="string">"Survived"</span>], axis=<span class="number">1</span>).columns</span><br><span class="line">le = LabelEncoder()</span><br><span class="line"><span class="keyword">for</span> feature <span class="keyword">in</span> features:</span><br><span class="line">    le = le.fit(combine[feature])</span><br><span class="line">    combine[feature] = le.transform(combine[feature])</span><br></pre></td></tr></table></figure>
<h3 id="将训练数据和测试数据分开"><a href="#将训练数据和测试数据分开" class="headerlink" title="将训练数据和测试数据分开"></a>将训练数据和测试数据分开</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_train = combine.iloc[:<span class="number">891</span>,:].drop([<span class="string">'PassengerId'</span>, <span class="string">'Survived'</span>],axis=<span class="number">1</span>)</span><br><span class="line">y_train = combine.iloc[:<span class="number">891</span>,:][<span class="string">'Survived'</span>]</span><br><span class="line">x_test = combine.iloc[<span class="number">891</span>:,:].drop([<span class="string">'PassengerId'</span>,<span class="string">'Survived'</span>], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="模型比较"><a href="#模型比较" class="headerlink" title="模型比较"></a>模型比较</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># logistic Regression</span></span><br><span class="line">Logreg = LogisticRegression()</span><br><span class="line">Logreg.fit(x_train,y_train)</span><br><span class="line">y_pred = Logreg.predict(x_test)</span><br><span class="line">acc_logreg = round(Logreg.score(x_train, y_train) * <span class="number">100</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Support Vector Machines</span></span><br><span class="line">svc = SVC()</span><br><span class="line">svc.fit(x_train, y_train)</span><br><span class="line">y_pred = svc.predict(x_test)</span><br><span class="line">acc_svc = round(svc.score(x_train, y_train) *<span class="number">100</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># K-Nearest Neighbors</span></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line">knn.fit(x_train, y_train)</span><br><span class="line">y_pred = knn.predict(x_test)</span><br><span class="line">acc_knn = round(knn.score(x_train, y_train) * <span class="number">100</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Random Forest</span></span><br><span class="line">rf = RandomForestClassifier(n_estimators=<span class="number">100</span>)</span><br><span class="line">rf.fit(x_train, y_train)</span><br><span class="line">y_pred = rf.predict(x_test)</span><br><span class="line">acc_rf = round(rf.score(x_train, y_train) * <span class="number">100</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decision Tree</span></span><br><span class="line">dec_tree = DecisionTreeClassifier()</span><br><span class="line">dec_tree.fit(x_train, y_train)</span><br><span class="line">y_pred = dec_tree.predict(x_test)</span><br><span class="line">acc_dec_tree = round(dec_tree.score(x_train,y_train) * <span class="number">100</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># XGBoost</span></span><br><span class="line">xgb = XGBClassifier(max_depth=<span class="number">3</span>, n_estimators=<span class="number">300</span>, learning_rate=<span class="number">0.03</span>)</span><br><span class="line">xgb.fit(x_train,y_train)</span><br><span class="line">y_pred = xgb.predict(x_test)</span><br><span class="line">acc_xgb = round(xgb.score(x_train,y_train) * <span class="number">100</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">models = pd.DataFrame(&#123;<span class="string">'model'</span>:[<span class="string">'Logreg'</span>,<span class="string">'svc'</span>,<span class="string">'knn'</span>,<span class="string">'rf'</span>,<span class="string">'dec_tree'</span>,<span class="string">'xgb'</span>],</span><br><span class="line">                       <span class="string">'Score'</span>:[acc_logreg,acc_svc,acc_knn,acc_rf,acc_dec_tree,acc_xgb]&#125;)</span><br><span class="line"></span><br><span class="line">print(models.sort_values(by=<span class="string">'Score'</span>, ascending=<span class="keyword">False</span>))</span><br></pre></td></tr></table></figure>
<pre><code>   Score     model
4  99.21  dec_tree
3  99.10        rf
5  88.55       xgb
2  87.32       knn
1  87.09       svc
0  86.31    Logreg
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># XGB</span></span><br><span class="line">xgb = XGBClassifier()</span><br><span class="line">xgb.fit(x_train,y_train)</span><br><span class="line">y_pred = xgb.predict(x_test).astype(int)<span class="comment"># 该列必须是整型，否则格式不对，得分0分（别问我怎么知道的）</span></span><br><span class="line"><span class="comment"># 只得到了78分的成绩</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">subminssion = pd.DataFrame(&#123;<span class="string">"PassengerId"</span>: data_test[<span class="string">"PassengerId"</span>],<span class="string">"Survived"</span>: y_pred&#125;)</span><br><span class="line">subminssion.to_csv(<span class="string">'submission.csv'</span>,index=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure>
<p>最后，提交结果后，发现得到了11% 的排名，这里没有做模型融合，模型的调参也不怎么熟练，特征工程也做的一般，所以还是有很大的优化空间的。</p>
]]></content>
      <categories>
        <category>机器学习项目</category>
        <category>kaggle</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>kaggle</tag>
      </tags>
  </entry>
  <entry>
    <title>统计分析之集中趋势与离中趋势</title>
    <url>/blogs/d999db0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="//cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><blockquote>
<p>统计指标对<strong>定量数据</strong>进行统计描述，常从<strong>集中趋势</strong>和<strong>离中趋势</strong>两个方面进行分析</p>
</blockquote>
<h1 id="集中趋势度量"><a href="#集中趋势度量" class="headerlink" title="集中趋势度量"></a>集中趋势度量</h1><blockquote>
<p>指一组数据向某一中心靠拢的倾向，核心在于寻找数据的代表值或中心值</p>
<p>取得集中趋势代表值的方法有两种：<strong>数值平均数</strong>和 <strong>位置平均数</strong></p>
<ul>
<li>数值平均数<ul>
<li>算数平均数</li>
<li>调和平均数</li>
<li>几何平均数</li>
</ul>
</li>
<li>位置平均数<ul>
<li>众数</li>
<li>中位数</li>
</ul>
</li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="数值平均数"><a href="#数值平均数" class="headerlink" title="数值平均数"></a>数值平均数</h2><h3 id="算数平均数"><a href="#算数平均数" class="headerlink" title="算数平均数"></a>算数平均数</h3><blockquote>
<p>关注数值，鲁棒性弱（稳定性较弱，易受到异常值影响）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;<span class="string">'value'</span>:np.random.randint(<span class="number">100</span>,<span class="number">120</span>,<span class="number">100</span>),</span><br><span class="line">                    <span class="string">'f'</span>:np.random.rand(<span class="number">100</span>)&#125;)</span><br><span class="line">data[<span class="string">'f'</span>] = data[<span class="string">'f'</span>] / data[<span class="string">'f'</span>].sum()  <span class="comment"># f为权重，这里将f列设置成总和为1的权重占比</span></span><br><span class="line">print(data.head())</span><br><span class="line">print(<span class="string">'-----------------'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 算数平均值</span></span><br><span class="line">mean = data[<span class="string">'value'</span>].mean()</span><br><span class="line">print(<span class="string">'算数平均数为：%.2f'</span>%mean)</span><br><span class="line"></span><br><span class="line">mean_w = (data[<span class="string">'value'</span>] * data[<span class="string">'f'</span>]).sum() / data[<span class="string">'f'</span>].sum()</span><br><span class="line">print(<span class="string">'加权算数平均值为：%.2f'</span>%mean_w)</span><br><span class="line"><span class="comment"># 加权算数平均值 = (x1f1 + x2f2 + ... + xnfn) / (f1 + f2 + ... + fn)</span></span><br></pre></td></tr></table></figure>
<pre><code>          f  value
0  0.014970    118
1  0.007184    116
2  0.007459    101
3  0.005892    110
4  0.016599    119
-----------------
算数平均数为：110.09
加权算数平均值为：110.69
</code></pre><h3 id="几何平均数"><a href="#几何平均数" class="headerlink" title="几何平均数"></a>几何平均数</h3><blockquote>
<p>计算几何平均数要求各观察值之间存在连乘积关系，它的主要用途是</p>
<ol>
<li>对比率、指数等进行平均</li>
<li>计算平均发展速度<ul>
<li>样本数据非负，主要用于对数正态分布</li>
</ul>
</li>
<li>复利下的平均年利率</li>
<li>连续作业的车间求产品的平均合格率</li>
</ol>
</blockquote>
<p>$$<br>G_{n} = \sqrt[n]{x_{1}x_{2}x_{3}x_{4}x_{…}x_{n}}\<br>$$</p>
<p><a href="https://baike.baidu.com/item/%E5%87%A0%E4%BD%95%E5%B9%B3%E5%9D%87%E6%95%B0/5557084#4" target="_blank" rel="noopener">几何平均数(百度百科)</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一位投资者持有股票，1996年，1997年，1998年，1999年收益率分别为</span></span><br><span class="line"><span class="comment"># 4.5%, 2.0%, 3.5%, 5.4%,</span></span><br><span class="line"><span class="comment"># 求此4年内平均收益率</span></span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> gmean</span><br><span class="line">data_g = gmean(data[<span class="string">'value'</span>])</span><br><span class="line">data_g</span><br></pre></td></tr></table></figure>
<pre><code>109.96165465844449
</code></pre><h3 id="位置平均数"><a href="#位置平均数" class="headerlink" title="位置平均数"></a>位置平均数</h3><blockquote>
<p>中位数：</p>
<ul>
<li>关注顺序，鲁棒性强</li>
</ul>
</blockquote>
<p>当N为奇数时：<br>$$m_{0.5} = X_{(N+1)/2}$$<br>当N为偶数时：<br>$$m_{0.5} = \frac{X_{(N/2)}+X_{(N/2+1)}}{2}$$</p>
<blockquote>
<p>众数：</p>
<ul>
<li>关注频次</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 中位数</span></span><br><span class="line">med = data[<span class="string">'value'</span>].median()</span><br><span class="line">print(<span class="string">'中位数为%i'</span> % med)</span><br><span class="line"><span class="comment"># 中位数指将总体各单位标志按照大小顺序排列后，中间位置的数字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 众数</span></span><br><span class="line">m = data[<span class="string">'value'</span>].mode()</span><br><span class="line">print(<span class="string">'众数为'</span>,m.tolist())</span><br><span class="line"><span class="comment"># 众数是一组数据中出现次数最多的数，这里可能返回多个值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 密度曲线</span></span><br><span class="line">data[<span class="string">'value'</span>].plot(kind=<span class="string">'kde'</span>,style=<span class="string">'--k'</span>,grid=<span class="keyword">True</span>,figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单算术平均</span></span><br><span class="line">plt.axvline(mean,hold=<span class="keyword">None</span>,color=<span class="string">'r'</span>,linestyle=<span class="string">'--'</span>,alpha=<span class="number">0.8</span>)</span><br><span class="line">plt.text(mean+<span class="number">5</span>,<span class="number">0.005</span>,<span class="string">'简单算术平均值：%.2f'</span> % mean,color=<span class="string">'r'</span>,fontsize=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加权平均数</span></span><br><span class="line">plt.axvline(mean_w,hold=<span class="keyword">None</span>,color=<span class="string">'b'</span>,linestyle=<span class="string">'--'</span>,alpha=<span class="number">0.8</span>)</span><br><span class="line">plt.text(mean+<span class="number">5</span>,<span class="number">0.01</span>,<span class="string">'加权平均值：%.2f'</span> % mean_w,color=<span class="string">'b'</span>,fontsize=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 几何平均数</span></span><br><span class="line">plt.axvline(data_g,hold=<span class="keyword">None</span>,color=<span class="string">'g'</span>,linestyle=<span class="string">'--'</span>,alpha=<span class="number">0.8</span>)</span><br><span class="line">plt.text(mean+<span class="number">5</span>,<span class="number">0.015</span>,<span class="string">'几何平均值：%.2f'</span> % data_g,color=<span class="string">'g'</span>,fontsize=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中位数</span></span><br><span class="line">plt.axvline(med,hold=<span class="keyword">None</span>,color=<span class="string">'y'</span>,linestyle=<span class="string">'--'</span>,alpha=<span class="number">0.8</span>)</span><br><span class="line">plt.text(mean+<span class="number">5</span>,<span class="number">0.020</span>,<span class="string">'几何平均值：%.2f'</span> % med,color=<span class="string">'y'</span>,fontsize=<span class="number">15</span>)</span><br></pre></td></tr></table></figure>
<pre><code>中位数为110
众数为 [108]

Text(115.09,0.02,&apos;几何平均值：110.00&apos;)
</code></pre><img src="/blogs/d999db0/2018-05-03-discrete_tendency_and_central_tendency01.jpg" title="图1">
<h1 id="离中趋势度"><a href="#离中趋势度" class="headerlink" title="离中趋势度"></a>离中趋势度</h1><blockquote>
<p>是指一组数据中个数据值以不同程度偏离其中心（平均数）的趋势，又称标志变动度</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建数据，销售数据</span></span><br><span class="line">data = pd.DataFrame(&#123;<span class="string">'A_sale'</span>:np.random.rand(<span class="number">30</span>)*<span class="number">1000</span>,</span><br><span class="line">                    <span class="string">'B_sale'</span>:np.random.rand(<span class="number">30</span>)*<span class="number">1000</span>&#125;,</span><br><span class="line">                   index = pd.period_range(<span class="string">'20170601'</span>,<span class="string">'20170630'</span>))</span><br><span class="line">print(data.head())</span><br></pre></td></tr></table></figure>
<pre><code>                A_sale      B_sale
2017-06-01  574.693080  970.059264
2017-06-02  278.487440  683.602258
2017-06-03  830.472896  293.102768
2017-06-04  505.211093  268.009253
2017-06-05  316.383594  134.011541
</code></pre><h2 id="极差与分位差"><a href="#极差与分位差" class="headerlink" title="极差与分位差"></a>极差与分位差</h2><blockquote>
<p>极差：</p>
<ul>
<li>没有考虑中间值的变动情况，测定离中趋势时不准确</li>
</ul>
<p>分位差：</p>
<ul>
<li>从一组数据踢出部分极端值后的从新计算类似极差的指标，常用的有 <strong>四分位差，八分位差</strong></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a_r = data[<span class="string">'A_sale'</span>].max() - data[<span class="string">'A_sale'</span>].min()</span><br><span class="line">b_r = data[<span class="string">'B_sale'</span>].max() - data[<span class="string">'B_sale'</span>].min()</span><br><span class="line">print(<span class="string">'A产品销售额极差为：%.2f,B产品销售额极差为：%.2f'</span>%(a_r,b_r))</span><br></pre></td></tr></table></figure>
<pre><code>A产品销售额极差为：920.98,B产品销售额极差为：914.30
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sta = data[<span class="string">'A_sale'</span>].describe()</span><br><span class="line">stb = data[<span class="string">'B_sale'</span>].describe()</span><br><span class="line"><span class="comment">#print(sta)</span></span><br><span class="line">a_iqr = sta.loc[<span class="string">'75%'</span>] - sta.loc[<span class="string">'25%'</span>]</span><br><span class="line">b_iqr = stb.loc[<span class="string">'75%'</span>] - stb.loc[<span class="string">'25%'</span>]</span><br><span class="line">print(<span class="string">'A销售额的分位差为：%.2f, B销售额的分位差为：%.2f'</span> % (a_iqr,b_iqr))</span><br></pre></td></tr></table></figure>
<pre><code>A销售额的分位差为：481.57, B销售额的分位差为：508.45
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制箱型图</span></span><br><span class="line"></span><br><span class="line">color = dict(boxes=<span class="string">'DarkGreen'</span>, whiskers=<span class="string">'DarkOrange'</span>, medians=<span class="string">'DarkBlue'</span>, caps=<span class="string">'Gray'</span>)</span><br><span class="line">data.plot.box(vert=<span class="keyword">False</span>,grid = <span class="keyword">True</span>,color = color,figsize = (<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment"># 箱型图</span></span><br></pre></td></tr></table></figure>

<h2 id="方差与标准差"><a href="#方差与标准差" class="headerlink" title="方差与标准差"></a>方差与标准差</h2><ul>
<li>平均差：平均差是总体所有单位与其算术平均数的离差绝对值的算术平均数，1范数，异常值影响</li>
</ul>
<p>$$<br>MD = \frac{\sum_N |x - \bar{x}|}{N}<br>$$</p>
<ul>
<li>方差：差的平方的均值，2范数，异常值影响</li>
</ul>
<p>总体方差</p>
<p>$$<br>\sigma^2 = \frac{\sum_N (X-E(X))^2}{N}<br>$$</p>
<p>样本方差</p>
<p>$$<br>s^2 = \frac{\sum_N (x - \bar{x})^2}{N-1}<br>$$</p>
<ul>
<li>标准差：方差的算数平方根（应用最广）</li>
</ul>
<blockquote>
<p>平均差 VS 方差：对异常值的敏感程度不同</p>
</blockquote>
<ul>
<li>离散系数（常用的是标准差系数：数据标准差和算数平均数的比）</li>
</ul>
<p>$$<br>CV = \frac{\sigma}{\mu}<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a_std = sta.loc[<span class="string">'std'</span>]</span><br><span class="line">b_std = stb.loc[<span class="string">'std'</span>]</span><br><span class="line">a_var = data[<span class="string">'A_sale'</span>].var()</span><br><span class="line">b_var = data[<span class="string">'B_sale'</span>].var()</span><br><span class="line">print(<span class="string">'A销售额的标准差为：%.2f, B销售额的标准差为：%.2f'</span> % (a_std,b_std))</span><br><span class="line">print(<span class="string">'A销售额的方差为：%.2f, B销售额的方差为：%.2f'</span> % (a_var,b_var))</span><br><span class="line"><span class="comment"># 方差 → 各组中数值与算数平均数离差平方的算术平均数</span></span><br><span class="line"><span class="comment"># 标准差 → 方差的平方根</span></span><br><span class="line"><span class="comment"># 标准差是最常用的离中趋势指标 → 标准差越大，离中趋势越明显</span></span><br></pre></td></tr></table></figure>
<pre><code>A销售额的标准差为：292.12, B销售额的标准差为：293.35
A销售额的方差为：85331.19, B销售额的方差为：86052.83
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure(figsize = (<span class="number">12</span>,<span class="number">4</span>))</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">data[<span class="string">'A_sale'</span>].plot(kind = <span class="string">'kde'</span>,style = <span class="string">'k--'</span>,grid = <span class="keyword">True</span>,title = <span class="string">'A密度曲线'</span>)</span><br><span class="line">plt.axvline(sta.loc[<span class="string">'50%'</span>],hold=<span class="keyword">None</span>,color=<span class="string">'r'</span>,linestyle=<span class="string">"--"</span>,alpha=<span class="number">0.8</span>)  </span><br><span class="line">plt.axvline(sta.loc[<span class="string">'50%'</span>] - a_std,hold=<span class="keyword">None</span>,color=<span class="string">'b'</span>,linestyle=<span class="string">"--"</span>,alpha=<span class="number">0.8</span>)  </span><br><span class="line">plt.axvline(sta.loc[<span class="string">'50%'</span>] + a_std,hold=<span class="keyword">None</span>,color=<span class="string">'b'</span>,linestyle=<span class="string">"--"</span>,alpha=<span class="number">0.8</span>)  </span><br><span class="line"><span class="comment"># A密度曲线，1个标准差</span></span><br><span class="line"></span><br><span class="line">ax2 = fig.add_subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">data[<span class="string">'B_sale'</span>].plot(kind = <span class="string">'kde'</span>,style = <span class="string">'k--'</span>,grid = <span class="keyword">True</span>,title = <span class="string">'B密度曲线'</span>)</span><br><span class="line">plt.axvline(stb.loc[<span class="string">'50%'</span>],hold=<span class="keyword">None</span>,color=<span class="string">'r'</span>,linestyle=<span class="string">"--"</span>,alpha=<span class="number">0.8</span>)  </span><br><span class="line">plt.axvline(stb.loc[<span class="string">'50%'</span>] - b_std,hold=<span class="keyword">None</span>,color=<span class="string">'b'</span>,linestyle=<span class="string">"--"</span>,alpha=<span class="number">0.8</span>)  </span><br><span class="line">plt.axvline(stb.loc[<span class="string">'50%'</span>] + b_std,hold=<span class="keyword">None</span>,color=<span class="string">'b'</span>,linestyle=<span class="string">"--"</span>,alpha=<span class="number">0.8</span>)  </span><br><span class="line"><span class="comment"># B密度曲线，1个标准差</span></span><br></pre></td></tr></table></figure>
<img src="/blogs/d999db0/2018-05-03-discrete_tendency_and_central_tendency03.png" title="图3">
]]></content>
      <categories>
        <category>统计学习</category>
      </categories>
      <tags>
        <tag>统计学习</tag>
        <tag>特征分析</tag>
      </tags>
  </entry>
</search>
